(function () {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var mergexml = createCommonjsModule(function (module, exports) {
	/**
	 * XML merging class
	 * Merge multiple XML sources
	 * 
	 * @package     MergeXML
	 * @author      Vallo Reima
	 * @copyright   (C)2014-2016
	 */

	/**
	 * AMD/CommonJS wrapper
	 * @param {object} root
	 * @param {function} factory
	 */
	(function(root, factory) {
	  {
	    // Does not work with strict CommonJS, 
	    // but only CommonJS-like environments 
	    // that support module.exports, like Node
	    module.exports = factory();
	  }
	}(commonjsGlobal, function() {
	  /**
	   * Return a function as the exported value
	   * @param {object} opts -- stay, join, updn (see readme)
	   */
	  return function(opts) {

	    var mde;        /* access mode 0,1,2 */
	    var msv;        /* MS DOM version */
	    var psr;        /* DOM parser object */
	    var nse;        /* parsererror namespace */
	    var xpe;        /* xPath evaluator */
	    var nsr;        /* namespace resolver */
	    var nsd = '_';  /* default namespace prefix */
	    var stay;       /* overwrite protection */
	    var join;       /* joining root name and status*/
	    var updn;       /* update nodes sequentially by name */
	    var XML_ELEMENT_NODE = 1;
	    var XML_TEXT_NODE = 3;
	    var XML_COMMENT_NODE = 8;
	    var XML_PI_NODE = 7;
	    var that = this;

	    that.Init = function() {
	      that.dom = null; /* result DOM object */
	      that.nsp = {};   /* namespaces */
	      that.count = 0; /* adding counter */
	      join[1] = false;
	      if (mde > 0) {
	        that.error = {code: '', text: ''};
	      }
	      return (mde > 0);
	    };

	    /**
	     * add XML file
	     * @param {object} file -- FileList element
	     * @return {object|false}
	     */
	    that.AddFile = function(file) {
	      var rlt;
	      if (!file || !file.target) {
	        rlt = Error('nof');
	      } else if (!file.target.result) {
	        rlt = Error('emf');
	      } else {
	        rlt = that.AddSource(file.target.result);
	      }
	      return rlt;
	    };

	    /**
	     * add XML string
	     * @param {string|oobject} xml
	     * @return mixed -- false - bad content
	     *                  object - result
	     */
	    that.AddSource = function(xml) {
	      var rlt, doc;
	      if (typeof xml === 'object') {
	        doc = that.Get(1, xml) ? xml : false;
	        if (doc && ((mde === 1 && !window.DOMParser) || (mde === 2 && !doc.selectSingleNode('/')))) {
	          doc = null; /* not compatible */
	        }
	      } else {
	        try {
	          doc = Load(xml);
	        } catch (e) {
	          doc = false;
	        }
	      }
	      if (doc === null) {
	        rlt = Error('nos');
	      } else if (doc === false) {
	        rlt = Error('inv');
	      } else if (doc === true) {
	        that.nsp = NameSpaces(that.dom.documentElement);
	        that.count = 1;
	        rlt = that.dom;
	      } else if (CheckSource(doc)) {
	        Merge(doc, '/');  /* add to existing */
	        if (join[1] === true) {
	          var tmp = that.dom.createTextNode("\r\n");
	          that.dom.documentElement.appendChild(tmp);
	        }
	        that.count++;
	        rlt = that.dom;
	      } else {
	        rlt = false;
	      }
	      return rlt;
	    };

	    /**
	     * load the source into dom object
	     * @param {object|string} src -- the source
	     * @return {mixed} -- false - error
	     *                    true - 1st load
	     *                    object - loaded doc
	     */
	    var Load = function(src) {
	      var rlt, doc;
	      if (mde === 1) {
	        if (that.dom) {
	          doc = psr.parseFromString(src, 'text/xml');
	          rlt = ParseError(doc) ? doc : false;
	        } else {
	          that.dom = psr.parseFromString(src, 'text/xml');
	          rlt = ParseError(that.dom) ? true : false;
	        }
	      } else if (that.dom) {
	        doc = new ActiveXObject(msv);
	        doc.async = false;
	        rlt = doc.loadXML(src) ? doc : false;
	      } else {
	        that.dom = new ActiveXObject(msv);
	        that.dom.async = false;
	        that.dom.setProperty('SelectionLanguage', 'XPath');
	        rlt = that.dom.loadXML(src) ? true : false;
	      }
	      return rlt;
	    };

	    /**
	     * check for xml syntax (mode 1)
	     * @param {object} doc
	     * @return {bool} -- true - ok
	     */
	    var ParseError = function(doc) {
	      return doc.getElementsByTagNameNS(nse, 'parsererror').length === 0;
	    };

	    /**
	     * 
	     * @param {object} doc
	     * @return {bool} -- true - ok
	     */
	    var CheckSource = function(doc) {
	      var rlt = true;
	      var charSet1 = that.dom.characterSet || that.dom.inputEncoding || that.dom.xmlEncoding;
	      var charSet2 = doc.characterSet || doc.inputEncoding || doc.xmlEncoding;
	      if (charSet2 !== charSet1) {
	        rlt = Error('enc');
	      } else if (doc.documentElement.namespaceURI !== that.dom.documentElement.namespaceURI) { /* $dom->documentElement->lookupnamespaceURI(NULL) */
	        rlt = Error('nse');
	      } else if (doc.documentElement.nodeName !== that.dom.documentElement.nodeName) {
	        if (!join[0]) {
	          rlt = Error('dif');
	        } else if (!join[1]) {
	          var enc = typeof charSet1 !== 'undefined' ? charSet1 : 'UTF-8';
	          var ver = that.dom.xmlVersion ? that.dom.xmlVersion : '1.0';
	          var xml = '<?xml version="' + ver + '" encoding="' + enc + "\"?>\r\n<" + join[0] + ">\r\n</" + join[0] + '>';
	          var d = Load(xml);
	          if (d) {
	            var tmp = that.dom.documentElement.cloneNode(true);
	            d.documentElement.appendChild(tmp);
	            tmp = d.createTextNode("\r\n");
	            d.documentElement.appendChild(tmp);
	            that.dom = d;
	            join[1] = true;
	          } else {
	            rlt = Error('jne');
	            join[1] = null;
	          }
	        }
	      }
	      if (rlt) {
	        var a = NameSpaces(doc.documentElement);
	        for (var c in a) {
	          if (!that.nsp[c]) {
	            if (typeof that.dom.documentElement.setAttributeNS !== 'undefined') {
	              that.dom.documentElement.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:' + c, a[c]);
	            } else {
	              // no choice but to use the incorrect setAttribute instead
	              that.dom.documentElement.setAttribute('xmlns:' + c, a[c]);
	            }
	            that.nsp[c] = a[c];
	          }
	        }
	        if (!updn) {
	          nsr = null;
	        } else if (mde === 1) {
	          nsr = Resolver;
	        } else {
	          ResolverIE();
	        }
	      }
	      return rlt;
	    };
	    /**
	     * join 2 dom objects recursively
	     * @param {object} src -- current source node
	     * @param {string} pth -- current source path
	     */
	    var Merge = function(src, pth) {
	      for (var i = 0; i < src.childNodes.length; i++) {
	        var tmp;
	        var node = src.childNodes[i]; //$node->getNodePath()
	        var path = GetNodePath(src.childNodes, node, pth, i);
	        var obj = that.Query(path);
	        if (node.nodeType === XML_ELEMENT_NODE) {
	          var flg = true;  /* replace existing node by default */
	          if (obj === null || obj.namespaceURI !== node.namespaceURI) {
	            tmp = node.cloneNode(true); /* take existing node */
	            obj = that.Query(pth); /* destination parent */
	            obj.appendChild(tmp); /* add a node */
	          } else {
	            if (ArraySearch(obj.getAttribute('stay'), stay) !== false) {
	              flg = false; /* don't replace */
	            }
	            if (flg) {
	              try {
	                for (var j = 0; j < node.attributes.length; j++) { /* add/replace attributes */
	                  if (node.attributes[j].namespaceURI && typeof node.setAttributeNS !== 'undefined') {
	                    obj.setAttributeNS(node.attributes[j].namespaceURI, node.attributes[j].nodeName, node.attributes[j].nodeValue);
	                  } else {
	                    obj.setAttribute(node.attributes[j].nodeName, node.attributes[j].nodeValue);
	                  }
	                }
	              } catch (e) {
	                /* read-only node */
	              }
	            }
	          }
	          if (node.hasChildNodes() && flg) {
	            Merge(node, path); /* go to subnodes */
	          }
	        } else if (node.nodeType === XML_TEXT_NODE || node.nodeType === XML_COMMENT_NODE) { /* leaf node */
	          if (obj === null || obj.nodeType !== node.nodeType) {
	            obj = that.Query(pth);    /* destination parent node */
	            if (node.nodeType === XML_TEXT_NODE) {
	              tmp = that.dom.createTextNode(node.nodeValue); /* add text */
	            } else {
	              tmp = that.dom.createComment(node.nodeValue);  /* add comment */
	            }
	            obj.appendChild(tmp); /* add leaf */
	          } else {
	            obj.nodeValue = node.nodeValue; /* replace leaf */
	          }
	        }
	      }
	    };

	    /**
	     * form the node xPath
	     * @param {object} nodes -- child nodes
	     * @param {object} node -- current child
	     * @param {string} pth -- parent path
	     * @param {int} eln -- element sequence number
	     * @return {string} query path
	     */
	    var GetNodePath = function(nodes, node, pth, eln) {
	      var p, i;
	      var j = 0;
	      if (node.nodeType === XML_ELEMENT_NODE) {
	        for (i = 0; i <= eln; i++) {
	          if ((updn && nodes[i].nodeType === node.nodeType && nodes[i].nodeName === node.nodeName) ||
	                  (!updn && nodes[i].nodeType !== XML_PI_NODE)) {
	            j++;
	          }
	        }
	        if (updn) {
	          var f = false;
	          var a = NameSpaces(node);
	          for (var c in a) {
	            if (c !== nsd) {
	              that.nsp[c] = a[c];
	              f = (mde === 2);
	            }
	          }
	          if (f) {
	            ResolverIE();
	          }
	          if (node.prefix) {
	            p = node.prefix + ':';
	          } else if (that.nsp[nsd]) {
	            p = nsd + ':';
	          } else {
	            p = '';
	          }
	          p += (node.localName ? node.localName : node.baseName);
	        } else {
	          p = 'node()';
	        }
	      } else if (node.nodeType === XML_TEXT_NODE || node.nodeType === XML_COMMENT_NODE) {
	        for (i = 0; i <= eln; i++) {
	          if (nodes[i].nodeType === node.nodeType) {
	            j++;
	          }
	        }
	        p = node.nodeType === XML_TEXT_NODE ? 'text()' : 'comment()';
	      } else {
	        p = pth;
	      }
	      if (j) {
	        p = pth + (pth.slice(-1) === '/' ? '' : '/') + p + '[' + j + ']';
	      }
	      return p;
	    };

	    /**
	     * get node's namespaces
	     * @param {object} node
	     * @return {array} 
	     */
	    var NameSpaces = function(node) {
	      var rlt = {};
	      var attrs = node.attributes;
	      for (var i = 0; i < attrs.length; ++i) {
	        var a = attrs[i].name.split(':');
	        if (a[0] === 'xmlns') {
	          var c = a[1] ? a[1] : nsd;
	          rlt[c] = attrs[i].value;
	        }
	      }
	      return rlt;
	    };

	    /**
	     * xPath query
	     * @param {string} qry -- query statement
	     * @return {object}
	     */
	    that.Query = function(qry) {
	      var rlt;
	      if (join[1]) {
	        qry = '/' + that.dom.documentElement.nodeName + (qry === '/' ? '' : qry);
	      }
	      try {
	        if (mde === 1) {
	          rlt = xpe.evaluate(qry, that.dom, nsr, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
	          rlt = rlt.singleNodeValue;
	        } else {
	          rlt = that.dom.selectSingleNode(qry);
	        }
	      }
	      catch (e) {
	        rlt = null; /* no such path */
	      }
	      return rlt;
	    };

	    /**
	     * XPathNSResolver 
	     * @param {string} pfx node prefix
	     * @return {string} namespace URI
	     */
	    var Resolver = function(pfx) {
	      return that.nsp[pfx] || null;
	    };

	    /**
	     * XPath IE Resolver 
	     */
	    var ResolverIE = function() {
	      var p = '';
	      for (var c in that.nsp) {
	        p += ' xmlns:' + c + '=' + "'" + that.nsp[c] + "'";
	      }
	      if (p) {
	        that.dom.setProperty('SelectionNamespaces', p.substr(1));
	      }
	    };

	    /**
	     * find array memeber by value
	     * @param {mixed} val
	     * @param {array} arr
	     * @returns {mixed}
	     */
	    var ArraySearch = function(val, arr) {
	      var rlt = false;
	      for (var key in arr) {
	        if (arr[key] === val) {
	          rlt = key;
	          break;
	        }
	      }
	      return rlt;
	    };

	    /**
	     * get result
	     * @param {int} flg -- 0 - object
	     *                     1 - xml
	     *                     2 - html
	     * @param {object} doc
	     * @return {mixed}
	     */
	    that.Get = function(flg, doc) {
	      var rlt;
	      if (flg && !doc) {
	        doc = that.dom;
	      }
	      if (!flg) {
	        rlt = that.dom;
	      } else if (!doc) {
	        rlt = '';
	      } else if (doc.xml) {
	        rlt = doc.xml;
	      } else {
	        try {
	          rlt = (new XMLSerializer()).serializeToString(doc);
	        } catch (e) {
	          rlt = null;
	        }
	      }
	      if (rlt && flg === 2) { /* make html view */
	        if (join[1]) {
	          var k = rlt.indexOf('<' + join[0]);
	          rlt = rlt.substr(0, k) + "\r\n" + rlt.substr(k);
	        }
	        rlt = rlt.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/ |\t/g, '&nbsp;'); /* tags and spaces */
	        rlt = rlt.replace(/(\r\n|\n|\r)/g, '<br>');  /* line breaks */
	      }
	      return rlt;
	    };

	    /**
	     * set error message
	     * @param {string} err -- token
	     * @return {false}
	     */
	    var Error = function(err) {
	      var errs = {
	        nod: 'XML DOM is not supported in this browser',
	        nox: 'xPath is not supported in this browser',
	        nos: 'Incompatible source object',
	        nof: 'File not found',
	        emf: 'File is empty', /* possible delivery fault */
	        inv: 'Invalid XML source',
	        enc: 'Different encoding',
	        dif: 'Different root nodes',
	        jne: 'Invalid join parameter',
	        nse: 'Namespace incompatibility',
	        und: 'Undefined error'
	      };
	      that.error.code = errs[err] ? err : 'und';
	      that.error.text = errs[that.error.code];
	      return false;
	    };

	    /**
	     * identify browser functionality
	     * @return {int|string} mode number or error code
	     */
	    var GetMode = function() {
	      var m;
	      var f = false;
	      var vers = [
	        'MSXML2.DOMDocument.6.0',
	        'MSXML2.DOMDocument.3.0',
	        'MSXML2.DOMDocument',
	        'Microsoft.XmlDom'
	      ];
	      var n = vers.length;
	      for (var i = 0; i < n; i++) {
	        try {
	          var d = new ActiveXObject(vers[i]);
	          d.async = false;
	          f = true;   /* DOM supported */
	          if (d.loadXML('<x></x>') && d.selectSingleNode('/')) {
	            break;    /* xPath supported */
	          }
	        } catch (e) {
	          /* skip */
	        }
	      }
	      if (f) {
	        if (i < n) {
	          msv = vers[i];
	          m = 2;  /* IE mode */
	        } else {
	          m = 'nox';  /* no xPath */
	        }
	      } else if (!window.DOMParser) {
	        m = 'nod';  /* no DOM */
	      } else if (!window.XPathEvaluator) {
	        m = 'nox';  /* no xPath */
	      } else {
	        psr = new DOMParser();
	        var e = psr.parseFromString('Invalid', 'text/xml'); /* to detect source error */
	        nse = e.getElementsByTagName('parsererror')[0].namespaceURI;
	        xpe = new XPathEvaluator();
	        m = 1;  /*  Firefox, Safari, Chrome, Opera */
	      }
	      return m;
	    };

	    if (typeof opts !== 'object') {
	      opts = {};
	    }
	    /* set stay attribute value to check */
	    if (typeof opts.stay === 'undefined') {
	      stay = ['all'];
	    } else if (!opts.stay) {
	      stay = [];
	    } else if (typeof opts.stay === 'object' && opts.stay instanceof Array) {
	      stay = opts.stay;
	    } else {
	      stay = [opts.stay];
	    }
	    /* set join condtion for different roots */
	    if (typeof opts.join === 'undefined') {
	      join = ['root'];
	    } else {
	      join = [opts.join ? String(opts.join) : false];
	    }
	    /* set update sequence manner */
	    if (typeof opts.updn === 'undefined') {
	      updn = true;
	    } else {
	      updn = opts.updn;
	    }
	    /* detect browser features: 2 - IE, 1 - rest, 0 - N/A */
	    mde = GetMode();
	    if (typeof mde === 'string') {
	      that.error = {};
	      Error(mde);
	      mde = 0;
	    }
	    that.Init();
	  };
	}));
	});

	/* global ArrayBuffer, Uint8Array */
	let cookies;

	/**
	 * Parses an Expression to extract all function calls and theirs argument arrays.
	 *
	 * @param  {String} expr The expression to search
	 * @param  {String} func The function name to search for
	 * @return {<String, <String*>>} The result array, where each result is an array containing the function call and array of arguments.
	 */
	function parseFunctionFromExpression( expr, func ) {
	    let index;
	    let result;
	    let openBrackets;
	    let start;
	    let argStart;
	    let args;
	    const findFunc = new RegExp( `${func}\\s*\\(`, 'g' );
	    const results = [];

	    if ( !expr || !func ) {
	        return results;
	    }

	    while ( ( result = findFunc.exec( expr ) ) !== null ) {
	        openBrackets = 1;
	        args = [];
	        start = result.index;
	        argStart = findFunc.lastIndex;
	        index = argStart - 1;
	        while ( openBrackets !== 0 && index < expr.length ) {
	            index++;
	            if ( expr[ index ] === '(' ) {
	                openBrackets++;
	            } else if ( expr[ index ] === ')' ) {
	                openBrackets--;
	            } else if ( expr[ index ] === ',' && openBrackets === 1 ) {
	                args.push( expr.substring( argStart, index ).trim() );
	                argStart = index + 1;
	            }
	        }
	        // add last argument
	        if ( argStart < index ) {
	            args.push( expr.substring( argStart, index ).trim() );
	        }

	        // add [ 'function( a ,b)', ['a','b'] ] to result array
	        results.push( [ expr.substring( start, index + 1 ), args ] );
	    }

	    return results;
	}

	function stripQuotes( str ) {
	    if ( /^".+"$/.test( str ) || /^'.+'$/.test( str ) ) {
	        return str.substring( 1, str.length - 1 );
	    }
	    return str;
	}

	// Because iOS gives any camera-provided file the same filename, we need to a 
	// unique-ified filename.
	// 
	// See https://github.com/kobotoolbox/enketo-express/issues/374
	function getFilename( file, postfix ) {
	    let filenameParts;
	    if ( typeof file === 'object' && file !== null && file.name ) {
	        postfix = postfix || '';
	        filenameParts = file.name.split( '.' );
	        if ( filenameParts.length > 1 ) {
	            filenameParts[ filenameParts.length - 2 ] += postfix;
	        } else if ( filenameParts.length === 1 ) {
	            filenameParts[ 0 ] += postfix;
	        }
	        return filenameParts.join( '.' );
	    }
	    return '';
	}

	/**
	 * Converts NodeLists or DOMtokenLists to an array
	 * @param  {[type]} list [description]
	 * @return {[type]}      [description]
	 */
	function toArray( list ) {
	    const array = [];
	    // iterate backwards ensuring that length is an UInt32
	    for ( let i = list.length >>> 0; i--; ) {
	        array[ i ] = list[ i ];
	    }
	    return array;
	}

	function isNumber( n ) {
	    return !isNaN( parseFloat( n ) ) && isFinite( n );
	}

	function readCookie( name ) {
	    let c;
	    let C;
	    let i;

	    if ( cookies ) {
	        return cookies[ name ];
	    }

	    c = document.cookie.split( '; ' );
	    cookies = {};

	    for ( i = c.length - 1; i >= 0; i-- ) {
	        C = c[ i ].split( '=' );
	        // decode URI
	        C[ 1 ] = decodeURIComponent( C[ 1 ] );
	        // if cookie is signed (using expressjs/cookie-parser/), extract value
	        if ( C[ 1 ].substr( 0, 2 ) === 's:' ) {
	            C[ 1 ] = C[ 1 ].slice( 2 );
	            C[ 1 ] = C[ 1 ].slice( 0, C[ 1 ].lastIndexOf( '.' ) );
	        }
	        cookies[ C[ 0 ] ] = decodeURIComponent( C[ 1 ] );
	    }

	    return cookies[ name ];
	}

	function dataUriToBlobSync( dataURI ) {
	    let byteString;
	    let mimeString;
	    let buffer;
	    let array;

	    // convert base64 to raw binary data held in a string
	    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
	    byteString = atob( dataURI.split( ',' )[ 1 ] );
	    // separate out the mime component
	    mimeString = dataURI.split( ',' )[ 0 ].split( ':' )[ 1 ].split( ';' )[ 0 ];

	    // write the bytes of the string to an ArrayBuffer
	    buffer = new ArrayBuffer( byteString.length );
	    array = new Uint8Array( buffer );

	    for ( let i = 0; i < byteString.length; i++ ) {
	        array[ i ] = byteString.charCodeAt( i );
	    }

	    // write the ArrayBuffer to a blob
	    return new Blob( [ array ], {
	        type: mimeString
	    } );
	}

	function getPasteData( event ) {
	    const clipboardData = event.originalEvent.clipboardData || window.clipboardData; // modern || IE11
	    return ( clipboardData ) ? clipboardData.getData( 'text' ) : null;
	}

	/**
	 * Update a HTML anchor to serve as a download or reset it if an empty objectUrl is provided.
	 * 
	 * @param {HTMLElement} anchor the anchor element
	 * @param {*} objectUrl the objectUrl to download
	 * @param {*} fileName  the filename of the file
	 */
	function updateDownloadLink( anchor, objectUrl, fileName ) {
	    if ( window.updateDownloadLinkIe11 ) {
	        return window.updateDownloadLinkIe11( ...arguments );
	    }
	    anchor.setAttribute( 'href', objectUrl || '' );
	    anchor.setAttribute( 'download', fileName || '' );
	}

	var jquery = createCommonjsModule(function (module) {
	/*!
	 * jQuery JavaScript Library v3.3.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2018-01-20T17:24Z
	 */
	( function( global, factory ) {

		{

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};

	var isFunction = function isFunction( obj ) {

	      // Support: Chrome <=57, Firefox <=52
	      // In some browsers, typeof returns "function" for HTML <object> elements
	      // (i.e., `typeof document.createElement( "object" ) === "function"`).
	      // We don't want to classify *any* DOM node as a function.
	      return typeof obj === "function" && typeof obj.nodeType !== "number";
	  };


	var isWindow = function isWindow( obj ) {
			return obj != null && obj === obj.window;
		};




		var preservedScriptAttributes = {
			type: true,
			src: true,
			noModule: true
		};

		function DOMEval( code, doc, node ) {
			doc = doc || document;

			var i,
				script = doc.createElement( "script" );

			script.text = code;
			if ( node ) {
				for ( i in preservedScriptAttributes ) {
					if ( node[ i ] ) {
						script[ i ] = node[ i ];
					}
				}
			}
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}


	function toType( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.3.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = toType( obj );

		if ( isFunction( obj ) || isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

	}var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Filtered directly for both simple and complex selectors
		return jQuery.filter( qualifier, elements, not );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, "iframe" ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.
	        if ( nodeName( elem, "template" ) ) {
	            elem = elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && toType( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[ 3 - i ][ 3 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock,

						// progress_handlers.lock
						tuples[ 0 ][ 3 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( toType( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};


	// Matches dashed string for camelizing
	var rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g;

	// Used by camelCase as callback to replace()
	function fcamelCase( all, letter ) {
		return letter.toUpperCase();
	}

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 15
	// Microsoft forgot to hump their vendor prefix (#9572)
	function camelCase( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	}
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( camelCase );
				} else {
					key = camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted, scale,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Support: Firefox <=54
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial = initial / 2;

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			while ( maxIterations-- ) {

				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery.style( elem, prop, initialInUnit + unit );
				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
					maxIterations = 0;
				}
				initialInUnit = initialInUnit / scale;

			}

			initialInUnit = initialInUnit * 2;
			jQuery.style( elem, prop, initialInUnit + unit );

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( toType( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || Date.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
			elem.type = elem.type.slice( 5 );
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			valueIsFunction = isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( valueIsFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( valueIsFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
				"margin-top:1px;padding:0;border:0";
			div.style.cssText =
				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
				"margin:auto;border:1px;padding:1px;" +
				"width:60%;top:1%";
			documentElement.appendChild( container ).appendChild( div );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
			// Some styles come back with percentage values, even though they shouldn't
			div.style.right = "60%";
			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

			// Support: IE 9 - 11 only
			// Detect misreporting of content dimensions for box-sizing:border-box elements
			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

			// Support: IE 9 only
			// Detect overflow:scroll screwiness (gh-3699)
			div.style.position = "absolute";
			scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		function roundPixelMeasures( measure ) {
			return Math.round( parseFloat( measure ) );
		}

		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
			reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		jQuery.extend( support, {
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelBoxStyles: function() {
				computeStyleTests();
				return pixelBoxStylesVal;
			},
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			},
			scrollboxSize: function() {
				computeStyleTests();
				return scrollboxSizeVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret = jQuery.cssProps[ name ];
		if ( !ret ) {
			ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
		var i = dimension === "width" ? 1 : 0,
			extra = 0,
			delta = 0;

		// Adjustment may not be necessary
		if ( box === ( isBorderBox ? "border" : "content" ) ) {
			return 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin
			if ( box === "margin" ) {
				delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
			}

			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
			if ( !isBorderBox ) {

				// Add padding
				delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// For "border" or "margin", add border
				if ( box !== "padding" ) {
					delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

				// But still keep track of it otherwise
				} else {
					extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}

			// If we get here with a border-box (content + padding + border), we're seeking "content" or
			// "padding" or "margin"
			} else {

				// For "content", subtract padding
				if ( box === "content" ) {
					delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// For "content" or "padding", subtract border
				if ( box !== "margin" ) {
					delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		// Account for positive content-box scroll gutter when requested by providing computedVal
		if ( !isBorderBox && computedVal >= 0 ) {

			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta += Math.max( 0, Math.ceil(
				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
				computedVal -
				delta -
				extra -
				0.5
			) );
		}

		return delta;
	}

	function getWidthOrHeight( elem, dimension, extra ) {

		// Start with computed style
		var styles = getStyles( elem ),
			val = curCSS( elem, dimension, styles ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
			valueIsBorderBox = isBorderBox;

		// Support: Firefox <=54
		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if ( rnumnonpx.test( val ) ) {
			if ( !extra ) {
				return val;
			}
			val = "auto";
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = valueIsBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ dimension ] );

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		if ( val === "auto" ||
			!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

			val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

			// offsetWidth/offsetHeight provide border-box values
			valueIsBorderBox = true;
		}

		// Normalize "" and auto
		val = parseFloat( val ) || 0;

		// Adjust for the element's box model
		return ( val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles,

				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, dimension ) {
		jQuery.cssHooks[ dimension ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = getStyles( elem ),
					isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					subtract = extra && boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					);

				// Account for unreliable border-box dimensions by comparing offset* to computed and
				// faking a content-box to get border and padding (gh-3699)
				if ( isBorderBox && support.scrollboxSize() === styles.position ) {
					subtract -= Math.ceil(
						elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
						parseFloat( styles[ dimension ] ) -
						boxModelAdjustment( elem, dimension, "border", false, styles ) -
						0.5
					);
				}

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ dimension ] = value;
					value = jQuery.css( elem, dimension );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( prefix !== "margin" ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = Date.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 15
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						result.stop.bind( result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !isFunction( easing ) && easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = Date.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function() {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	function classesToArray( value ) {
		if ( Array.isArray( value ) ) {
			return value;
		}
		if ( typeof value === "string" ) {
			return value.match( rnothtmlwhite ) || [];
		}
		return [];
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isValidValue = type === "string" || Array.isArray( value );

			if ( typeof stateVal === "boolean" && isValidValue ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( isValidValue ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = classesToArray( value );

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, valueIsFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			valueIsFunction = isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( valueIsFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	support.focusin = "onfocusin" in window;


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback = function( e ) {
			e.stopPropagation();
		};

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = lastElement = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
				lastElement = cur;
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;

						if ( event.isPropagationStopped() ) {
							lastElement.addEventListener( type, stopPropagationCallback );
						}

						elem[ type ]();

						if ( event.isPropagationStopped() ) {
							lastElement.removeEventListener( type, stopPropagationCallback );
						}

						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = Date.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && toType( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 15
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available and should be processed, append data to url
				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var htmlIsFunction = isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.ontimeout =
										xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {

		// offset() relates an element's border box to the document origin
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect = elem.getBoundingClientRect();
			win = elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},

		// position() relates an element's margin box to its offset parent's padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset, doc,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume position:fixed implies availability of getBoundingClientRect
				offset = elem.getBoundingClientRect();

			} else {
				offset = this.offset();

				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc = elem.ownerDocument;
				offsetParent = elem.offsetParent || doc.documentElement;
				while ( offsetParent &&
					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
					jQuery.css( offsetParent, "position" ) === "static" ) {

					offsetParent = offsetParent.parentNode;
				}
				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset = jQuery( offsetParent ).offset();
					parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
					parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
				}
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery.proxy = function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	};

	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;
	jQuery.isFunction = isFunction;
	jQuery.isWindow = isWindow;
	jQuery.camelCase = camelCase;
	jQuery.type = toType;

	jQuery.now = Date.now;

	jQuery.isNumeric = function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	};




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;
	} );
	});

	/**
	 * Gets siblings that match selector and self _in DOM order_.
	 * @param {} element 
	 * @param {*} selector 
	 */
	function getSiblingElementsAndSelf( element, selector ) {
	    return _getSiblingElements( element, selector, [ element ] );
	}

	function getSiblingElements( element, selector ) {
	    return _getSiblingElements( element, selector );
	}

	function _getSiblingElements( element, selector = '*', startArray = [] ) {
	    const siblings = startArray;
	    let prev = element.previousElementSibling;
	    let next = element.nextElementSibling;

	    while ( prev ) {
	        if ( prev.matches( selector ) ) {
	            siblings.unshift( prev );
	        }
	        prev = prev.previousElementSibling;
	    }

	    while ( next ) {
	        if ( next.matches( selector ) ) {
	            siblings.push( next );
	        }
	        next = next.nextElementSibling;
	    }
	    return siblings;
	}

	function getAncestors( element, selector = '*' ) {
	    const ancestors = [];
	    let parent = element.parentElement;

	    while ( parent ) {
	        if ( parent.matches( selector ) ) {
	            // document order
	            ancestors.unshift( parent );
	        }
	        parent = parent.parentElement;
	    }

	    return ancestors;
	}

	function empty( element ) {
	    [ ...element.children ].forEach( el => el.remove() );
	}

	/** 
	 * Adapted from https://stackoverflow.com/a/46522991/3071529
	 * 
	 * A storage solution aimed at replacing jQuerys data function.
	 * Implementation Note: Elements are stored in a (WeakMap)[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap].
	 * This makes sure the data is garbage collected when the node is removed.
	 */
	const elementDataStore = {
	    _storage: new WeakMap(),
	    put: function( element, key, obj ) {
	        if ( !this._storage.has( element ) ) {
	            this._storage.set( element, new Map() );
	        }
	        this._storage.get( element ).set( key, obj );
	    },
	    get: function( element, key ) {
	        const item = this._storage.get( element );
	        return item ? item.get( key ) : item;
	    },
	    has: function( element, key ) {
	        const item = this._storage.get( element );
	        return item && item.has( key );
	    },
	    remove: function( element, key ) {
	        var ret = this._storage.get( element ).delete( key );
	        if ( !this._storage.get( key ).size === 0 ) {
	            this._storage.delete( element );
	        }
	        return ret;
	    }
	};

	function FormLogicError( message ) {
	    this.message = message || 'unknown';
	    this.name = 'FormLogicError';
	    this.stack = ( new Error() ).stack;
	}

	FormLogicError.prototype = Object.create( Error.prototype );
	FormLogicError.prototype.constructor = FormLogicError;

	var config = {
	    'maps': [ {
	        'tiles': [ 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png' ],
	        'name': 'streets',
	        'attribution': '© <a href=\'http://openstreetmap.org\'>OpenStreetMap</a> | <a href=\'www.openstreetmap.org/copyright\'>Terms</a>'
	    }, {
	        'tiles': 'GOOGLE_SATELLITE',
	        'name': 'satellite'
	    } ],
	    'googleApiKey': '',
	    'repeatOrdinals': false,
	    'validateContinuously': false,
	    'validatePage': true,
	    'swipePage': true,
	    'arcGis': {
	        'jsUrl': '',
	        'cssUrl': '',
	        'webMapId': '',
	        'hasZ': true,
	        'basemaps': [ 'streets' ]
	    },
	    'textMaxChars': 2000
	};

	let _locale = navigator.language;
	const NUMBER = '0-9\u0660-\u0669';
	const TIME_PART = `[:${NUMBER}]+`;
	const MERIDIAN_PART = `[^: ${NUMBER}]+`;
	const HAS_MERIDIAN = new RegExp( `^(${TIME_PART} ?(${MERIDIAN_PART}))|((${MERIDIAN_PART}) ?${TIME_PART})$` );

	function _getCleanLocalTime( dt ) {
	    dt = typeof dt == 'undefined' ? new Date() : dt;
	    return _cleanSpecialChars( dt.toLocaleTimeString( _locale ) );
	}

	function _cleanSpecialChars( timeStr ) {
	    return timeStr.replace( /[\u200E\u200F]/g, '' );
	}

	const time = {
	    // For now we just look at a subset of numbers in Arabic and Latin. There are actually over 20 number scripts and :digit: doesn't work in browsers
	    get hour12() {
	        return this.hasMeridian( _getCleanLocalTime() );
	    },
	    get pmNotation() {
	        return this.meridianNotation( new Date( 2000, 1, 1, 23, 0, 0 ) );
	    },
	    get amNotation() {
	        return this.meridianNotation( new Date( 2000, 1, 1, 1, 0, 0 ) );
	    },
	    meridianNotation( dt ) {
	        let matches = _getCleanLocalTime( dt ).match( HAS_MERIDIAN );
	        if ( matches && matches.length ) {
	            matches = matches.filter( item => !!item );
	            return matches[ matches.length - 1 ].trim();
	        }
	        return null;
	    },
	    hasMeridian( time ) {
	        return HAS_MERIDIAN.test( _cleanSpecialChars( time ) );
	    }
	};

	const types = {
	    'string': {
	        convert( x ) {
	            return x.replace( /^\s+$/, '' );
	        },
	        //max length of type string is 255 chars.Convert( truncate ) silently ?
	        validate() {
	            return true;
	        }
	    },
	    'select': {
	        validate() {
	            return true;
	        }
	    },
	    'select1': {
	        validate() {
	            return true;
	        }
	    },
	    'decimal': {
	        convert( x ) {
	            const num = Number( x );
	            if ( isNaN( num ) || num === Number.POSITIVE_INFINITY || num === Number.NEGATIVE_INFINITY ) {
	                // Comply with XML schema decimal type that has no special values. '' is our only option.
	                return '';
	            }
	            return num;
	        },
	        validate( x ) {
	            const num = Number( x );
	            return !isNaN( num ) && num !== Number.POSITIVE_INFINITY && num !== Number.NEGATIVE_INFINITY;
	        }
	    },
	    'int': {
	        convert( x ) {
	            const num = Number( x );
	            if ( isNaN( num ) || num === Number.POSITIVE_INFINITY || num === Number.NEGATIVE_INFINITY ) {
	                // Comply with XML schema int type that has no special values. '' is our only option.
	                return '';
	            }
	            return ( num >= 0 ) ? Math.floor( num ) : -Math.floor( Math.abs( num ) );
	        },
	        validate( x ) {
	            const num = Number( x );
	            return !isNaN( num ) && num !== Number.POSITIVE_INFINITY && num !== Number.NEGATIVE_INFINITY && Math.round( num ) === num && num.toString() === x.toString();
	        }
	    },
	    'date': {
	        validate( x ) {
	            const pattern = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/;
	            const segments = pattern.exec( x );
	            if ( segments && segments.length === 4 ) {
	                const year = Number( segments[ 1 ] );
	                const month = Number( segments[ 2 ] ) - 1;
	                const day = Number( segments[ 3 ] );
	                const date = new Date( year, month, day );
	                // Do not approve automatic JavaScript conversion of invalid dates such as 2017-12-32
	                return date.getFullYear() === year && date.getMonth() === month && date.getDate() === day;
	            }
	            return false;
	        },
	        convert( x ) {
	            if ( isNumber( x ) ) {
	                // The XPath expression "2012-01-01" + 2 returns a number of days in XPath.
	                const date = new Date( x * 24 * 60 * 60 * 1000 );
	                return date.toString() === 'Invalid Date' ?
	                    '' : `${date.getFullYear().toString().pad(4)}-${(date.getMonth() + 1).toString().pad(2)}-${date.getDate().toString().pad(2)}`;
	            } else {
	                // For both dates and datetimes
	                // If it's a datetime, we can quite safely assume it's in the local timezone, and therefore we can simply chop off
	                // the time component.
	                if ( /[0-9]T[0-9]/.test( x ) ) {
	                    x = x.split( 'T' )[ 0 ];
	                }
	                return this.validate( x ) ? x : '';
	            }
	        }
	    },
	    'datetime': {
	        validate( x ) {
	            const parts = x.split( 'T' );
	            if ( parts.length === 2 ) {
	                return types.date.validate( parts[ 0 ] ) && types.time.validate( parts[ 1 ], false );
	            }

	            return types.data.validate( parts[ 0 ] );
	        },
	        convert( x ) {
	            let date = 'Invalid Date';
	            const parts = x.split( 'T' );
	            if ( isNumber( x ) ) {
	                // The XPath expression "2012-01-01T01:02:03+01:00" + 2 returns a number of days in XPath.
	                date = new Date( x * 24 * 60 * 60 * 1000 );
	            } else if ( /[0-9]T[0-9]/.test( x ) && parts.length === 2 ) {
	                const convertedDate = types.date.convert( parts[ 0 ] );
	                // The milliseconds are optional for datetime (and shouldn't be added)
	                const convertedTime = types.time.convert( parts[ 1 ], false );
	                if ( convertedDate && convertedTime ) {
	                    return `${convertedDate}T${convertedTime}`;
	                }
	            } else {
	                const convertedDate = types.date.convert( parts[ 0 ] );
	                if ( convertedDate ) {
	                    return `${convertedDate}T00:00:00.000${(new Date()).getTimezoneOffsetAsTime()}`;
	                }
	            }

	            return date.toString() !== 'Invalid Date' ? date.toISOLocalString() : '';
	        }
	    },
	    'time': {
	        // Note that it's okay if the validate function is stricter than the spec,
	        // (for timezone offset), as long as the convertor automatically converts
	        // to a valid time.
	        validate( x, requireMillis ) {
	            let m = x.match( /^(\d\d):(\d\d):(\d\d)\.\d\d\d(\+|-)(\d\d):(\d\d)$/ );

	            requireMillis = typeof requireMillis !== 'boolean' ? true : requireMillis;

	            if ( !m && !requireMillis ) {
	                m = x.match( /^(\d\d):(\d\d):(\d\d)(\+|-)(\d\d):(\d\d)$/ );
	            }

	            if ( !m ) {
	                return false;
	            }

	            // no need to convert to numbers since we know they are number strings
	            return m[ 1 ] < 24 && m[ 1 ] >= 0 &&
	                m[ 2 ] < 60 && m[ 2 ] >= 0 &&
	                m[ 3 ] < 60 && m[ 3 ] >= 0 &&
	                m[ 5 ] < 24 && m[ 5 ] >= 0 && // this could be tighter
	                m[ 6 ] < 60 && m[ 6 ] >= 0; // this is probably either 0 or 30
	        },
	        convert( x, requireMillis ) {
	            let date;
	            const o = {};
	            let parts;
	            let time;
	            let secs;
	            let tz;
	            let offset;
	            const timeAppearsCorrect = /^[0-9]{1,2}:[0-9]{1,2}(:[0-9.]*)?/;

	            requireMillis = typeof requireMillis !== 'boolean' ? true : requireMillis;

	            if ( !timeAppearsCorrect.test( x ) ) {
	                // An XPath expression would return a datetime string since there is no way to request a timeValue.
	                // We can test this by trying to convert to a date.
	                date = new Date( x );
	                if ( date.toString() !== 'Invalid Date' ) {
	                    x = `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}.${date.getMilliseconds()}${date.getTimezoneOffsetAsTime()}`;
	                } else {
	                    return '';
	                }
	            }

	            parts = x.toString().split( /(\+|-|Z)/ );
	            // We're using a 'capturing group' here, so the + or - is included!.
	            if ( parts.length < 1 ) {
	                return '';
	            }

	            time = parts[ 0 ].split( ':' );
	            tz = parts[ 2 ] ? [ parts[ 1 ] ].concat( parts[ 2 ].split( ':' ) ) : ( parts[ 1 ] === 'Z' ? [ '+', '00', '00' ] : [] );

	            o.hours = time[ 0 ].pad( 2 );
	            o.minutes = time[ 1 ].pad( 2 );

	            secs = time[ 2 ] ? time[ 2 ].split( '.' ) : [ '00' ];

	            o.seconds = secs[ 0 ];
	            o.milliseconds = secs[ 1 ] || ( requireMillis ? '000' : undefined );

	            if ( tz.length === 0 ) {
	                offset = new Date().getTimezoneOffsetAsTime();
	            } else {
	                offset = `${tz[0] + tz[1].pad(2)}:${tz[2] ? tz[2].pad(2) : '00'}`;
	            }

	            x = `${o.hours}:${o.minutes}:${o.seconds}${o.milliseconds ? `.${o.milliseconds}` : ''}${offset}`;

	            return this.validate( x, requireMillis ) ? x : '';
	        },
	        // converts "11:30 AM", and "11:30 ", and "11:30 上午" to: "11:30"
	        // converts "11:30 PM", and "11:30 下午" to: "23:30"
	        convertMeridian( x ) {
	            x = x.trim();
	            if ( time.hasMeridian( x ) ) {
	                const parts = x.split( ' ' );
	                const timeParts = parts[ 0 ].split( ':' );
	                if ( parts.length > 0 ) {
	                    // This will only work for latin numbers but that should be fine because that's what the widget supports.
	                    if ( parts[ 1 ] === time.pmNotation ) {
	                        timeParts[ 0 ] = ( ( Number( timeParts[ 0 ] ) % 12 ) + 12 ).toString().pad( 2 );
	                    } else if ( parts[ 1 ] === time.amNotation ) {
	                        timeParts[ 0 ] = ( Number( timeParts[ 0 ] ) % 12 ).toString().pad( 2 );
	                    }
	                    x = timeParts.join( ':' );
	                }
	            }
	            return x;
	        }
	    },
	    'barcode': {
	        validate() {
	            return true;
	        }
	    },
	    'geopoint': {
	        validate( x ) {
	            const coords = x.toString().trim().split( ' ' );
	            // Note that longitudes from -180 to 180 are problematic when recording points close to the international
	            // dateline. They are therefore set from -360  to 360 (circumventing Earth twice, I think) which is 
	            // an arbitrary limit. https://github.com/kobotoolbox/enketo-express/issues/1033
	            return ( coords[ 0 ] !== '' && coords[ 0 ] >= -90 && coords[ 0 ] <= 90 ) &&
	                ( coords[ 1 ] !== '' && coords[ 1 ] >= -360 && coords[ 1 ] <= 360 ) &&
	                ( typeof coords[ 2 ] === 'undefined' || !isNaN( coords[ 2 ] ) ) &&
	                ( typeof coords[ 3 ] === 'undefined' || ( !isNaN( coords[ 3 ] ) && coords[ 3 ] >= 0 ) );
	        },
	        convert( x ) {
	            return x.toString().trim();
	        }
	    },
	    'geotrace': {
	        validate( x ) {
	            const geopoints = x.toString().split( ';' );
	            return geopoints.length >= 2 && geopoints.every( geopoint => types.geopoint.validate( geopoint ) );
	        },
	        convert( x ) {
	            return x.toString().trim();
	        }
	    },
	    'geoshape': {
	        validate( x ) {
	            const geopoints = x.toString().split( ';' );
	            return geopoints.length >= 4 && ( geopoints[ 0 ] === geopoints[ geopoints.length - 1 ] ) && geopoints.every( geopoint => types.geopoint.validate( geopoint ) );
	        },
	        convert( x ) {
	            return x.toString().trim();
	        }
	    },
	    'binary': {
	        validate() {
	            return true;
	        }
	    }
	};

	// TODO: add second "propagate" parameter to constructors to add .enketo namespace to event.

	function DataUpdate( detail ) {
	    return new CustomEvent( 'dataupdate', { detail } );
	}

	function FakeFocus() {
	    return new CustomEvent( 'fakefocus', { bubbles: true } );
	}

	function ApplyFocus() {
	    return new CustomEvent( 'applyfocus' );
	}

	function PageFlip() {
	    return new CustomEvent( 'pageflip', { bubbles: true } );
	}

	function Removed( detail ) {
	    return new CustomEvent( 'removed', { detail, bubbles: true } );
	}

	function AddRepeat( detail ) {
	    return new CustomEvent( 'addrepeat', { detail, bubbles: true } );
	}

	function RemoveRepeat() {
	    return new CustomEvent( 'removerepeat', { bubbles: true } );
	}

	function ChangeLanguage() {
	    return new CustomEvent( 'changelanguage', { bubbles: true } );
	}

	function Change() {
	    return new Event( 'change', { bubbles: true } );
	}

	function Input() {
	    return new Event( 'input', { bubbles: true } );
	}

	function InputUpdate() {
	    return new CustomEvent( 'inputupdate', { bubbles: true } );
	}

	function Edited() {
	    return new CustomEvent( 'edited', { bubbles: true } );
	}

	function ValidationComplete() {
	    return new CustomEvent( 'validationcomplete', { bubbles: true } );
	}

	function Invalidated() {
	    return new CustomEvent( 'invalidated', { bubbles: true } );
	}

	function ProgressUpdate( detail ) {
	    return new CustomEvent( 'progressupdate', { detail, bubbles: true } );
	}

	function GoToHidden() {
	    return new CustomEvent( 'gotohidden', { bubbles: true } );
	}

	var event = {
	    DataUpdate,
	    FakeFocus,
	    ApplyFocus,
	    PageFlip,
	    Removed,
	    AddRepeat,
	    RemoveRepeat,
	    ChangeLanguage,
	    Change,
	    Input,
	    InputUpdate,
	    Edited,
	    ValidationComplete,
	    Invalidated,
	    ProgressUpdate,
	    GoToHidden
	};

	/**
	 * Converts a native Date UTC String to a RFC 3339-compliant date string with local offsets
	 * used in ODK, so it replaces the Z in the ISOstring with a local offset
	 * @return {string} a datetime string formatted according to RC3339 with local offset
	 */
	Date.prototype.toISOLocalString = function() {
	    //2012-09-05T12:57:00.000-04:00 (ODK)

	    if ( this.toString() === 'Invalid Date' ) {
	        return this.toString();
	    }

	    var dt = new Date( this.getTime() - ( this.getTimezoneOffset() * 60 * 1000 ) ).toISOString()
	        .replace( 'Z', this.getTimezoneOffsetAsTime() );

	    if ( dt.indexOf( 'T00:00:00.000' ) > 0 ) {
	        return dt.split( 'T' )[ 0 ];
	    } else {
	        return dt;
	    }
	};

	Date.prototype.getTimezoneOffsetAsTime = function() {
	    var offsetMinutesTotal;
	    var hours;
	    var minutes;
	    var direction;
	    var pad2 = function( x ) {
	        return ( x < 10 ) ? '0' + x : x;
	    };

	    if ( this.toString() === 'Invalid Date' ) {
	        return this.toString();
	    }

	    offsetMinutesTotal = this.getTimezoneOffset();

	    direction = ( offsetMinutesTotal < 0 ) ? '+' : '-';
	    hours = pad2( Math.abs( Math.floor( offsetMinutesTotal / 60 ) ) );
	    minutes = pad2( Math.abs( Math.floor( offsetMinutesTotal % 60 ) ) );

	    return direction + hours + ':' + minutes;
	};

	// Extend native objects, aka monkey patching ..... really I see no harm!

	/**
	 * Pads a string with prefixed zeros until the requested string length is achieved.
	 * @param  {number} digits [description]
	 * @return {String|string}        [description]
	 */
	String.prototype.pad = function( digits ) {
	    let x = this;
	    while ( x.length < digits ) {
	        x = `0${x}`;
	    }
	    return x;
	};



	if ( typeof console.deprecate === 'undefined' ) {
	    console.deprecate = ( bad, good ) => {
	        console.warn( `${bad} is deprecated. Use ${good} instead.` );
	    };
	}

	var parser = (function() {

	  /*
	   * Generated by PEG.js 0.9.0.
	   *
	   * http://pegjs.org/
	   */

	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }

	  function peg$SyntaxError(message, expected, found, location) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.location = location;
	    this.name     = "SyntaxError";

	    if (typeof Error.captureStackTrace === "function") {
	      Error.captureStackTrace(this, peg$SyntaxError);
	    }
	  }

	  peg$subclass(peg$SyntaxError, Error);

	  function peg$parse(input) {
	    var options = arguments.length > 1 ? arguments[1] : {},
	        peg$FAILED = {},

	        peg$startRuleFunctions = { XPath: peg$parseXPath },
	        peg$startRuleFunction  = peg$parseXPath,

	        peg$c0 = function(expr) {
	        		return {
	        			 tree: expr
	        			,nsPrefixes: nsPrefixes
	        		}
	        	},
	        peg$c1 = "/",
	        peg$c2 = { type: "literal", value: "/", description: "\"/\"" },
	        peg$c3 = function(path) {
	        		return {
	        			 type: '/'
	        			,args: [
	        				null,
	        				(path) ? path[1] : null
	        			]
	        		};
	        	},
	        peg$c4 = "//",
	        peg$c5 = { type: "literal", value: "//", description: "\"//\"" },
	        peg$c6 = function(expr, repeatedExpr) {
	        		var i;
	        		
	        		for(i=0; i < repeatedExpr.length; i++)
	        		{
	        			expr = expandSlashAbbrev(repeatedExpr[i][1], expr, repeatedExpr[i][3]);
	        		}
	        		
	        		return expr;
	        	},
	        peg$c7 = function(axis, node, predicate) {
	        		return predicateExpression({
	        			type: 'step',
	        			args: [
	        				axis,
	        				node
	        			]},
	        			axis,
	        			predicate,
	        			1
	        		);
	        	},
	        peg$c8 = "::",
	        peg$c9 = { type: "literal", value: "::", description: "\"::\"" },
	        peg$c10 = function(axis) {
	        		return axis;
	        	},
	        peg$c11 = function(aas) {
	        		return (aas.length) ? aas : 'child';
	        	},
	        peg$c12 = "ancestor-or-self",
	        peg$c13 = { type: "literal", value: "ancestor-or-self", description: "\"ancestor-or-self\"" },
	        peg$c14 = "ancestor",
	        peg$c15 = { type: "literal", value: "ancestor", description: "\"ancestor\"" },
	        peg$c16 = "attribute",
	        peg$c17 = { type: "literal", value: "attribute", description: "\"attribute\"" },
	        peg$c18 = "child",
	        peg$c19 = { type: "literal", value: "child", description: "\"child\"" },
	        peg$c20 = "descendant-or-self",
	        peg$c21 = { type: "literal", value: "descendant-or-self", description: "\"descendant-or-self\"" },
	        peg$c22 = "descendant",
	        peg$c23 = { type: "literal", value: "descendant", description: "\"descendant\"" },
	        peg$c24 = "following-sibling",
	        peg$c25 = { type: "literal", value: "following-sibling", description: "\"following-sibling\"" },
	        peg$c26 = "following",
	        peg$c27 = { type: "literal", value: "following", description: "\"following\"" },
	        peg$c28 = "namespace",
	        peg$c29 = { type: "literal", value: "namespace", description: "\"namespace\"" },
	        peg$c30 = "parent",
	        peg$c31 = { type: "literal", value: "parent", description: "\"parent\"" },
	        peg$c32 = "preceding-sibling",
	        peg$c33 = { type: "literal", value: "preceding-sibling", description: "\"preceding-sibling\"" },
	        peg$c34 = "preceding",
	        peg$c35 = { type: "literal", value: "preceding", description: "\"preceding\"" },
	        peg$c36 = "self",
	        peg$c37 = { type: "literal", value: "self", description: "\"self\"" },
	        peg$c38 = "(",
	        peg$c39 = { type: "literal", value: "(", description: "\"(\"" },
	        peg$c40 = ")",
	        peg$c41 = { type: "literal", value: ")", description: "\")\"" },
	        peg$c42 = function(nodeType) {
	        		return {
	        			 type: 'nodeType'
	        			,args: [
	        				nodeType,
	        				[]
	        			]
	        		};
	        	},
	        peg$c43 = "processing-instruction",
	        peg$c44 = { type: "literal", value: "processing-instruction", description: "\"processing-instruction\"" },
	        peg$c45 = function(pi, arg) {
	        		return {
	        			 type: 'nodeType'
	        			,args: [
	        				pi,
	        				[arg]
	        			]
	        		};
	        	},
	        peg$c46 = function(nt) {
	        		return nt;
	        	},
	        peg$c47 = "[",
	        peg$c48 = { type: "literal", value: "[", description: "\"[\"" },
	        peg$c49 = "]",
	        peg$c50 = { type: "literal", value: "]", description: "\"]\"" },
	        peg$c51 = function(expr) {
	        		return expr;
	        	},
	        peg$c52 = function(path) {
	        		return expandSlashAbbrev('//', null, path);
	        	},
	        peg$c53 = "..",
	        peg$c54 = { type: "literal", value: "..", description: "\"..\"" },
	        peg$c55 = ".",
	        peg$c56 = { type: "literal", value: ".", description: "\".\"" },
	        peg$c57 = function(abbrev) {
	        		/*
	        		 * @see http://www.w3.org/TR/xpath/#path-abbrev
	        		 */
	        		var result = {
	        			type: 'step',
	        			args: [
	        				'self', // assume .
	        				{
	        					type: 'nodeType',
	        					args: [
	        						'node',
	        						[]
	        					]
	        				}
	        			]
	        		};
	        		
	        		if (abbrev == '..')
	        		{
	        			result.args[0] = 'parent';
	        		}
	        		
	        		return result;
	        	},
	        peg$c58 = "@",
	        peg$c59 = { type: "literal", value: "@", description: "\"@\"" },
	        peg$c60 = function(attribute) {
	        		return (attribute) ? 'attribute' : '';
	        	},
	        peg$c61 = function(vr) {
	        		return vr;
	        	},
	        peg$c62 = function(l) {
	        		return l;
	        	},
	        peg$c63 = function(n) {
	        		return n;
	        	},
	        peg$c64 = ",",
	        peg$c65 = { type: "literal", value: ",", description: "\",\"" },
	        peg$c66 = function(name, arg) {
	        		var i, args = [];
	        		if (arg)
	        		{
	        			args.push(arg[1]);
	        			for (i=0; i < arg[2].length; i++)
	        			{
	        				args.push(arg[2][i][3]);
	        			}
	        		}
	        		return {
	        			 type: 'function'
	        			,args: [
	        				name,
	        				args
	        			]
	        		};
	        	},
	        peg$c67 = "|",
	        peg$c68 = { type: "literal", value: "|", description: "\"|\"" },
	        peg$c69 = function(expr, repeatedExpr) {
	        		return expressionSimplifier(expr, repeatedExpr, 1, 3);
	        	},
	        peg$c70 = function(expr, path) {
	        		if (!path)
	        			return expr;
	        		
	        		return expandSlashAbbrev(path[1], expr, path[3]);
	        	},
	        peg$c71 = function(path) {
	        		return path;
	        	},
	        peg$c72 = function(expr, repeatedExpr) {
	        		return predicateExpression(expr, 'child', repeatedExpr, 1);
	        	},
	        peg$c73 = "or",
	        peg$c74 = { type: "literal", value: "or", description: "\"or\"" },
	        peg$c75 = "and",
	        peg$c76 = { type: "literal", value: "and", description: "\"and\"" },
	        peg$c77 = "=",
	        peg$c78 = { type: "literal", value: "=", description: "\"=\"" },
	        peg$c79 = "!=",
	        peg$c80 = { type: "literal", value: "!=", description: "\"!=\"" },
	        peg$c81 = "<=",
	        peg$c82 = { type: "literal", value: "<=", description: "\"<=\"" },
	        peg$c83 = "<",
	        peg$c84 = { type: "literal", value: "<", description: "\"<\"" },
	        peg$c85 = ">=",
	        peg$c86 = { type: "literal", value: ">=", description: "\">=\"" },
	        peg$c87 = ">",
	        peg$c88 = { type: "literal", value: ">", description: "\">\"" },
	        peg$c89 = "+",
	        peg$c90 = { type: "literal", value: "+", description: "\"+\"" },
	        peg$c91 = "-",
	        peg$c92 = { type: "literal", value: "-", description: "\"-\"" },
	        peg$c93 = "div",
	        peg$c94 = { type: "literal", value: "div", description: "\"div\"" },
	        peg$c95 = "mod",
	        peg$c96 = { type: "literal", value: "mod", description: "\"mod\"" },
	        peg$c97 = function(expr) {
	        		return {
	        			 type: '*' // multiply
	        			,args: [
	        				{
	        					type: 'number',
	        					args: [
	        						-1
	        					]
	        				},
	        				expr
	        			]
	        		}
	        	},
	        peg$c98 = "\"",
	        peg$c99 = { type: "literal", value: "\"", description: "\"\\\"\"" },
	        peg$c100 = /^[^"]/,
	        peg$c101 = { type: "class", value: "[^\"]", description: "[^\"]" },
	        peg$c102 = function(literals) {
	        		return {
	        			type: 'string',
	        			args: [
	        				literals.join('')
	        			]
	        		};
	        	},
	        peg$c103 = "'",
	        peg$c104 = { type: "literal", value: "'", description: "\"'\"" },
	        peg$c105 = /^[^']/,
	        peg$c106 = { type: "class", value: "[^']", description: "[^']" },
	        peg$c107 = function(digits, decimals) {
	        		return {
	        			 type: 'number'
	        			,args: [
	        				(decimals) ? parseFloat(digits + '.' + decimals[1]) : parseInt(digits)
	        			]
	        		};
	        	},
	        peg$c108 = function(digits) {
	        		return {
	        			type: 'number',
	        			args: [
	        				parseFloat('.' + digits)
	        			]
	        		};
	        	},
	        peg$c109 = /^[0-9]/,
	        peg$c110 = { type: "class", value: "[0-9]", description: "[0-9]" },
	        peg$c111 = function(digits) {
	        		return digits.join('');
	        	},
	        peg$c112 = "*",
	        peg$c113 = { type: "literal", value: "*", description: "\"*\"" },
	        peg$c114 = function(name) { // - NodeType
	        		var i;
	        		
	        		// exclude NodeType names
	        		if (lastQNameParsed.args[0] === null) // no namespace
	        		{
	        			for(i=0; i<nodeTypeNames.length; i++)
	        			{
	        				if (lastQNameParsed.args[1] == nodeTypeNames[i]) // name
	        				{
	        					// Reserved NodeType name used, so don't allow this function name
	        					return false;
	        				}
	        			}
	        		}
	        		
	        		// function name ok
	        		return true;
	        	},
	        peg$c115 = function(name) {
	        		(name.args[0] === '')
	        			? name = {  // NOTE: apparently "name.args[0] = null" doesn't work well because NameTest get's screwed up...
	        				 type: name.type
	        				,args: [
	        					null,
	        					name.args[1]
	        				]
	        			}
	        			: trackNsPrefix(name.args[0])
	        		;
	        		return name;
	        	},
	        peg$c116 = "$",
	        peg$c117 = { type: "literal", value: "$", description: "\"$\"" },
	        peg$c118 = function(name) {
	        		trackNsPrefix(name.args[0]);
	        		
	        		return {
	        			 type: '$'
	        			,args: [
	        				name
	        			]
	        		};
	        	},
	        peg$c119 = function() {
	        		return {
	        			 type: 'name'
	        			,args: [
	        				null,
	        				null
	        			]
	        		};
	        	},
	        peg$c120 = ":",
	        peg$c121 = { type: "literal", value: ":", description: "\":\"" },
	        peg$c122 = function(ns) {
	        		trackNsPrefix(ns);
	        		return {
	        			 type: 'name'
	        			,args: [
	        				ns,
	        				null
	        			]
	        		};
	        	},
	        peg$c123 = function(name) {
	        		trackNsPrefix(name.args[0]);
	        		return name;
	        	},
	        peg$c124 = "comment",
	        peg$c125 = { type: "literal", value: "comment", description: "\"comment\"" },
	        peg$c126 = "text",
	        peg$c127 = { type: "literal", value: "text", description: "\"text\"" },
	        peg$c128 = "node",
	        peg$c129 = { type: "literal", value: "node", description: "\"node\"" },
	        peg$c130 = /^[ \t\r\n]/,
	        peg$c131 = { type: "class", value: "[\\u0020\\u0009\\u000D\\u000A]", description: "[\\u0020\\u0009\\u000D\\u000A]" },
	        peg$c132 = function(name) {
	        		lastQNameParsed = name;
	        		return name;
	        	},
	        peg$c133 = function(ns, name) {
	        		return {
	        			 type: 'name'
	        			,args: [
	        				ns,
	        				name
	        			]
	        		};
	        	},
	        peg$c134 = function(name) {
	        		return {
	        			 type: 'name'
	        			,args: [
	        				null,
	        				name
	        			]
	        		};
	        	},
	        peg$c135 = /^[A-Z]/,
	        peg$c136 = { type: "class", value: "[A-Z]", description: "[A-Z]" },
	        peg$c137 = "_",
	        peg$c138 = { type: "literal", value: "_", description: "\"_\"" },
	        peg$c139 = /^[a-z]/,
	        peg$c140 = { type: "class", value: "[a-z]", description: "[a-z]" },
	        peg$c141 = /^[\xC0-\xD6]/,
	        peg$c142 = { type: "class", value: "[\\u00C0-\\u00D6]", description: "[\\u00C0-\\u00D6]" },
	        peg$c143 = /^[\xD8-\xF6]/,
	        peg$c144 = { type: "class", value: "[\\u00D8-\\u00F6]", description: "[\\u00D8-\\u00F6]" },
	        peg$c145 = /^[\xF8-\u02FF]/,
	        peg$c146 = { type: "class", value: "[\\u00F8-\\u02FF]", description: "[\\u00F8-\\u02FF]" },
	        peg$c147 = /^[\u0370-\u037D]/,
	        peg$c148 = { type: "class", value: "[\\u0370-\\u037D]", description: "[\\u0370-\\u037D]" },
	        peg$c149 = /^[\u037F-\u1FFF]/,
	        peg$c150 = { type: "class", value: "[\\u037F-\\u1FFF]", description: "[\\u037F-\\u1FFF]" },
	        peg$c151 = /^[\u200C-\u200D]/,
	        peg$c152 = { type: "class", value: "[\\u200C-\\u200D]", description: "[\\u200C-\\u200D]" },
	        peg$c153 = /^[\u2070-\u218F]/,
	        peg$c154 = { type: "class", value: "[\\u2070-\\u218F]", description: "[\\u2070-\\u218F]" },
	        peg$c155 = /^[\u2C00-\u2FEF]/,
	        peg$c156 = { type: "class", value: "[\\u2C00-\\u2FEF]", description: "[\\u2C00-\\u2FEF]" },
	        peg$c157 = /^[\u3001-\uD7FF]/,
	        peg$c158 = { type: "class", value: "[\\u3001-\\uD7FF]", description: "[\\u3001-\\uD7FF]" },
	        peg$c159 = /^[\uF900-\uFDCF]/,
	        peg$c160 = { type: "class", value: "[\\uF900-\\uFDCF]", description: "[\\uF900-\\uFDCF]" },
	        peg$c161 = /^[\uFDF0-\uFFFD]/,
	        peg$c162 = { type: "class", value: "[\\uFDF0-\\uFFFD]", description: "[\\uFDF0-\\uFFFD]" },
	        peg$c163 = /^[\xB7]/,
	        peg$c164 = { type: "class", value: "[\\u00B7]", description: "[\\u00B7]" },
	        peg$c165 = /^[\u0300-\u036F]/,
	        peg$c166 = { type: "class", value: "[\\u0300-\\u036F]", description: "[\\u0300-\\u036F]" },
	        peg$c167 = /^[\u203F-\u2040]/,
	        peg$c168 = { type: "class", value: "[\\u203F-\\u2040]", description: "[\\u203F-\\u2040]" },
	        peg$c169 = function(startchar, chars) {
	        		return startchar + chars.join('');
	        	},

	        peg$currPos          = 0,
	        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$result;

	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleFunctions)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }

	      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	    }

	    function peg$computePosDetails(pos) {
	      var details = peg$posDetailsCache[pos],
	          p, ch;

	      if (details) {
	        return details;
	      } else {
	        p = pos - 1;
	        while (!peg$posDetailsCache[p]) {
	          p--;
	        }

	        details = peg$posDetailsCache[p];
	        details = {
	          line:   details.line,
	          column: details.column,
	          seenCR: details.seenCR
	        };

	        while (p < pos) {
	          ch = input.charAt(p);
	          if (ch === "\n") {
	            if (!details.seenCR) { details.line++; }
	            details.column = 1;
	            details.seenCR = false;
	          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	            details.line++;
	            details.column = 1;
	            details.seenCR = true;
	          } else {
	            details.column++;
	            details.seenCR = false;
	          }

	          p++;
	        }

	        peg$posDetailsCache[pos] = details;
	        return details;
	      }
	    }

	    function peg$computeLocation(startPos, endPos) {
	      var startPosDetails = peg$computePosDetails(startPos),
	          endPosDetails   = peg$computePosDetails(endPos);

	      return {
	        start: {
	          offset: startPos,
	          line:   startPosDetails.line,
	          column: startPosDetails.column
	        },
	        end: {
	          offset: endPos,
	          line:   endPosDetails.line,
	          column: endPosDetails.column
	        }
	      };
	    }

	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }

	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }

	      peg$maxFailExpected.push(expected);
	    }

	    function peg$buildException(message, expected, found, location) {
	      function cleanupExpected(expected) {
	        var i = 1;

	        expected.sort(function(a, b) {
	          if (a.description < b.description) {
	            return -1;
	          } else if (a.description > b.description) {
	            return 1;
	          } else {
	            return 0;
	          }
	        });

	        while (i < expected.length) {
	          if (expected[i - 1] === expected[i]) {
	            expected.splice(i, 1);
	          } else {
	            i++;
	          }
	        }
	      }

	      function buildMessage(expected, found) {
	        function stringEscape(s) {
	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

	          return s
	            .replace(/\\/g,   '\\\\')
	            .replace(/"/g,    '\\"')
	            .replace(/\x08/g, '\\b')
	            .replace(/\t/g,   '\\t')
	            .replace(/\n/g,   '\\n')
	            .replace(/\f/g,   '\\f')
	            .replace(/\r/g,   '\\r')
	            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	        }

	        var expectedDescs = new Array(expected.length),
	            expectedDesc, foundDesc, i;

	        for (i = 0; i < expected.length; i++) {
	          expectedDescs[i] = expected[i].description;
	        }

	        expectedDesc = expected.length > 1
	          ? expectedDescs.slice(0, -1).join(", ")
	              + " or "
	              + expectedDescs[expected.length - 1]
	          : expectedDescs[0];

	        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

	        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	      }

	      if (expected !== null) {
	        cleanupExpected(expected);
	      }

	      return new peg$SyntaxError(
	        message !== null ? message : buildMessage(expected, found),
	        expected,
	        found,
	        location
	      );
	    }

	    function peg$parseXPath() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseExpr();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            s1 = peg$c0(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseLocationPath() {
	      var s0;

	      s0 = peg$parseRelativeLocationPath();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseAbsoluteLocationPath();
	      }

	      return s0;
	    }

	    function peg$parseAbsoluteLocationPath() {
	      var s0, s1, s2, s3, s4;

	      s0 = peg$parseAbbreviatedAbsoluteLocationPath();
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 47) {
	          s1 = peg$c1;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          { peg$fail(peg$c2); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$currPos;
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseRelativeLocationPath();
	            if (s4 !== peg$FAILED) {
	              s3 = [s3, s4];
	              s2 = s3;
	            } else {
	              peg$currPos = s2;
	              s2 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	          if (s2 === peg$FAILED) {
	            s2 = null;
	          }
	          if (s2 !== peg$FAILED) {
	            s1 = peg$c3(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseRelativeLocationPath() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseStep();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c4) {
	            s5 = peg$c4;
	            peg$currPos += 2;
	          } else {
	            s5 = peg$FAILED;
	            { peg$fail(peg$c5); }
	          }
	          if (s5 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 47) {
	              s5 = peg$c1;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c2); }
	            }
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseStep();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 2) === peg$c4) {
	              s5 = peg$c4;
	              peg$currPos += 2;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c5); }
	            }
	            if (s5 === peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 47) {
	                s5 = peg$c1;
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                { peg$fail(peg$c2); }
	              }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseStep();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c6(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseStep() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseAxisSpecifier();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseNodeTest();
	          if (s3 !== peg$FAILED) {
	            s4 = [];
	            s5 = peg$currPos;
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parsePredicate();
	              if (s7 !== peg$FAILED) {
	                s6 = [s6, s7];
	                s5 = s6;
	              } else {
	                peg$currPos = s5;
	                s5 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s5;
	              s5 = peg$FAILED;
	            }
	            while (s5 !== peg$FAILED) {
	              s4.push(s5);
	              s5 = peg$currPos;
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parsePredicate();
	                if (s7 !== peg$FAILED) {
	                  s6 = [s6, s7];
	                  s5 = s6;
	                } else {
	                  peg$currPos = s5;
	                  s5 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s5;
	                s5 = peg$FAILED;
	              }
	            }
	            if (s4 !== peg$FAILED) {
	              s1 = peg$c7(s1, s3, s4);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseAbbreviatedStep();
	      }

	      return s0;
	    }

	    function peg$parseAxisSpecifier() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseAxisName();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c8) {
	            s3 = peg$c8;
	            peg$currPos += 2;
	          } else {
	            s3 = peg$FAILED;
	            { peg$fail(peg$c9); }
	          }
	          if (s3 !== peg$FAILED) {
	            s1 = peg$c10(s1);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$parseAbbreviatedAxisSpecifier();
	        if (s1 !== peg$FAILED) {
	          s1 = peg$c11(s1);
	        }
	        s0 = s1;
	      }

	      return s0;
	    }

	    function peg$parseAxisName() {
	      var s0;

	      if (input.substr(peg$currPos, 16) === peg$c12) {
	        s0 = peg$c12;
	        peg$currPos += 16;
	      } else {
	        s0 = peg$FAILED;
	        { peg$fail(peg$c13); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 8) === peg$c14) {
	          s0 = peg$c14;
	          peg$currPos += 8;
	        } else {
	          s0 = peg$FAILED;
	          { peg$fail(peg$c15); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.substr(peg$currPos, 9) === peg$c16) {
	            s0 = peg$c16;
	            peg$currPos += 9;
	          } else {
	            s0 = peg$FAILED;
	            { peg$fail(peg$c17); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.substr(peg$currPos, 5) === peg$c18) {
	              s0 = peg$c18;
	              peg$currPos += 5;
	            } else {
	              s0 = peg$FAILED;
	              { peg$fail(peg$c19); }
	            }
	            if (s0 === peg$FAILED) {
	              if (input.substr(peg$currPos, 18) === peg$c20) {
	                s0 = peg$c20;
	                peg$currPos += 18;
	              } else {
	                s0 = peg$FAILED;
	                { peg$fail(peg$c21); }
	              }
	              if (s0 === peg$FAILED) {
	                if (input.substr(peg$currPos, 10) === peg$c22) {
	                  s0 = peg$c22;
	                  peg$currPos += 10;
	                } else {
	                  s0 = peg$FAILED;
	                  { peg$fail(peg$c23); }
	                }
	                if (s0 === peg$FAILED) {
	                  if (input.substr(peg$currPos, 17) === peg$c24) {
	                    s0 = peg$c24;
	                    peg$currPos += 17;
	                  } else {
	                    s0 = peg$FAILED;
	                    { peg$fail(peg$c25); }
	                  }
	                  if (s0 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 9) === peg$c26) {
	                      s0 = peg$c26;
	                      peg$currPos += 9;
	                    } else {
	                      s0 = peg$FAILED;
	                      { peg$fail(peg$c27); }
	                    }
	                    if (s0 === peg$FAILED) {
	                      if (input.substr(peg$currPos, 9) === peg$c28) {
	                        s0 = peg$c28;
	                        peg$currPos += 9;
	                      } else {
	                        s0 = peg$FAILED;
	                        { peg$fail(peg$c29); }
	                      }
	                      if (s0 === peg$FAILED) {
	                        if (input.substr(peg$currPos, 6) === peg$c30) {
	                          s0 = peg$c30;
	                          peg$currPos += 6;
	                        } else {
	                          s0 = peg$FAILED;
	                          { peg$fail(peg$c31); }
	                        }
	                        if (s0 === peg$FAILED) {
	                          if (input.substr(peg$currPos, 17) === peg$c32) {
	                            s0 = peg$c32;
	                            peg$currPos += 17;
	                          } else {
	                            s0 = peg$FAILED;
	                            { peg$fail(peg$c33); }
	                          }
	                          if (s0 === peg$FAILED) {
	                            if (input.substr(peg$currPos, 9) === peg$c34) {
	                              s0 = peg$c34;
	                              peg$currPos += 9;
	                            } else {
	                              s0 = peg$FAILED;
	                              { peg$fail(peg$c35); }
	                            }
	                            if (s0 === peg$FAILED) {
	                              if (input.substr(peg$currPos, 4) === peg$c36) {
	                                s0 = peg$c36;
	                                peg$currPos += 4;
	                              } else {
	                                s0 = peg$FAILED;
	                                { peg$fail(peg$c37); }
	                              }
	                            }
	                          }
	                        }
	                      }
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseNodeTest() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseNodeType();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 40) {
	            s3 = peg$c38;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            { peg$fail(peg$c39); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 41) {
	                s5 = peg$c40;
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                { peg$fail(peg$c41); }
	              }
	              if (s5 !== peg$FAILED) {
	                s1 = peg$c42(s1);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 22) === peg$c43) {
	          s1 = peg$c43;
	          peg$currPos += 22;
	        } else {
	          s1 = peg$FAILED;
	          { peg$fail(peg$c44); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parse_();
	          if (s2 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 40) {
	              s3 = peg$c38;
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              { peg$fail(peg$c39); }
	            }
	            if (s3 !== peg$FAILED) {
	              s4 = peg$parse_();
	              if (s4 !== peg$FAILED) {
	                s5 = peg$parseLiteral();
	                if (s5 !== peg$FAILED) {
	                  s6 = peg$parse_();
	                  if (s6 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 41) {
	                      s7 = peg$c40;
	                      peg$currPos++;
	                    } else {
	                      s7 = peg$FAILED;
	                      { peg$fail(peg$c41); }
	                    }
	                    if (s7 !== peg$FAILED) {
	                      s1 = peg$c45(s1, s5);
	                      s0 = s1;
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          s1 = peg$parseNameTest();
	          if (s1 !== peg$FAILED) {
	            s1 = peg$c46(s1);
	          }
	          s0 = s1;
	        }
	      }

	      return s0;
	    }

	    function peg$parsePredicate() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 91) {
	        s1 = peg$c47;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        { peg$fail(peg$c48); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseExpr();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 93) {
	                s5 = peg$c49;
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                { peg$fail(peg$c50); }
	              }
	              if (s5 !== peg$FAILED) {
	                s1 = peg$c51(s3);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseAbbreviatedAbsoluteLocationPath() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c4) {
	        s1 = peg$c4;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseRelativeLocationPath();
	          if (s3 !== peg$FAILED) {
	            s1 = peg$c52(s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseAbbreviatedStep() {
	      var s0, s1;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c53) {
	        s1 = peg$c53;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        { peg$fail(peg$c54); }
	      }
	      if (s1 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 46) {
	          s1 = peg$c55;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          { peg$fail(peg$c56); }
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c57(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseAbbreviatedAxisSpecifier() {
	      var s0, s1;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 64) {
	        s1 = peg$c58;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        { peg$fail(peg$c59); }
	      }
	      if (s1 === peg$FAILED) {
	        s1 = null;
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c60(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseExpr() {
	      var s0, s1;

	      s0 = peg$currPos;
	      s1 = peg$parseOrExpr();
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c51(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parsePrimaryExpr() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      s1 = peg$parseVariableReference();
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c61(s1);
	      }
	      s0 = s1;
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 40) {
	          s1 = peg$c38;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          { peg$fail(peg$c39); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parse_();
	          if (s2 !== peg$FAILED) {
	            s3 = peg$parseExpr();
	            if (s3 !== peg$FAILED) {
	              s4 = peg$parse_();
	              if (s4 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 41) {
	                  s5 = peg$c40;
	                  peg$currPos++;
	                } else {
	                  s5 = peg$FAILED;
	                  { peg$fail(peg$c41); }
	                }
	                if (s5 !== peg$FAILED) {
	                  s1 = peg$c51(s3);
	                  s0 = s1;
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          s1 = peg$parseLiteral();
	          if (s1 !== peg$FAILED) {
	            s1 = peg$c62(s1);
	          }
	          s0 = s1;
	          if (s0 === peg$FAILED) {
	            s0 = peg$currPos;
	            s1 = peg$parseNumber();
	            if (s1 !== peg$FAILED) {
	              s1 = peg$c63(s1);
	            }
	            s0 = s1;
	            if (s0 === peg$FAILED) {
	              s0 = peg$parseFunctionCall();
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseFunctionCall() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

	      s0 = peg$currPos;
	      s1 = peg$parseFunctionName();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 40) {
	            s3 = peg$c38;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            { peg$fail(peg$c39); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$currPos;
	            s5 = peg$parse_();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parseExpr();
	              if (s6 !== peg$FAILED) {
	                s7 = [];
	                s8 = peg$currPos;
	                s9 = peg$parse_();
	                if (s9 !== peg$FAILED) {
	                  if (input.charCodeAt(peg$currPos) === 44) {
	                    s10 = peg$c64;
	                    peg$currPos++;
	                  } else {
	                    s10 = peg$FAILED;
	                    { peg$fail(peg$c65); }
	                  }
	                  if (s10 !== peg$FAILED) {
	                    s11 = peg$parse_();
	                    if (s11 !== peg$FAILED) {
	                      s12 = peg$parseExpr();
	                      if (s12 !== peg$FAILED) {
	                        s9 = [s9, s10, s11, s12];
	                        s8 = s9;
	                      } else {
	                        peg$currPos = s8;
	                        s8 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s8;
	                      s8 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s8;
	                    s8 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s8;
	                  s8 = peg$FAILED;
	                }
	                while (s8 !== peg$FAILED) {
	                  s7.push(s8);
	                  s8 = peg$currPos;
	                  s9 = peg$parse_();
	                  if (s9 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 44) {
	                      s10 = peg$c64;
	                      peg$currPos++;
	                    } else {
	                      s10 = peg$FAILED;
	                      { peg$fail(peg$c65); }
	                    }
	                    if (s10 !== peg$FAILED) {
	                      s11 = peg$parse_();
	                      if (s11 !== peg$FAILED) {
	                        s12 = peg$parseExpr();
	                        if (s12 !== peg$FAILED) {
	                          s9 = [s9, s10, s11, s12];
	                          s8 = s9;
	                        } else {
	                          peg$currPos = s8;
	                          s8 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s8;
	                        s8 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s8;
	                      s8 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s8;
	                    s8 = peg$FAILED;
	                  }
	                }
	                if (s7 !== peg$FAILED) {
	                  s5 = [s5, s6, s7];
	                  s4 = s5;
	                } else {
	                  peg$currPos = s4;
	                  s4 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s4;
	              s4 = peg$FAILED;
	            }
	            if (s4 === peg$FAILED) {
	              s4 = null;
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse_();
	              if (s5 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 41) {
	                  s6 = peg$c40;
	                  peg$currPos++;
	                } else {
	                  s6 = peg$FAILED;
	                  { peg$fail(peg$c41); }
	                }
	                if (s6 !== peg$FAILED) {
	                  s1 = peg$c66(s1, s4);
	                  s0 = s1;
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseUnionExpr() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parsePathExpr();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 124) {
	            s5 = peg$c67;
	            peg$currPos++;
	          } else {
	            s5 = peg$FAILED;
	            { peg$fail(peg$c68); }
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parsePathExpr();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 124) {
	              s5 = peg$c67;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c68); }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parsePathExpr();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c69(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parsePathExpr() {
	      var s0, s1, s2, s3, s4, s5, s6;

	      s0 = peg$currPos;
	      s1 = peg$parseFilterExpr();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        s3 = peg$parse_();
	        if (s3 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c4) {
	            s4 = peg$c4;
	            peg$currPos += 2;
	          } else {
	            s4 = peg$FAILED;
	            { peg$fail(peg$c5); }
	          }
	          if (s4 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 47) {
	              s4 = peg$c1;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              { peg$fail(peg$c2); }
	            }
	          }
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parse_();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parseRelativeLocationPath();
	              if (s6 !== peg$FAILED) {
	                s3 = [s3, s4, s5, s6];
	                s2 = s3;
	              } else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s2;
	              s2 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 === peg$FAILED) {
	          s2 = null;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c70(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$parseLocationPath();
	        if (s1 !== peg$FAILED) {
	          s1 = peg$c71(s1);
	        }
	        s0 = s1;
	      }

	      return s0;
	    }

	    function peg$parseFilterExpr() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      s1 = peg$parsePrimaryExpr();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parsePredicate();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parsePredicate();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c72(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseOrExpr() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseAndExpr();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c73) {
	            s5 = peg$c73;
	            peg$currPos += 2;
	          } else {
	            s5 = peg$FAILED;
	            { peg$fail(peg$c74); }
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseAndExpr();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 2) === peg$c73) {
	              s5 = peg$c73;
	              peg$currPos += 2;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c74); }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseAndExpr();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c69(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseAndExpr() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseEqualityExpr();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 3) === peg$c75) {
	            s5 = peg$c75;
	            peg$currPos += 3;
	          } else {
	            s5 = peg$FAILED;
	            { peg$fail(peg$c76); }
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseEqualityExpr();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 3) === peg$c75) {
	              s5 = peg$c75;
	              peg$currPos += 3;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c76); }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseEqualityExpr();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c69(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseEqualityExpr() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseRelationalExpr();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 61) {
	            s5 = peg$c77;
	            peg$currPos++;
	          } else {
	            s5 = peg$FAILED;
	            { peg$fail(peg$c78); }
	          }
	          if (s5 === peg$FAILED) {
	            if (input.substr(peg$currPos, 2) === peg$c79) {
	              s5 = peg$c79;
	              peg$currPos += 2;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c80); }
	            }
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseRelationalExpr();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 61) {
	              s5 = peg$c77;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c78); }
	            }
	            if (s5 === peg$FAILED) {
	              if (input.substr(peg$currPos, 2) === peg$c79) {
	                s5 = peg$c79;
	                peg$currPos += 2;
	              } else {
	                s5 = peg$FAILED;
	                { peg$fail(peg$c80); }
	              }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseRelationalExpr();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c69(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseRelationalExpr() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseAdditiveExpr();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c81) {
	            s5 = peg$c81;
	            peg$currPos += 2;
	          } else {
	            s5 = peg$FAILED;
	            { peg$fail(peg$c82); }
	          }
	          if (s5 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 60) {
	              s5 = peg$c83;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c84); }
	            }
	            if (s5 === peg$FAILED) {
	              if (input.substr(peg$currPos, 2) === peg$c85) {
	                s5 = peg$c85;
	                peg$currPos += 2;
	              } else {
	                s5 = peg$FAILED;
	                { peg$fail(peg$c86); }
	              }
	              if (s5 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 62) {
	                  s5 = peg$c87;
	                  peg$currPos++;
	                } else {
	                  s5 = peg$FAILED;
	                  { peg$fail(peg$c88); }
	                }
	              }
	            }
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseAdditiveExpr();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 2) === peg$c81) {
	              s5 = peg$c81;
	              peg$currPos += 2;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c82); }
	            }
	            if (s5 === peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 60) {
	                s5 = peg$c83;
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                { peg$fail(peg$c84); }
	              }
	              if (s5 === peg$FAILED) {
	                if (input.substr(peg$currPos, 2) === peg$c85) {
	                  s5 = peg$c85;
	                  peg$currPos += 2;
	                } else {
	                  s5 = peg$FAILED;
	                  { peg$fail(peg$c86); }
	                }
	                if (s5 === peg$FAILED) {
	                  if (input.charCodeAt(peg$currPos) === 62) {
	                    s5 = peg$c87;
	                    peg$currPos++;
	                  } else {
	                    s5 = peg$FAILED;
	                    { peg$fail(peg$c88); }
	                  }
	                }
	              }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseAdditiveExpr();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c69(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseAdditiveExpr() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseMultiplicativeExpr();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 43) {
	            s5 = peg$c89;
	            peg$currPos++;
	          } else {
	            s5 = peg$FAILED;
	            { peg$fail(peg$c90); }
	          }
	          if (s5 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 45) {
	              s5 = peg$c91;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c92); }
	            }
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseMultiplicativeExpr();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 43) {
	              s5 = peg$c89;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c90); }
	            }
	            if (s5 === peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 45) {
	                s5 = peg$c91;
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                { peg$fail(peg$c92); }
	              }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseMultiplicativeExpr();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c69(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseMultiplicativeExpr() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseUnaryExpr();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseMultiplyOperator();
	          if (s5 === peg$FAILED) {
	            if (input.substr(peg$currPos, 3) === peg$c93) {
	              s5 = peg$c93;
	              peg$currPos += 3;
	            } else {
	              s5 = peg$FAILED;
	              { peg$fail(peg$c94); }
	            }
	            if (s5 === peg$FAILED) {
	              if (input.substr(peg$currPos, 3) === peg$c95) {
	                s5 = peg$c95;
	                peg$currPos += 3;
	              } else {
	                s5 = peg$FAILED;
	                { peg$fail(peg$c96); }
	              }
	            }
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseUnaryExpr();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseMultiplyOperator();
	            if (s5 === peg$FAILED) {
	              if (input.substr(peg$currPos, 3) === peg$c93) {
	                s5 = peg$c93;
	                peg$currPos += 3;
	              } else {
	                s5 = peg$FAILED;
	                { peg$fail(peg$c94); }
	              }
	              if (s5 === peg$FAILED) {
	                if (input.substr(peg$currPos, 3) === peg$c95) {
	                  s5 = peg$c95;
	                  peg$currPos += 3;
	                } else {
	                  s5 = peg$FAILED;
	                  { peg$fail(peg$c96); }
	                }
	              }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseUnaryExpr();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c69(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseUnaryExpr() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseUnionExpr();
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c51(s1);
	      }
	      s0 = s1;
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 45) {
	          s1 = peg$c91;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          { peg$fail(peg$c92); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parse_();
	          if (s2 !== peg$FAILED) {
	            s3 = peg$parseUnaryExpr();
	            if (s3 !== peg$FAILED) {
	              s1 = peg$c97(s3);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseLiteral() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s1 = peg$c98;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        { peg$fail(peg$c99); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        if (peg$c100.test(input.charAt(peg$currPos))) {
	          s3 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          { peg$fail(peg$c101); }
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          if (peg$c100.test(input.charAt(peg$currPos))) {
	            s3 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            { peg$fail(peg$c101); }
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 34) {
	            s3 = peg$c98;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            { peg$fail(peg$c99); }
	          }
	          if (s3 !== peg$FAILED) {
	            s1 = peg$c102(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 39) {
	          s1 = peg$c103;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          { peg$fail(peg$c104); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = [];
	          if (peg$c105.test(input.charAt(peg$currPos))) {
	            s3 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            { peg$fail(peg$c106); }
	          }
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            if (peg$c105.test(input.charAt(peg$currPos))) {
	              s3 = input.charAt(peg$currPos);
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              { peg$fail(peg$c106); }
	            }
	          }
	          if (s2 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 39) {
	              s3 = peg$c103;
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              { peg$fail(peg$c104); }
	            }
	            if (s3 !== peg$FAILED) {
	              s1 = peg$c102(s2);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseNumber() {
	      var s0, s1, s2, s3, s4;

	      s0 = peg$currPos;
	      s1 = peg$parseDigits();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 46) {
	          s3 = peg$c55;
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          { peg$fail(peg$c56); }
	        }
	        if (s3 !== peg$FAILED) {
	          s4 = peg$parseDigits();
	          if (s4 === peg$FAILED) {
	            s4 = null;
	          }
	          if (s4 !== peg$FAILED) {
	            s3 = [s3, s4];
	            s2 = s3;
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 === peg$FAILED) {
	          s2 = null;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c107(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 46) {
	          s1 = peg$c55;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          { peg$fail(peg$c56); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parseDigits();
	          if (s2 !== peg$FAILED) {
	            s1 = peg$c108(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseDigits() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c109.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        { peg$fail(peg$c110); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c109.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            { peg$fail(peg$c110); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c111(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseMultiplyOperator() {
	      var s0;

	      if (input.charCodeAt(peg$currPos) === 42) {
	        s0 = peg$c112;
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        { peg$fail(peg$c113); }
	      }

	      return s0;
	    }

	    function peg$parseFunctionName() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$parseQName();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$c114(s1);
	        if (s2) {
	          s2 = void 0;
	        } else {
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c115(s1);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseVariableReference() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 36) {
	        s1 = peg$c116;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        { peg$fail(peg$c117); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseQName();
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c118(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNameTest() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 42) {
	        s1 = peg$c112;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        { peg$fail(peg$c113); }
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c119();
	      }
	      s0 = s1;
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$parseNCName();
	        if (s1 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 58) {
	            s2 = peg$c120;
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            { peg$fail(peg$c121); }
	          }
	          if (s2 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 42) {
	              s3 = peg$c112;
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              { peg$fail(peg$c113); }
	            }
	            if (s3 !== peg$FAILED) {
	              s1 = peg$c122(s1);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          s1 = peg$parseQName();
	          if (s1 !== peg$FAILED) {
	            s1 = peg$c123(s1);
	          }
	          s0 = s1;
	        }
	      }

	      return s0;
	    }

	    function peg$parseNodeType() {
	      var s0;

	      if (input.substr(peg$currPos, 7) === peg$c124) {
	        s0 = peg$c124;
	        peg$currPos += 7;
	      } else {
	        s0 = peg$FAILED;
	        { peg$fail(peg$c125); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 4) === peg$c126) {
	          s0 = peg$c126;
	          peg$currPos += 4;
	        } else {
	          s0 = peg$FAILED;
	          { peg$fail(peg$c127); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.substr(peg$currPos, 22) === peg$c43) {
	            s0 = peg$c43;
	            peg$currPos += 22;
	          } else {
	            s0 = peg$FAILED;
	            { peg$fail(peg$c44); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.substr(peg$currPos, 4) === peg$c128) {
	              s0 = peg$c128;
	              peg$currPos += 4;
	            } else {
	              s0 = peg$FAILED;
	              { peg$fail(peg$c129); }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseS() {
	      var s0, s1;

	      s0 = [];
	      if (peg$c130.test(input.charAt(peg$currPos))) {
	        s1 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        { peg$fail(peg$c131); }
	      }
	      if (s1 !== peg$FAILED) {
	        while (s1 !== peg$FAILED) {
	          s0.push(s1);
	          if (peg$c130.test(input.charAt(peg$currPos))) {
	            s1 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s1 = peg$FAILED;
	            { peg$fail(peg$c131); }
	          }
	        }
	      } else {
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parse_() {
	      var s0;

	      s0 = peg$parseS();
	      if (s0 === peg$FAILED) {
	        s0 = null;
	      }

	      return s0;
	    }

	    function peg$parseQName() {
	      var s0, s1;

	      s0 = peg$currPos;
	      s1 = peg$parsePrefixedName();
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseUnprefixedName();
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c132(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parsePrefixedName() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseNCName();
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 58) {
	          s2 = peg$c120;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          { peg$fail(peg$c121); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseNCName();
	          if (s3 !== peg$FAILED) {
	            s1 = peg$c133(s1, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseUnprefixedName() {
	      var s0, s1;

	      s0 = peg$currPos;
	      s1 = peg$parseNCName();
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c134(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseNCName() {
	      var s0;

	      s0 = peg$parseName();

	      return s0;
	    }

	    function peg$parseNameStartChar() {
	      var s0;

	      if (peg$c135.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        { peg$fail(peg$c136); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 95) {
	          s0 = peg$c137;
	          peg$currPos++;
	        } else {
	          s0 = peg$FAILED;
	          { peg$fail(peg$c138); }
	        }
	        if (s0 === peg$FAILED) {
	          if (peg$c139.test(input.charAt(peg$currPos))) {
	            s0 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            { peg$fail(peg$c140); }
	          }
	          if (s0 === peg$FAILED) {
	            if (peg$c141.test(input.charAt(peg$currPos))) {
	              s0 = input.charAt(peg$currPos);
	              peg$currPos++;
	            } else {
	              s0 = peg$FAILED;
	              { peg$fail(peg$c142); }
	            }
	            if (s0 === peg$FAILED) {
	              if (peg$c143.test(input.charAt(peg$currPos))) {
	                s0 = input.charAt(peg$currPos);
	                peg$currPos++;
	              } else {
	                s0 = peg$FAILED;
	                { peg$fail(peg$c144); }
	              }
	              if (s0 === peg$FAILED) {
	                if (peg$c145.test(input.charAt(peg$currPos))) {
	                  s0 = input.charAt(peg$currPos);
	                  peg$currPos++;
	                } else {
	                  s0 = peg$FAILED;
	                  { peg$fail(peg$c146); }
	                }
	                if (s0 === peg$FAILED) {
	                  if (peg$c147.test(input.charAt(peg$currPos))) {
	                    s0 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                  } else {
	                    s0 = peg$FAILED;
	                    { peg$fail(peg$c148); }
	                  }
	                  if (s0 === peg$FAILED) {
	                    if (peg$c149.test(input.charAt(peg$currPos))) {
	                      s0 = input.charAt(peg$currPos);
	                      peg$currPos++;
	                    } else {
	                      s0 = peg$FAILED;
	                      { peg$fail(peg$c150); }
	                    }
	                    if (s0 === peg$FAILED) {
	                      if (peg$c151.test(input.charAt(peg$currPos))) {
	                        s0 = input.charAt(peg$currPos);
	                        peg$currPos++;
	                      } else {
	                        s0 = peg$FAILED;
	                        { peg$fail(peg$c152); }
	                      }
	                      if (s0 === peg$FAILED) {
	                        if (peg$c153.test(input.charAt(peg$currPos))) {
	                          s0 = input.charAt(peg$currPos);
	                          peg$currPos++;
	                        } else {
	                          s0 = peg$FAILED;
	                          { peg$fail(peg$c154); }
	                        }
	                        if (s0 === peg$FAILED) {
	                          if (peg$c155.test(input.charAt(peg$currPos))) {
	                            s0 = input.charAt(peg$currPos);
	                            peg$currPos++;
	                          } else {
	                            s0 = peg$FAILED;
	                            { peg$fail(peg$c156); }
	                          }
	                          if (s0 === peg$FAILED) {
	                            if (peg$c157.test(input.charAt(peg$currPos))) {
	                              s0 = input.charAt(peg$currPos);
	                              peg$currPos++;
	                            } else {
	                              s0 = peg$FAILED;
	                              { peg$fail(peg$c158); }
	                            }
	                            if (s0 === peg$FAILED) {
	                              if (peg$c159.test(input.charAt(peg$currPos))) {
	                                s0 = input.charAt(peg$currPos);
	                                peg$currPos++;
	                              } else {
	                                s0 = peg$FAILED;
	                                { peg$fail(peg$c160); }
	                              }
	                              if (s0 === peg$FAILED) {
	                                if (peg$c161.test(input.charAt(peg$currPos))) {
	                                  s0 = input.charAt(peg$currPos);
	                                  peg$currPos++;
	                                } else {
	                                  s0 = peg$FAILED;
	                                  { peg$fail(peg$c162); }
	                                }
	                              }
	                            }
	                          }
	                        }
	                      }
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseNameChar() {
	      var s0;

	      s0 = peg$parseNameStartChar();
	      if (s0 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 45) {
	          s0 = peg$c91;
	          peg$currPos++;
	        } else {
	          s0 = peg$FAILED;
	          { peg$fail(peg$c92); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 46) {
	            s0 = peg$c55;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            { peg$fail(peg$c56); }
	          }
	          if (s0 === peg$FAILED) {
	            if (peg$c109.test(input.charAt(peg$currPos))) {
	              s0 = input.charAt(peg$currPos);
	              peg$currPos++;
	            } else {
	              s0 = peg$FAILED;
	              { peg$fail(peg$c110); }
	            }
	            if (s0 === peg$FAILED) {
	              if (peg$c163.test(input.charAt(peg$currPos))) {
	                s0 = input.charAt(peg$currPos);
	                peg$currPos++;
	              } else {
	                s0 = peg$FAILED;
	                { peg$fail(peg$c164); }
	              }
	              if (s0 === peg$FAILED) {
	                if (peg$c165.test(input.charAt(peg$currPos))) {
	                  s0 = input.charAt(peg$currPos);
	                  peg$currPos++;
	                } else {
	                  s0 = peg$FAILED;
	                  { peg$fail(peg$c166); }
	                }
	                if (s0 === peg$FAILED) {
	                  if (peg$c167.test(input.charAt(peg$currPos))) {
	                    s0 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                  } else {
	                    s0 = peg$FAILED;
	                    { peg$fail(peg$c168); }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseName() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseNameStartChar();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseNameChar();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseNameChar();
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c169(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }


	    	var expressionSimplifier = function(left, right, rightTypeIndex, rightPartIndex)
	    	{
	    		var  i, j
	    			,result = {
	    				type: '',
	    				args: []
	    			}
	    		;

	    		result.args.push(left);
	    		for(i = 0; i < right.length; i++)
	    		{
	    			switch(typeof rightTypeIndex)
	    			{
	    				case 'string':
	    					result.type = rightTypeIndex;
	    					break;

	    				case 'object':
	    					result.type = right[i][rightTypeIndex[0]];
	    					for(j=1; j < rightTypeIndex.length; j++)
	    					{
	    						result.type = result.type[rightTypeIndex[j]];
	    					}
	    					break;

	    				default:
	    					result.type = right[i][rightTypeIndex];
	    					break;
	    			}
	    			result.args.push(
	    				(typeof rightPartIndex == 'undefined') ? right[i] : right[i][rightPartIndex]
	    			);
	    			
	    			result = {
	    				type: '',
	    				args:[
	    					result
	    				]
	    			};
	    		}
	    		
	    		return result.args[0];
	    	}
	    	
	    	,predicateExpression = function(expr, axis, predicate, predicateIndex)
	    	{
	    		var i, predicates = [];
	    		
	    		if (predicate.length < 1)
	    		{
	    			return expr;
	    		}
	    		
	    		for (i=0; i < predicate.length; i++)
	    		{
	    			predicates.push(predicate[i][predicateIndex]);
	    		}
	    		
	    		return {
	    			type: 'predicate',
	    			args: [
	    				axis,
	    				expr,
	    				predicates
	    			]
	    		}
	    	}

	    	// Track all namespace prefixes used in the expression
	    	,nsPrefixes = []
	    	
	    	,trackNsPrefix = function(ns)
	    	{
	    		var  i
	    			,nsPrefixExists = false
	    		;
	    		
	    		if (ns === null) return;

	    		// add namespace to the list of namespaces
	    		for (i = 0; i < nsPrefixes.length; i++) {
	    			if (nsPrefixes[i] === ns) {
	    				nsPrefixExists = true;
	    				break;
	    			}
	    		}

	    		if (!nsPrefixExists)
	    		{
	    			nsPrefixes.push(ns);
	    		}
	    	}
	    	
	    	,lastQNameParsed
	    	,nodeTypeNames = [
	    		'comment',
	    		'text',
	    		'processing-instruction',
	    		'node'
	    	]
	    	,expandSlashAbbrev = function(slash, left, right)
	    	{
	    		if (slash == '/')
	    		{
	    			return {
	    				type: '/',
	    				args: [
	    					left,
	    					right
	    				]
	    			};
	    		}
	    		
	    		// slash == '//'
	    		return {
	    			type: '/',
	    			args: [
	    				{
	    					type: '/',
	    					args: [
	    						left,
	    						{
	    							type: 'step',
	    							args: [
	    								'descendant-or-self',
	    								{
	    									type: 'nodeType',
	    									args: [
	    										'node',
	    										[]
	    									]
	    								}
	    							]
	    						}
	    					]
	    				},
	    				right
	    			]
	    		};
	    	}
	    	;


	    peg$result = peg$startRuleFunction();

	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail({ type: "end", description: "end of input" });
	      }

	      throw peg$buildException(
	        null,
	        peg$maxFailExpected,
	        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
	        peg$maxFailPos < input.length
	          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
	          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
	      );
	    }
	  }

	  return {
	    SyntaxError: peg$SyntaxError,
	    parse:       peg$parse
	  };
	})();

	var MAX_INT32 = 2147483647;
	var MINSTD = 16807;

	/**
	 * Performs the "inside-out" variant of the Fisher-Yates array shuffle.
	 * 
	 * @see https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_%22inside-out%22_algorithm
	 * 
	 * @param  {<*>}        array the array to shuffle
	 * @param  {number=}    seed the seed value
	 * @return {<*>}        the suffled array
	 */
	function shuffle( array, seed ) {
	    var rng;
	    var result = [];

	    if ( typeof seed !== 'undefined' ){
	        if ( !Number.isInteger( seed ) ) {
	            throw new Error('Invalid seed argument. Integer required.');
	        }
	        var rnd = new Random( seed );
	        rng = rnd.nextFloat.bind(rnd);
	    } else {
	        rng = Math.random;
	    }

	    for ( var i = 0; i < array.length; ++i ) {
	      var j = Math.floor( rng() * ( i + 1 ) );
	  
	      if ( j !== i ) {
	        result[i] = result[j];
	      }
	  
	      result[j] = array[i];
	    }
	  
	    return result;
	}

	// Polyfill for Internet Explorer
	Number.isInteger = Number.isInteger || function( value ) {
	    return typeof value === 'number' &&
	        isFinite( value ) &&
	        Math.floor( value ) === value;
	};

	/**
	 * Creates a the Park-Miller PRNG pseudo-random value generator. 
	 * The seed must be an integer.
	 * 
	 * Adapted from: https://gist.github.com/blixt/f17b47c62508be59987b
	 */
	function Random( seed ) {
	    this._seed = seed % MAX_INT32;
		if ( this._seed <= 0 ) {
			this._seed += ( MAX_INT32 - 1 );
		}
	}

	/**
	 * Returns a pseudo-random integer value.
	 */
	Random.prototype.next = function () {
	    return this._seed = this._seed * MINSTD % MAX_INT32;
	};

	/**
	 * Returns a pseudo-random floating point number in range [0, 1).
	 */
	Random.prototype.nextFloat = function () {
	    // We know that result of next() will be 1 to 2147483646 (inclusive).
	    return ( this.next() - 1 ) / ( MAX_INT32 - 1 );
	}; 

	var shuffle_1 = shuffle;

	var EARTH_EQUATORIAL_RADIUS_METERS = 6378100;
	var PRECISION = 100;

	function _toLatLngs(geopoints) {
	    return geopoints.map(function (geopoint) {
	        return geopoint.trim().split(' ');
	    });
	}

	// converts degrees to radians
	function _toRadians(angle) {
	    return angle * Math.PI / 180;
	}

	// check if all geopoints are valid (copied from Enketo FormModel)
	function _latLngsValid(latLngs) {
	    return latLngs.every(function (coords) {
	        return (
	            (coords[0] !== '' && coords[0] >= -90 && coords[0] <= 90) &&
	            (coords[1] !== '' && coords[1] >= -180 && coords[1] <= 180) &&
	            (typeof coords[2] == 'undefined' || !isNaN(coords[2])) &&
	            (typeof coords[3] == 'undefined' || (!isNaN(coords[3]) && coords[3] >= 0))
	        );
	    });
	}

	/**
	 * Adapted from https://www.movable-type.co.uk/scripts/latlong.html
	 * 
	 * @param {{lat:number, lng: number}} p1 
	 * @param {{lat:number, lng: number}} p2 
	 * @returns {number}
	 */
	function _distanceBetween(p1,p2) {
	    var Δλ = _toRadians(p1.lng - p2.lng);
	    var φ1 = _toRadians(p1.lat);
	    var φ2 = _toRadians(p2.lat);
	    return Math.acos(Math.sin(φ1) * Math.sin(φ2) + Math.cos(φ1) * Math.cos(φ2) * Math.cos(Δλ)) * EARTH_EQUATORIAL_RADIUS_METERS;
	}

	/**
	 * Adapted from https://github.com/Leaflet/Leaflet.draw/blob/3cba37065ea5be28f42efe9cc47836c9e3f5db8c/src/ext/GeometryUtil.js#L3-L20
	 */
	function area(geopoints) {
	    var latLngs = _toLatLngs(geopoints);

	    if (!_latLngsValid(latLngs)) {
	        return Number.NaN;
	    }

	    var pointsCount = latLngs.length;
	    var area = 0.0;

	    if (pointsCount > 2) {
	        for (var i = 0; i < pointsCount; i++) {
	            var p1 = {
	                lat: latLngs[i][0],
	                lng: latLngs[i][1]
	            };
	            var p2 = {
	                lat: latLngs[(i + 1) % pointsCount][0],
	                lng: latLngs[(i + 1) % pointsCount][1]
	            };
	            area += _toRadians(p2.lng - p1.lng) *
	                (2 + Math.sin(_toRadians(p1.lat)) + Math.sin(_toRadians(p2.lat)));
	        }
	        area = area * EARTH_EQUATORIAL_RADIUS_METERS * EARTH_EQUATORIAL_RADIUS_METERS / 2.0;
	    }
	    return Math.abs(Math.round(area * PRECISION)) / PRECISION;
	}

	/**
	 * @param {any} geopoints 
	 * @returns 
	 */
	function distance(geopoints) {
	    var latLngs = _toLatLngs(geopoints);

	    if (!_latLngsValid(latLngs)) {
	        return Number.NaN;
	    }

	    var pointsCount = latLngs.length;
	    var distance = 0.0;

	    if (pointsCount > 1) {
	        for (var i = 1; i < pointsCount; i++) {
	            var p1 = {
	                lat: latLngs[i - 1][0],
	                lng: latLngs[i - 1][1]
	            };
	            var p2 = {
	                lat: latLngs[i][0],
	                lng: latLngs[i][1]
	            };

	            distance += _distanceBetween(p1, p2);
	        }
	    }
	    
	    return Math.abs(Math.round(distance * PRECISION)) / PRECISION;}

	var geo = {
	    area: area,
	    distance: distance
	};

	/**
	 * Original copyright notice for XPathJS:
	 *
	 * Copyright (C) 2011 Andrej Pavlovic for XPathJS
	 *
	 * This file is part of XPathJS.
	 *
	 * XPathJS is free software: you can redistribute it and/or modify it under
	 * the terms of the GNU Affero General Public License as published by the Free
	 * Software Foundation, version 3 of the License.
	 *
	 * XPathJS is distributed in the hope that it will be useful, but WITHOUT ANY
	 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
	 * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
	 * details.
	 *
	 * You should have received a copy of the GNU Affero General Public License along
	 * with this program. If not, see <http://www.gnu.org/licenses/>.
	 */

	/* global window */





	var engine = (function(){
		var XPathException,
			XPathEvaluator,
			XPathExpression,
			XPathNSResolver,
			XPathResult,
			XPathNamespace,
			module,
			evaluateExpressionTree,
			expressions,
			functions,
			Context,
			namespaceCache = [],
			
			NAMESPACE_URI_XML = 'http://www.w3.org/XML/1998/namespace',
			NAMESPACE_URI_XMLNS = 'http://www.w3.org/2000/xmlns/',
			NAMESPACE_URI_XHTML = 'http://www.w3.org/1999/xhtml',
			
			// XPath types
			BaseType,
			BooleanType,
			StringType,
			NumberType,
			NodeSetType,
			DateType,
			
			// HACK: track expression currently being evaluated
			currentExpression,
			
			/**
			 * Return all direct children of given node, but only those explicitly
			 * allowed by XPath specification.
			 *
			 * @param {Node} node
			 * @return {Array} List of nodes in document order.
			 */
			nodeChildren = function(node)
			{
				var nodes = [],
					filterSupportedNodeTypes = function(nodes, types)
					{
						var item, i, filteredNodes = [];
						
						for(i=0; i < nodes.length; i++)
						{
							item = nodes.item(i);
							if (false !== arrayIndexOf(item.nodeType, types))
							{
								filteredNodes.push(item);
							}
						}
						
						return filteredNodes;
					}
				;

				switch(node.nodeType)
				{
					/**
					 * @see http://www.w3.org/TR/xpath/#element-nodes
					 *
					 * The children of an element node are the element nodes, comment nodes, processing
					 * instruction nodes and text nodes for its content.
					 */
					case 1: // element,
						nodes = filterSupportedNodeTypes(node.childNodes,  [
							1, // element
							3, // text
							4, // CDATASection
							7, // processing instruction
							8  // comment
						]);
						break;
					
					/**
					 * @see http://www.w3.org/TR/xpath/#root-node
					 *
					 * The element node for the document element is a child of the root node. The root
					 * node also has as children processing instruction and comment nodes for
					 * processing instructions and comments that occur in the prolog and
					 * after the end of the document element.
					 */
					case 9: // document
						nodes = filterSupportedNodeTypes(node.childNodes, [
							1, // element
							7, // processing instruction
							8  // comment
						]);
						break;
					
					case 2: // attribute
					case 3: // text
					case 4: // CDATASection
					case 7: // processing instruction
					case 8: // comment
					case 13: // namespace
						break;
					
					default:
						throw new Error('Internal Error: nodeChildren - unsupported node type: ' + node.nodeType);
				}
				
				return nodes;
			},
			
			/**
			 * Return all decendants of given node.
			 *
			 * @param {Node} node
			 * @return {Array} List of nodes in document order.
			 */
			nodeDescendant = function(node)
			{
				var nodes,
					i,
					nodes2 = []
				;
				
				nodes = nodeChildren(node);
				
				for(i = 0; i < nodes.length; i++)
				{
					nodes2.push(nodes[i]);
					nodes2.push.apply(nodes2, nodeDescendant(nodes[i]));
				}
				
				return nodes2;
			},
			
			/**
			 * Return parent of given node if there is one.
			 *
			 * @param {Node} node
			 * @return {Node}
			 */
			nodeParent = function(node)
			{
				/**
				 * All nodes, except Attr, Document, DocumentFragment, Entity, and Notation may have a parent.
				 *
				 * @see http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1060184317
				 */
				var element
				;
				
				switch(node.nodeType)
				{
					case 1: // element
					case 3: // text
					case 4: // CDATAsection
					case 7: // processing instruction
					case 8: // comment
					case 9: // document
						return node.parentNode;
					
					case 2: // Node.ATTRIBUTE_NODE
						// DOM 2 has ownerElement
						if (node.ownerElement) {
							return node.ownerElement;
						}
						
						// Other DOM 1 implementations must search the entire document...
						element = nodeAttributeSearch(node.ownerDocument, true, function(element, attribute) {
							if (attribute === node)
							{
								return true;
							}
						});
						
						return element;
					
					case 13: // Node.NAMESPACE_NODE
						return node.ownerElement;
					
					default:
						throw new Error('Internal Error: nodeParent - node type not supported: ' + node.type);
				}
			},
			
			
			/**
			 * Return ancestors of given node.
			 *
			 * @param {Node} node
			 * @return {Array} List of nodes in reverse document order
			 */
			nodeAncestor = function(node)
			{
				var parent,
					nodes = []
				;
				
				while((parent = nodeParent(node)))
				{
					nodes.push(parent);
					node = parent;
				}
				
				return nodes;
			},
			
			/**
			 * Return following siblings of given node.
			 *
			 * @param {Node} node
			 * @return {Array} List of nodes in document order
			 */
			nodeFollowingSibling = function(node)
			{
				return nodeXSibling(node, 'nextSibling');
			},
			
			/**
			 * Return preceding siblings of given node.
			 *
			 * @param {Node} node
			 * @return {Array} List of nodes in reverse document order
			 */
			nodePrecedingSibling = function(node)
			{
				return nodeXSibling(node, 'previousSibling');
			},
			
			nodeXSibling = function(node, type)
			{
				var sibling,
					nodes = []
				;
				
				while ((sibling = node[type]))
				{
					switch(sibling.nodeType)
					{
						case 1: // element
						case 3: // text
						case 4: // CDATAsection
						case 7: // processing instruction
						case 8: // comment
						case 9: // document
							nodes.push(sibling);
							break;
							
						default:
							// don't add it
							break;
					}
					
					node = sibling;
				}
				
				return nodes;
			},
			
			/**
			 * Return following nodes of given node in document order excluding direct descendants.
			 *
			 * @param {Node} node
			 * @return {Array} List of nodes in document order
			 */
			nodeFollowing = function(node)
			{
				var nodes = [],
					parents,
					i,
					siblings,
					j
				;
				
				parents = nodeAncestor(node);
				parents.unshift(node);
				
				for(i=0; i < parents.length; i++)
				{
					siblings = nodeFollowingSibling(parents[i]);
					for(j=0; j < siblings.length; j++)
					{
						nodes.push(siblings[j]);
						nodes.push.apply(nodes, nodeDescendant(siblings[j]));
					}
				}
				
				return nodes;
			},
			
			/**
			 * Return preceding nodes of given node excluding direct ancestors.
			 *
			 * @param {Node} node
			 * @return {Array} List of nodes in reverse document order
			 */
			nodePreceding = function(node)
			{
				var nodes = [],
					parents,
					i,
					siblings,
					j
				;
				
				parents = nodeAncestor(node);
				parents.unshift(node);
				
				for(i=0; i < parents.length; i++)
				{
					siblings = nodePrecedingSibling(parents[i]);
					for(j=0; j < siblings.length; j++)
					{
						nodes.push.apply(nodes, nodeDescendant(siblings[j]).reverse());
						nodes.push(siblings[j]);
					}
				}
				
				return nodes;
			},
			
			/**
			 * Return owner document of node, or node itself if document
			 *
			 * @param {Node} node
			 * @return {Document} 
			 */
			nodeOwnerDocument = function(node)
			{
				switch(node.nodeType)
				{
					case 9: // document
						return node;
						
					default:
						return node.ownerDocument;
				}
			},
			
			/**
			 * Return attributes of given element in document order regardless of whether they may be namespace nodes or not.
			 * 
			 * @return {Array} List of attribute nodes in document order
			 */
			nodeGetAttributes = function(node) 
			{
				var nodes = [],
					i
				;
				
				if (node.nodeType === 1) // element
				{
					for(i=0; i<node.attributes.length; i++)
					{
						if (!node.attributes[i].specified)
						{
							continue;
						}
						
						nodes.push(node.attributes[i]);
					}
				}
				
				// sort attributes if compareDocumentPosition available
				if (nodes.length > 1 && nodes[0].compareDocumentPosition) {
					nodes.sort(function(a, b) {
						var position = a.compareDocumentPosition(b);
						
						if ((position & 2) == 2) return 1;
						else if ((position & 4) == 4) return -1;
						else return 0;
					});
				}
				
				return nodes;
			},
			
			/**
			 * Return attributes of given element (no namespaces of course). Empty array otherwise
			 *
			 * @param {Node} node
			 * @return {Array} List of attribute nodes in document order
			 */
			nodeAttribute = function(node)
			{
				var allAttributeNodes = nodeGetAttributes(node),
					nodes = [],
					i
				;
				
				for(i = 0; i < allAttributeNodes.length; i++)
				{
					if (false === isNamespaceAttributeNode(allAttributeNodes[i]))
					{
						nodes.push(allAttributeNodes[i]);
					}
				}
				
				return nodes;
			},
			
			/**
			 * Return namespace nodes of given element node. Empty array otherwise
			 *
			 * @param {Node} node
			 * @param {Array} (optional) List of namespace nodes (in document order) to include
			 * @return {Array} List of namespace nodes in document order
			 */
			nodeNamespace = function(node, nsNodes)
			{
				var nodes = (nsNodes || []),
					allAttributeNodes,
					i,
					name,
					item
				;
				
				if (node.nodeType === 1) // element
				{
					/**
					 * IE puts all namespaces inside document.namespaces for HTML node
					 *
					 * @see http://msdn.microsoft.com/en-us/library/ms537470(VS.85).aspx
					 * @see http://msdn.microsoft.com/en-us/library/ms535854(v=VS.85).aspx
					 */
					if (node.ownerDocument.documentElement === node && typeof node.ownerDocument.namespaces === 'object')
					{
						for(i=node.ownerDocument.namespaces.length-1; i>=0; i--)
						{
							item = node.ownerDocument.namespaces.item(i);
							insertNamespaceIfNotDeclared.call(this, nodes, item.name, item.urn, node);
						}
					}
					
					allAttributeNodes = nodeGetAttributes(node);
					
					for(i = allAttributeNodes.length-1; i>=0; i--)
					{
						if (false === (name = isNamespaceAttributeNode(allAttributeNodes[i])))
						{
							continue;
						}
						
						/**
						 * Check the default namespace
						 *
						 * @see http://www.w3.org/TR/xml-names/#defaulting
						 */
						if (name.length === 1)
						{
							insertNamespaceIfNotDeclared.call(this, nodes, '', allAttributeNodes[i].nodeValue, node);
							continue;
						}
						
						/**
						 * Normal attribute checking for namespace declarations
						 */
						insertNamespaceIfNotDeclared.call(this, nodes, name[1], allAttributeNodes[i].nodeValue, node);
					}
					
					/**
					 * ... resolving the namespaceURI from a given prefix using the
					 * current information available in the node's hierarchy ...
					 *
					 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createNSResolver
					 */
					nodeNamespace.call(this, node.parentNode, nodes);
					
					// finished with tracking down all nodes
					if (nsNodes === undefined)
					{
						// always need this namespace
						insertNamespaceIfNotDeclared.call(this, nodes, 'xml', NAMESPACE_URI_XML, node);
						
						// if the default namespace is empty, remove it
						if (nodes[0] && nodes[0].prefix === '' && nodes[0].namespaceURI === '')
						{
							nodes.shift();
						}
					}
					
					if (nsNodes === undefined)
					{
						// before returning to original caller, we need to ensure all namespace nodes are
						// specific to this parent node
						for(i = 0; i < nodes.length; i++)
						{
							if (nodes[i].ownerElement !== node)
							{
								nodes[i] = createNamespaceNode(nodes[i].prefix, nodes[i].nodeValue, node);
							}
						}
					}
				}
				
				return nodes;
			},
			
			insertNamespaceIfNotDeclared = function(namespaces, prefix, ns, parent)
			{
				var i, namespace;
				
				if (!this.opts['case-sensitive'])
				{
					prefix = prefix.toLowerCase();
				}
				
				for(i=0; i < namespaces.length; i++)
				{
					if (namespaces[i].prefix === prefix)
					{
						// namespace already set, do not allow it to be overwritten
						return false;
					}
				}
				
				namespace = createNamespaceNode(prefix, ns, parent);
				
				if (prefix === '' && ns !== null)
				{
					namespaces.unshift(namespace);
				}
				else
				{
					namespaces.push(namespace);
				}
				
				return true;
			},
			
			isNamespaceAttributeNode = function(node)
			{
				var name = node.nodeName.split(':');
				
				if (name[0] === 'xmlns')
				{
					return name;
				}
				
				return false;
			},
			
			nodeIdAttribute = function(node, attribute)
			{
				var i,
					j,
					attributes,
					namespaces,
					ns,
					name
				;
				
				if (node.nodeType === 1)
				{
					attributes = (!attribute) ? nodeAttribute(node) : [attribute];
					namespaces = nodeNamespace.call(this, node);
					
					for(i=0; i<attributes.length; i++)
					{
						name = attributes[i].nodeName.split(':');
						
						if (name.length === 1)
						{
							// set default namespace
							name[1] = name[0];
							name[0] = '';
						}
						
						// check namespace of attribute
						ns = null;
						for(j=0; j < namespaces.length; j++)
						{
							if (namespaces[j].prefix === name[0])
							{
								ns = namespaces[j].namespaceURI;
								break;
							}
						}
						
						if (ns === null)
							ns = '';
						
						if (this.opts['unique-ids'][ns] === name[1])
						{
							// found it
							return attributes[i];
						}
					}
				}
				
				return null;
			},
			
			nodeAttributeSearch = function(startNode, stopAfterFirstMatch, fn)
			{
				var i,
					j,
					elements,
					element,
					matches = []
				;
				
				// TODO: Possibly cache attribute nodes
				elements = startNode.getElementsByTagName('*');
				for (i = 0; i < elements.length; i++) {
					element = elements.item(i);
					if (element.nodeType != 1 /*Node.ELEMENT_NODE*/)
					{
						continue;
					}
					for (j = 0; j < element.attributes.length; j++) {
						if (!element.attributes[j].specified)
						{
							continue;
						}
						
						if (fn(element, element.attributes[j]) === true)
						{
							if (stopAfterFirstMatch)
							{
								return element;
							}
							else
							{
								matches.push(element);
								break;
							}
						}
					}
				}
				
				if (stopAfterFirstMatch)
				{
					return null;
				}
				else
				{
					return matches;
				}
			},
			
			nodeExpandedName = function(node)
			{
				var name,
					namespaces,
					i,
					qname
				;
				
				switch(node.nodeType)
				{
					/**
					 * There is an element node for every element in the document. An element node has an
					 * expanded-name computed by expanding the QName of the element specified in the
					 * tag in accordance with the XML Namespaces Recommendation [XML Names]. The namespace
					 * URI of the element's expanded-name will be null if the QName has no prefix and there
					 * is no applicable default namespace.
					 */
					case 1: // element
						/**
						 * @see http://tanalin.com/en/articles/ie-version-js/
						 */
						if (typeof node.scopeName != 'undefined' && /* < IE9 */ !document.addEventListener)
						{
							/**
							 * IE specific
							 *
							 * @see http://msdn.microsoft.com/en-us/library/ms534388(v=vs.85).aspx
							 */
							qname = {
								prefix: (node.scopeName == 'HTML') ? '' : node.scopeName,
								name: node.nodeName
							};
						}
						else
						{
							// other browsers
							name = node.nodeName.split(':');
							
							// check for namespace prefix
							if (name.length == 1)
							{
								qname = {
									prefix: '',
									name: name[0]
								};
							}
							else
							{
								qname = {
									prefix: name[0],
									name: name[1]
								};
							}
						}
						
						if (!this.opts['case-sensitive'])
						{
							qname.prefix = qname.prefix.toLowerCase();
							qname.name = qname.name.toLowerCase();
						}
						
						// resolve namespace
						namespaces = nodeNamespace.call(this, node);
						
						for(i=0; i < namespaces.length; i++)
						{
							if (namespaces[i].prefix === qname.prefix)
							{
								qname.ns = namespaces[i].namespaceURI;
								return qname;
							}
						}
						
						if (qname.prefix === '')
						{
							qname.ns = null;
							return qname;
						}
						
						throw new Error('Internal Error: nodeExpandedName - Failed to expand namespace prefix "' + qname.prefix + '" on element: ' + node.nodeName);
					
					case 2: // attribute
						name = node.nodeName.split(':');
						
						// check for namespace prefix
						if (name.length == 1)
						{
							/**
							 * The namespace URI of the attribute's name will be null if
							 * the QName of the attribute does not have a prefix.
							 */
							return {
								prefix: '',
								ns: null,
								name: name[0]
							};
						}
						
						qname = {
							prefix: name[0],
							name: name[1]
						};
						
						if (!this.opts['case-sensitive'])
						{
							qname.prefix = qname.prefix.toLowerCase();
							qname.name = qname.name.toLowerCase();
						}
						
						// resolve namespace
						namespaces = nodeNamespace.call(this, nodeParent(node)); // attribute
						
						for(i=0; i < namespaces.length; i++)
						{
							if (namespaces[i].prefix === qname.prefix)
							{
								qname.ns = namespaces[i].namespaceURI;
								return qname;
							}
						}
						
						throw new Error('Internal Error: nodeExpandedName - Failed to expand namespace prefix "' + qname.prefix + '" on attribute: ' + node.nodeName);
						
					case 13: // namespace
						return {
							prefix: null,
							ns: null,
							name: ((!this.opts['case-sensitive']) ? node.prefix : node.prefix.toLowerCase())
						};
					
					case 7: // processing instruction
						return {
							prefix: null,
							ns: null,
							name: ((!this.opts['case-sensitive']) ? node.target : node.target.toLowerCase())
						};
					
					default:
						return false;
				}
			},
			
			nodeStringValue = function(node)
			{
				var i,
					nodeset,
					value = ''
				;
				
				switch(node.nodeType)
				{
					/**
					 * The string-value of the root node is the concatenation of the string-values of all
					 * text node descendants of the root node in document order.
					 */
					case 9: // document
					/**
					 * The string-value of an element node is the concatenation of the string-values of all
					 * text node descendants of the element node in document order.
					 */
					case 1: // element
						nodeset = evaluateExpressionTree(
							new Context(node, 1, 1, {}, {}, {}), {
								type: 'step',
								args: [
									'descendant',
									{
										type: 'nodeType',
										args: [
											'text',
											[]
										]
									}
								]
							}
						);
						
						nodeset.sortDocumentOrder();
						
						for(i=0; i< nodeset.value.length; i++)
						{
							value += nodeset.value[i].data;
						}
						
						return value;
					
					/**
					 * The string-value is the normalized value as specified by the XML Recommendation [XML].
					 * An attribute whose normalized value is a zero-length string is not treated specially:
					 * it results in an attribute node whose string-value is a zero-length string.
					 *
					 * @see http://www.w3.org/TR/1998/REC-xml-19980210#AVNormalize
					 */
					case 2: // attribute
						return node.nodeValue;
					
					/**
					 * The string-value of a namespace node is the namespace URI that is being bound to the
					 * namespace prefix;
					 * TODO-FUTURE: if it is relative, it must be resolved just like a namespace URI in an expanded-name.
					 */
					case 13: // namespace
						return node.namespaceURI;
					
					/**
					 * The string-value of a processing instruction node is the part of the processing instruction following
					 * the target and any whitespace. It does not include the terminating ?>.
					 */
					case 7: // processing instruction
					/**
					 * The string-value of comment is the content of the comment not including the opening <!-- or the closing -->.
					 */
					case 8: // comment
					/**
					 * The string-value of a text node is the character data. A text node always has at least one character of data.
					 */
					case 3: // text
					case 4: // CDATAsection
						return node.data;
					
					default:
						throw new Error('Internal Error: nodeStringValue does not support node type: ' + node.nodeType);
				}
			},
			
			createError = function(code, name, message)
			{
				var err = new Error(message);
				err.name = name;
				err.code = code;
				return err;
			},
			
			/**
			 * @param {Object} needle
			 * @param {Array} haystack
			 * @return {Number}
			 */
			arrayIndexOf = function(needle, haystack)
			{
				var i = haystack.length;
				while (i--) {
					if (haystack[i] === needle) {
						return i;
					}
				}
				return false;
			},
			
			/**
			 * @see http://www.w3.org/TR/xpath/#booleans
			 */
			compareOperator = function(left, right, operator, compareFunction)
			{
				var i,
					j,
					leftValues,
					rightValues,
					result
				;
				if (left instanceof NodeSetType)
				{
					if (right instanceof NodeSetType)
					{
						/**
						 * If both objects to be compared are node-sets, then the comparison
						 * will be true if and only if there is a node in the first node-set
						 * and a node in the second node-set such that the result of performing
						 * the comparison on the string-values of the two nodes is true.
						 */
						rightValues = right.stringValues();
						leftValues = left.stringValues();
						
						for(i=0; i < leftValues.length; i++)
						{
							for(j=0; j < rightValues.length; j++)
							{
								result = compareOperator(leftValues[i], rightValues[j], operator, compareFunction);
								if (result.toBoolean())
								{
									return result;
								}
							}
						}
					}
					else
					{
						/**
						 * If one object to be compared is a node-set and the other is a number,
						 * then the comparison will be true if and only if there is a node in the node-set
						 * such that the result of performing the comparison on the number to be compared
						 * and on the result of converting the string-value of that node to a
						 * number using the number function is true.
						 */
						if (right instanceof NumberType)
						{
							leftValues = left.stringValues();
							
							for(i=0; i < leftValues.length; i++)
							{
								result = compareOperator(new NumberType(leftValues[i].toNumber()), right, operator, compareFunction);
								if (result.toBoolean())
								{
									return result;
								}
							}
						}
						/**
						 * JavaRosa addition:
						 * Check whether string is a date object or a datestring. A datestring is converted to an
						 * instance of DateType. Note that we've already checked for numbers and that DateType is basically
						 * just the native JavaScript Date object. So any string, except a number string, that can convert to
						 * a valid date is considered a date string. It is safe enough hopefully....
						 */
						else if (right instanceof DateType || (right instanceof StringType && right.isDateString()))
						{
							if (right instanceof StringType)
							{
								right = new DateType(right);
							}

							leftValues = left.stringValues();
							
							for(i=0; i < leftValues.length; i++)
							{
								result = compareOperator(new DateType(leftValues[i].toDate()), right, operator, compareFunction);
								if (result.toBoolean())
								{
									return result;
								}
							}
						}
						/**
						 * If one object to be compared is a node-set and the other is a string, then the
						 * comparison will be true if and only if there is a node in the node-set such
						 * that the result of performing the comparison on the string-value of
						 * the node and the other string is true.
						 */
						else if (right instanceof StringType)
						{
							leftValues = left.stringValues();
							
							for(i=0; i < leftValues.length; i++)
							{
								result = compareOperator(leftValues[i], right, operator, compareFunction);
								if (result.toBoolean())
								{
									return result;
								}
							}
						}
						/**
						 * If one object to be compared is a node-set and the other is a boolean, then the comparison
						 * will be true if and only if the result of performing the comparison on the boolean
						 * and on the result of converting the node-set to a boolean using the boolean function is true.
						 */
						else
						{
							return compareOperator(new BooleanType(left.toBoolean()), right, operator, compareFunction);
						}
					}
				}
				else
				{
					if (right instanceof NodeSetType)
					{
						/**
						 * If one object to be compared is a node-set and the other is a number,
						 * then the comparison will be true if and only if there is a node in the node-set
						 * such that the result of performing the comparison on the number to be compared
						 * and on the result of converting the string-value of that node to a
						 * number using the number function is true.
						 */
						if (left instanceof NumberType)
						{
							rightValues = right.stringValues();
							
							for(i=0; i < rightValues.length; i++)
							{
								result = compareOperator(left, new NumberType(rightValues[i].toNumber()), operator, compareFunction);
								if (result.toBoolean())
								{
									return result;
								}
							}
						}
						/** JavaRosa addition:
						 * If one object to be compared is a date object or a datestring....etc. A datestring is converted to an
						 * instance of DateType. Note that we've already checked for numbers and that DateType is basically
						 * just the native JavaScript Date object. So any string, except a number string, that can convert to
						 * a valid date is considered a date string. It is safe enough hopefully...
						 */
						else if (left instanceof DateType || (left instanceof StringType && left.isDateString()))
						{
							if (left instanceof StringType)
							{
								left = new DateType(left);
							}

							rightValues = right.stringValues();

							for(i=0; i < rightValues.length; i++)
							{
								result = compareOperator(left, new DateType(rightValues[i].toDate()), operator, compareFunction);
								if (result.toBoolean())
								{
									return result;
								}
							}
						}
						/**
						 * If one object to be compared is a node-set and the other is a string, then the
						 * comparison will be true if and only if there is a node in the node-set such
						 * that the result of performing the comparison on the string-value of
						 * the node and the other string is true.
						 */
						else if (left instanceof StringType)
						{
							rightValues = right.stringValues();
							
							for(i=0; i < rightValues.length; i++)
							{
								result = compareOperator(left, rightValues[i], operator, compareFunction);
								if (result.toBoolean())
								{
									return result;
								}
							}
						}
						/**
						 * If one object to be compared is a node-set and the other is a boolean, then the comparison
						 * will be true if and only if the result of performing the comparison on the boolean
						 * and on the result of converting the node-set to a boolean using the boolean function is true.
						 */
						else
						{
							return compareOperator(left, new BooleanType(right.toBoolean()), operator, compareFunction);
						}
					}
					else
					{
						switch(operator)
						{
							/**
							 * When neither object to be compared is a node-set and the operator is = or !=,
							 * then the objects are compared by converting them to a common type as
							 * follows and then comparing them.
							 */
							case '=':
							case '!=':
								/**
								 * If at least one object to be compared is a boolean, then each object to be
								 * compared is converted to a boolean as if by applying the boolean function.
								 */
								if (left instanceof BooleanType || right instanceof BooleanType)
								{
									return new BooleanType(compareFunction(left.toBoolean(), right.toBoolean()));
								}
								/**
								 * Otherwise, if at least one object to be compared is a number, then each object
								 * to be compared is converted to a number as if by applying the number function.
								 */
								else if (left instanceof NumberType || right instanceof NumberType)
								{
									return new BooleanType(compareFunction(left.toNumber(), right.toNumber()));
								}
								/**
								 * With Dates, we have to fight interal JavaScript Date behavior, because
								 * new Date(1012,1,1) !== new Date(1012,1,1) (different objects).
								 * So we convert to number. I'm not sure if should be done elsewhere instead.
								 */
								else if (left instanceof DateType || right instanceof DateType 
									|| (left instanceof StringType && left.isDateString()) 
									|| (right instanceof StringType && right.isDateString()))
								{
									return new BooleanType(compareFunction(left.toNumber(), right.toNumber()));
								}

								/**
								 * Otherwise, both objects to be compared are converted to strings
								 * as if by applying the string function.
								 */
								return new BooleanType(compareFunction(left.toString(), right.toString()));
							
							/**
							 * When neither object to be compared is a node-set and the operator is <=, <, >= or >,
							 * then the objects are compared by converting both objects to numbers and comparing
							 * the numbers according to IEEE 754.
							 */
							default:
								return new BooleanType(compareFunction(left.toNumber(), right.toNumber()));
						}
					}
				}
				
				return new BooleanType(false);
			},
			
			getComparableNode = function(node)
			{
				switch(node.nodeType)
				{
					case 2: // attribute
					case 3: // text
					case 4: // CDATASection
					case 7: // processing instruction
					case 8: // comment
						return nodeParent(node);
					
					case 1: // element
					case 9: // document
						// leave as is
						return node;
					
					case 13: // namespace
					default:
						throw new Error('Internal Error: getComparableNode - Node type not supported: ' + node.nodeType);
				}
			},
			
			compareDocumentPosition = function(a, b)
			{
				var result, nodes, i;
				
				if (a.nodeType == 13 &&
					b.nodeType == 13 &&
					a.ownerElement == b.ownerElement
				) {
					// identical
					if (a === b) return 0;
					
					nodes = nodeNamespace.call(currentExpression, a.ownerElement);
					
					for(i=0; i < nodes.length; i++)
					{
						if (nodes[i] === a)
						{
							result = 4;
							break;
						}
						else if (nodes[i] === b)
						{
							result = 2;
							break;
						}
					}
				}
				else
				{
					if (a.nodeType == 13) a = a.ownerElement;
					if (b.nodeType == 13) b = b.ownerElement;
					
					result = compareDocumentPositionNoNamespace(a, b);
				}
				
				return result;
			},
			
			/**
			 * @see http://ejohn.org/blog/comparing-document-position/
			 */
			compareDocumentPositionNoNamespace = function(a, b)
			{
				var a2,
					b2,
					result,
					i,
					item,
					compareOriginalVsComparableNode = function(a, a2, b, b2, result, v16, v8, v4, v2) {
						// if a contains b2 or a == b2
						if (result === 0 || (result & v16) === v16)
						{
							// return result
							return v4 + v16;
						}
						// else if b2 contains a
						else if ((result & v8) === v8)
						{
							// since b != b2, b is an attribute
							// and since a == a2, a is a node,
							// so b has to come before a
							return v2;
						}
						else
						{
							// return result
							return result;
						}
					}
				;
				
				// check for native implementation
				if (a.compareDocumentPosition)
				{
					return a.compareDocumentPosition(b);
				}
				
				if (a === b)
				{
					return 0;
				}
				
				a2 = getComparableNode(a);
				b2 = getComparableNode(b);
				
				// handle document case
				if (a2.nodeType === 9)
				{
					if (b2.nodeType === 9)
					{
						if (a2 !== b2)
						{
							return 1; // different documents
						}
						else
						{
							result = 0; // same nodes
						}
					}
					else
					{
						if (a2 !== b2.ownerDocument)
						{
							return 1; // different documents
						}
						else
						{
							result = 4 + 16; // a2 before b2, a2 contains b2
						}
					}
				}
				else
				{
					if (b2.nodeType === 9)
					{
						if (b2 !== a2.ownerDocument)
						{
							return 1; // different documents
						}
						else
						{
							result = 2 + 8; // b2 before a2, b2 contains a2
						}
					}
					else
					{
						if (a2.ownerDocument !== b2.ownerDocument)
						{
							return 1; // different documents
						}
						else
						{
							// do a contains comparison for element nodes
							if (!a2.contains || typeof a2.sourceIndex === 'undefined' || !b2.contains || typeof b2.sourceIndex === 'undefined')
							{
								throw new Error('Cannot compare elements. Neither "compareDocumentPosition" nor "contains" available.');
							}
							else
							{
								result = 
									(a2 != b2 && a2.contains(b2) && 16) +
									(a2 != b2 && b2.contains(a2) && 8) +
									(a2.sourceIndex >= 0 && b2.sourceIndex >= 0
										? (a2.sourceIndex < b2.sourceIndex && 4) + (a2.sourceIndex > b2.sourceIndex && 2)
										: 1 ) +
									0 ;
							}
						}
					}
				}
				
				if (a === a2 && b === b2)
				{
					return result;
				}
				else if (a === a2)
				{
					return compareOriginalVsComparableNode(a, a2, b, b2, result, 16, 8, 4, 2);
				}
				else if (b === b2)
				{
					return compareOriginalVsComparableNode(b, b2, a, a2, result, 8, 16, 2, 4);
				}
				else
				{
					// if a2 contains b2
					if ((result & 16) === 16)
					{
						// since a and b are attributes, a has to come before b
						return 4;
					}
					// else if b2 contains a2
					else if ((result & 8) === 8)
					{
						// since a and b are attributes, b has to come before a
						return 2;
					}
					// else if a2 === b2
					else if (result === 0)
					{
						// since a and b are attributes, and both have the same parent
						// find out which attribute comes first
						
						// return "a pre b" or "b pre a" depending on a or b occurs first in a2.childNodes
						for(i=0; i<a2.attributes.length; i++)
						{
							item = a2.attributes[i];
							if (!item.specified) continue;
							
							if (item === b)
							{
								return 2;
							}
							else if (item === a)
							{
								return 4;
							}
						}
						
						throw new Error('Internal Error: compareDocumentPosition failed to sort attributes.');
					}	
					// else
					else
					{
						// return result
						return result;
					}
				}
				
				//throw new Error('Internal Error: compareDocumentPosition failed to sort nodes.');
			},
			
			nodeSupported = function(contextNode)
			{
				if (!contextNode) {
					throw createError(9, 'NOT_SUPPORTED_ERR', 'Context node was not supplied.');
				}
				else if (
						contextNode.nodeType != 9 && // Document
						contextNode.nodeType != 1 && // Element
						contextNode.nodeType != 2 && // Attribute
						contextNode.nodeType != 3 && // Text
						contextNode.nodeType != 4 && // CDATASection
						contextNode.nodeType != 8 && // Comment
						contextNode.nodeType != 7 && // ProcessingInstruction
						contextNode.nodeType != 13   // XPathNamespace
				) {
					throw createError(9, 'NOT_SUPPORTED_ERR', 'The supplied node type is not supported. (nodeType: ' + contextNode.nodeType + ')');
				}
				else if (contextNode.nodeType == 2 && !contextNode.specified)
				{
					throw createError(9, 'NOT_SUPPORTED_ERR', 'The supplied node is a non-specified attribute node. Only specified attribute nodes are supported.');
				}
			},
			
			createNamespaceNode = function(prefix, ns, parent)
			{
				var i, namespaceNode;
				
				for(i = 0; i < namespaceCache.length; i++)
				{
					namespaceNode = namespaceCache[i];
					
					if (namespaceNode.prefix === prefix &&
						namespaceNode.nodeValue === ns &&
						namespaceNode.ownerElement === parent)
					{
						// we have already created this namespace node, so use this one
						return namespaceNode;
					}
				}
				
				// no such node created in the past, so create it now
				namespaceNode = new XPathNamespace(prefix, ns, parent);
				
				// add node to cache
				namespaceCache.push(namespaceNode);
				
				return namespaceNode;
			}
		;
		
		BaseType = function(value, type, supports)
		{
			this.value = value;
			this.type = type;
			this.supports = supports;
		};
		
		BaseType.prototype = {
			value: null,
			type: null,
			supports: [],
			
			toBoolean: function() {
				throw new Error('Unable to convert "' + this.type + '" to "boolean".');
			},
			
			toString: function() {
				throw new Error('Unable to convert "' + this.type + '" to "string".');
			},
			
			toNumber: function() {
				throw new Error('Unable to convert "' + this.type + '" to "number".');
			},
			
			toNodeSet: function() {
				throw new Error('Unable to convert "' + this.type + '" to "node-set".');
			},

			toDate: function() {
				throw new Error('Unable to convert "' + this.type + '" to "date".');
			},
			
			/**
			 * Check if this type can be converted to a particular javascript type.
			 */
			canConvertTo: function(type)
			{
				return false !== arrayIndexOf(type, this.supports);
			}
		};
		
		BooleanType = function(value)
		{
			BaseType.call(this, value, 'boolean', [
				'boolean',
				'string',
				'number',
				'date'
			]);
		};
		BooleanType.prototype = new BaseType;
		BooleanType.constructor = BooleanType;
		BooleanType.prototype.toBoolean = function() {
			return this.value;
		};
		/**
		 * The boolean false value is converted to the string false. The boolean true value is converted to the string true.
		 */
		BooleanType.prototype.toString = function() {
			return (this.value === true) ? 'true' : 'false';
		};
		/**
		 * boolean true is converted to 1; boolean false is converted to 0
		 */
		BooleanType.prototype.toNumber = function() {
			return (this.value) ? 1 : 0;
		};
		BooleanType.prototype.toDate = function(){
			return null;
		};
		
		NodeSetType = function(value, documentOrder)
		{
			BaseType.call(this, value, 'node-set', [
				'boolean',
				'string',
				'number',
				'node-set',
				'date'
			]);
			
			this.docOrder = (documentOrder || 'unsorted');
		};
		NodeSetType.prototype = new BaseType;
		NodeSetType.constructor = NodeSetType;
		/**
		 * a node-set is true if and only if it is non-empty
		 */
		NodeSetType.prototype.toBoolean = function() {
			return (this.value.length > 0) ? true : false;
		};
		/**
		 * A node-set is converted to a string by returning the string-value of the node
		 * in the node-set that is first in document order. If the node-set
		 * is empty, an empty string is returned.
		 */
		NodeSetType.prototype.toString = function() {
			if (this.value.length < 1)
			{
				return '';
			}
			
			this.sortDocumentOrder();
			return nodeStringValue(this.value[0]);
		};
		/**
		 * a node-set is first converted to a string as if by a call to the string
		 * function and then converted in the same way as a string argument
		 */
		NodeSetType.prototype.toNumber = function() {
			return (new StringType(this.toString())).toNumber();
		};
		NodeSetType.prototype.toNodeSet = function() {
			return this.value;
		};
		NodeSetType.prototype.toDate = function(){
			return (new StringType(this.toString())).toDate();
		};
		NodeSetType.prototype.sortDocumentOrder = function() {
			switch(this.docOrder)
			{
				case 'document-order':
					// already sorted
					break;
					
				case 'reverse-document-order':
					// reverse the order
					this.value.reverse();
					break;
					
				default:
					this.value.sort(function(a, b) {
						var result = compareDocumentPosition(a, b);
						
						if ( (result & 4) == 4 ) // a before b
						{
							return -1;
						}
						else if ( (result & 2) == 2 ) // b before a
						{
							return 1;
						}
						else
						{
							throw new Error('NodeSetType.sortDocumentOrder - unexpected compare result: ' + result);
						}
					});
					break;
			}
			
			this.docOrder = 'document-order';
		};
		NodeSetType.prototype.sortReverseDocumentOrder = function() {
			switch(this.docOrder)
			{
				case 'document-order':
					// reverse the order
					this.value.reverse();
					break;
					
				case 'reverse-document-order':
					// already sorted
					break;
					
				default:
					this.sortDocumentOrder();
					this.value.reverse();
					break;
			}
			
			this.docOrder = 'reverse-document-order';
		};
		
		NodeSetType.prototype.append = function(nodeset) {
			var i = 0,
				j = 0,
				result
			;
			
			if(!(nodeset instanceof NodeSetType))
			{
				throw new Error('NodeSetType can be passed into NodeSetType.append method');
			}
			
			// use merge sort algorithm
			this.sortDocumentOrder();
			nodeset.sortDocumentOrder();
			
			while(i < this.value.length && j < nodeset.value.length)
			{
				result = compareDocumentPosition(this.value[i], nodeset.value[j]);
				
				if (result == 0) // same nodes
				{
					// ignore duplicates
					j++;
				}
				else if ( (result & 4) == 4 ) // a before b
				{
					i++;
				}
				else if ( (result & 2) == 2 ) // b before a
				{
					this.value.splice(i, 0, nodeset.value[j]);
					i++;
					j++;
				}
				else
				{
					throw new Error('Internal Error: NodeSetType.append - unable to sort nodes. (result: ' + result + ')');
				}
			}
			
			// append remaining elements
			for (;j < nodeset.value.length; j++)
			{
				this.value.push(nodeset.value[j]);
			}
			
			this.docOrder = 'document-order';
		};
		
		NodeSetType.prototype.stringValues = function()
		{
			var i, obj,
				values = []
			;
			
			for(i=0; i < this.value.length; i++)
			{
				//seems like an ugly hack, original commented out below
				obj = new StringType(nodeStringValue(this.value[i]));
				if (obj.isDateString()){
					obj = new DateType(obj.value);
				} 
				values.push(obj);
				//values.push(new StringType(nodeStringValue(this.value[i])));
			}
			
			return values;
		};
		
		StringType = function(value)
		{
			BaseType.call(this, value, 'string', [
				'boolean',
				'string',
				'number',
				'date'
			]);
		};
		StringType.prototype = new BaseType;
		StringType.constructor = StringType;
		/**
		 * a string is true if and only if its length is non-zero
		 */
		StringType.prototype.toBoolean = function() {
			return (this.value.length > 0) ? true : false;
		};
		StringType.prototype.toString = function() {
			return this.value;
		};
		/**
		 * a string that consists of optional whitespace followed by an optional minus sign
		 * followed by a Number followed by whitespace is converted to the IEEE 754 number
		 * that is nearest (according to the IEEE 754 round-to-nearest rule) to the mathematical
		 * value represented by the string; any other string is converted to NaN
		 */
		StringType.prototype.toNumber = function() {
			var result;
			
			if (this.isDateString(this.value)){
				return new DateType(this.value).toNumber();
			}
				
			// Digits ('.' Digits?)?
			result = this.value.match(/^[ \t\r\n]*(-?[0-9]+(?:[.][0-9]*)?)[ \t\r\n]*$/);
			if (result !== null)
			{
				return parseFloat(result[1]);
			}
			
			// '.' Digits
			result = this.value.match(/^[ \t\r\n]*(-?[.][0-9]+)[ \t\r\n]*$/);
			if (result !== null)
			{
				return parseFloat(result[1]);
			}
			
			// Invalid number
			return Number.NaN;
		};
		StringType.prototype.toDate = function() {
			return new DateType(this.value).toDate();
		};
		/**
		 * Test whether the value of a String is (probably a date string)
		 * It seems like a bit of a hack (and inefficient because it is called for all strings)
		 * but not sure how else to do this.
		 * Note that "'4'" and '"4'" can be parse as valid dates.
		 * 
		 * @return {Boolean} 
		 */
		StringType.prototype.isDateString = function(){	
			// if it is a number
			if (!isNaN(this.value)){
				return false;
			}
			// if JavaScript cannot parse the value to a date
			if (isNaN(Date.parse(this.value))){
				return false;
			}
			// if it does not conform to this crude regex 
			// (required on old versions of Android webview that parse weird strings such as "opv_3" to a valid date...)
			// it is just a bug fix we can remove around 2018 probably
			if (!/('|")?[0-9]{4}(-|\/)[0-9]{2}(-|\/)[0-9]{2}('|")?/.test(this.value)){
				return false;
			}
			return true;
		};
		
		NumberType = function(value)
		{
			BaseType.call(this, value, 'number', [
				'boolean',
				'string',
				'number',
				'date'
			]);
		};
		NumberType.prototype = new BaseType;
		NumberType.constructor = NumberType;
		/**
		 * a number is true if and only if it is neither positive or negative zero nor NaN
		 */
		NumberType.prototype.toBoolean = function() {
			return (this.value !== 0 && !isNaN(this.value)) ? true : false;
		};
		/**
		 * A number is converted to a string as follows:
		 *     NaN is converted to the string NaN
		 *     positive zero is converted to the string 0
		 *     negative zero is converted to the string 0
		 *     positive infinity is converted to the string Infinity
		 *     negative infinity is converted to the string -Infinity
		 *     if the number is an integer, the number is represented in decimal form as a Number with no decimal point
		 *     and no leading zeros, preceded by a minus sign (-) if the number is negative ...
		 *     otherwise, the number is represented in decimal form as a Number
		 */
		NumberType.prototype.toString = function() {
			return this.value.toString();
		};
		NumberType.prototype.toNumber = function() {
			return this.value;
		};
		/**
		 * This is where JavaRosa's date object deviates from the built-in 
		 * javascript Date object. It instantiates a date based on the amount of days since the 
		 * epoch (and not milliseconds)
		 * 
		 */
		NumberType.prototype.toDate = function() {
			return new Date(this.value * (1000 * 60 * 60 * 24) );
		};
		/** 
		 * Date type used in JavaRosa functions 
		 **/
		DateType = function(value)
		{
			/*
			 * For dates that are missing time zone information, like '2012-02-03' we can go into different directions here.
			 * 1. We could assume GMT time.
			 * 2. We could assume local time.
			 * Since a date widget would return the format '2012-02-03' and we'd like the constraint ". < today()" to work,
			 * we have to choose option 2.
			 * Note: the timezone offset has to be obtained from the actual date in order to account for DST!
			 */
			if (/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(value)) {
				value += 'T00:00:00.000' + (new Date(value)).getTimezoneOffsetAsTime();
			} 

			BaseType.call(this, value, 'date', [
				'date',
				'string',
				'number',
				'boolean'
			]);
		};

		DateType.prototype = new BaseType;
		DateType.constructor = DateType;

		DateType.prototype.toDate = function() {
			return new Date(this.value);
		};
		//maybe the string should be build 'manually' with milliseconds appended to it
		//more in line with JavaRosa
		DateType.prototype.toString = function(){
			return new Date(this.value).toISOLocalString();
		};
		// Gets days since epoch
		DateType.prototype.toNumber = function(){
			return ( new Date(this.value).getTime() ) / (1000 * 60 * 60 * 24) ;
		};

		DateType.prototype.toBoolean = function(){
			return (!isNaN(new Date(this.value).getTime()));
		};
		
		/**
		 * A new exception has been created for exceptions specific to these XPath interfaces.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathException
		 * 
		 */
		XPathException = function(code, message)
		{
			var err;
			
			/**
			 * @type {number}
			 */
			this.code = code;
			
			switch(this.code)
			{
				case XPathException.INVALID_EXPRESSION_ERR:
					this.name = 'INVALID_EXPRESSION_ERR';
					break;
					
				case XPathException.TYPE_ERR:
					this.name = 'TYPE_ERR';
					break;
				
				default:
					err = new Error('Unsupported XPathException code: ' + this.code);
					err.name = 'XPathExceptionInternalError';
					throw err;
			}
			
			this.message = (message || '');
		};
		
		XPathException.prototype.toString = function() {
			return 'XPathException: "' + this.message + '"'
				+ ', code: "' + this.code + '"'
				+ ', name: "' + this.name + '"'
			;
		};
		
		/**
		 * If the expression has a syntax error or otherwise is not a legal expression
		 * according to the rules of the specific XPathEvaluator or contains specialized
		 * extension functions or variables not supported by this implementation.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#INVALID_EXPRESSION_ERR
		 */
		XPathException.INVALID_EXPRESSION_ERR = 51;
		
		/**
		 * If the expression cannot be converted to return the specified type.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#TYPE_ERR
		 */
		XPathException.TYPE_ERR = 52;
		
		/**
		 * The evaluation of XPath expressions is provided by XPathEvaluator. In a DOM
		 * implementation which supports the XPath 3.0 feature, as described above,
		 * the XPathEvaluator interface will be implemented on the same object which
		 * implements the Document interface permitting it to be obtained by the usual
		 * binding-specific method such as casting or by using the DOM Level 3
		 * getInterface method. In this case the implementation obtained from the Document
		 * supports the XPath DOM module and is compatible with the XPath 1.0 specification.
		 *
		 * Evaluation of expressions with specialized extension functions or variables
		 * may not work in all implementations and is, therefore, not portable.
		 * XPathEvaluator implementations may be available from other sources that
		 * could provide specific support for specialized extension functions or variables
		 * as would be defined by other specifications.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator
		 */
		XPathEvaluator = function(options)
		{
			var option, defaultOption, found;
			
			for (option in options)
			{
				found = false;
				for(defaultOption in this.opts)
				{
					if (option === defaultOption)
					{
						this.opts[option] = options[option];
						found = true;
						break;
					}
				}
				if (found)
					continue;
				
				throw new Error('Unsupported option: ' + option);
			}
			
			// define unique ids
			this.opts['unique-ids'][NAMESPACE_URI_XML] = 'id';
			this.opts['unique-ids'][NAMESPACE_URI_XHTML] = 'id';
		};
		XPathEvaluator.prototype = {
			opts: {
				/**
				 * List of unique ID for each namespace
				 *
				 * @see http://www.w3.org/TR/xpath/#unique-id
				 */
				'unique-ids': {},
				
				/**
				 * Specifies whether node name tests should be case sensitive
				 */
				'case-sensitive': false
			},
			
			/**
			 * Creates a parsed XPath expression with resolved namespaces. This is
			 * useful when an expression will be reused in an application since it
			 * makes it possible to compile the expression string into a more efficient
			 * internal form and preresolve all namespace prefixes which occur within
			 * the expression.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createExpression
			 * @param {string} expression The XPath expression string to be parsed.
			 * @param {XPathNSResolver} resolver The resolver permits translation of all prefixes,
			 *        including the xml namespace prefix, within the XPath expression into
			 *        appropriate namespace URIs. If this is specified as null, any namespace
			 *        prefix within the expression will result in DOMException being thrown
			 *        with the code NAMESPACE_ERR.
			 * @return {XPathExpression} The compiled form of the XPath expression.
			 * @exception {XPathException} INVALID_EXPRESSION_ERR: Raised if the expression is not
			 *        legal according to the rules of the XPathEvaluator.
			 * @exception {DOMException} NAMESPACE_ERR: Raised if the expression contains namespace
			 *        prefixes which cannot be resolved by the specified XPathNSResolver.
			 */
			createExpression: function(expression, resolver)
			{
				var tree,
					message,
					i,
					nsMapping = {},
					prefix
				;
				
				// Parse the expression
				try {
					tree = parser.parse(expression);
				} catch(err) {
					message = 'The expression is not a legal expression.';
					if (err instanceof parser.SyntaxError)
					{
						message += ' (line: ' + err.line + ', character: ' + err.column + ')';
					}
					else
					{
						// this shouldn't happen, but it's here just in case
						message += ' (' + err.message + ')';
					}
					throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, message);
				}
				
				// Resolve namespaces if any
				if (tree.nsPrefixes.length > 0)
				{
					// ensure resolver supports lookupNamespaceURI function
					if (typeof resolver != 'object' ||
						typeof resolver.lookupNamespaceURI === 'undefined')
					{
						throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
							'No namespace resolver provided or lookupNamespaceURI function not supported.'
						);
					}
					
					for(i=0; i < tree.nsPrefixes.length; i++)
					{
						prefix = tree.nsPrefixes[i];
						nsMapping[prefix] = resolver.lookupNamespaceURI(prefix);
						
						if (nsMapping[prefix] === null)
						{
							throw createError(14, 'NAMESPACE_ERR', 'Undefined namespace prefix "' + prefix + '" in the context of the given resolver.');
						}
					}
				}
				
				return new XPathExpression(tree, nsMapping, this.opts);
			}
			
			/**
			 * Adapts any DOM node to resolve namespaces so that an XPath expression
			 * can be easily evaluated relative to the context of the node where it
			 * appeared within the document. This adapter works like the DOM Level 3
			 * method lookupNamespaceURI on nodes in resolving the namespaceURI from a
			 * given prefix using the current information available in the node's
			 * hierarchy at the time lookupNamespaceURI is called. also correctly
			 * resolving the implicit xml prefix.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createNSResolver
			 * @param {Node} nodeResolver The node to be used as a context for namespace resolution.
			 * @return {XPathNSResolver} Resolves namespaces with respect to the definitions in scope for a specified node.
			 */
			,createNSResolver: function(nodeResolver)
			{
				return new XPathNSResolver(nodeResolver);
			}
			
			/**
			 * Evaluates an XPath expression string and returns a result of the specified type if possible.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-evaluate
			 * @param {string} expression The XPath expression string to be parsed and evaluated.
			 * @param {Node} contextNode The context is context node for the evaluation of this XPath expression.
			 *        If the XPathEvaluator was obtained by casting the Document then this must
			 *        be owned by the same document and must be a Document, Element, Attribute,
			 *        Text, CDATASection, Comment, ProcessingInstruction, or XPathNamespace node.
			 *        If the context node is a Text or a CDATASection, then the context is
			 *        interpreted as the whole logical text node as seen by XPath, unless the node
			 *        is empty in which case it may not serve as the XPath context.
			 * @param {XPathNSResolver} resolver The resolver permits translation of all prefixes, including the
			 *        xml namespace prefix, within the XPath expression into appropriate namespace
			 *        URIs. If this is specified as null, any namespace prefix within the
			 *        expression will result in DOMException being thrown with the code NAMESPACE_ERR.
			 * @param {number} type If a specific type is specified, then the result will be returned as the corresponding type.
			 *        For XPath 1.0 results, this must be one of the codes of the XPathResult interface.
			 * @param {XPathResult} result The result specifies a specific result object which may be reused and
			 *        returned by this method. If this is specified as nullor the implementation does
			 *        not reuse the specified result, a new result object will be constructed and returned.
			 * @return {XPathResult} The result of the evaluation of the XPath expression.
			 * @exception {XPathException} INVALID_EXPRESSION_ERR: Raised if the expression is not
			 *        legal according to the rules of the XPathEvaluator.
			 *        TYPE_ERR: Raised if the result cannot be converted to return the specified type.
			 * @exception {Error} NAMESPACE_ERR: Raised if the expression contains namespace prefixes
			 *        which cannot be resolved by the specified XPathNSResolver.
			 *        WRONG_DOCUMENT_ERR: The Node is from a document that is not supported by this XPathEvaluator.
			 *        NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath context node or the request
			 *        type is not permitted by this XPathEvaluator.
			 */
			,evaluate: function(expression, contextNode, resolver, type, result)
			{
				// create expression
				expression = this.createExpression(expression, resolver);
				
				// evaluate expression
				return expression.evaluate(contextNode, type, result);
			}
		};
		
		/**
		 * The XPathExpression interface represents a parsed and resolved XPath expression.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathExpression
		 */
		XPathExpression = function(parsedExpression, namespaceMapping, options) {
			this.parsedExpression = parsedExpression;
			this.namespaceMapping = namespaceMapping;
			this.opts = options || {};
		};
		
		XPathExpression.prototype = {
			/**
			 * Parsed expression tree
			 *
			 * @type {Object}
			 */
			parsedExpression: null,
			
			/**
			 * Mapping of prefixes to namespaces
			 *
			 * @type {Object}
			 */
			namespaceMapping: null,
			
			/**
			 * Options used to tweak expression evaluation
			 *
			 * @type {Object}
			 */
			opts: {},
			
			/**
			 * Evaluates this XPath expression and returns a result.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathExpression-evaluate
			 * @param {Node} contextNode The context is context node for the evaluation of this XPath expression.
			 *        If the XPathEvaluator was obtained by casting the Document then this must
			 *        be owned by the same document and must be a Document, Element, Attribute,
			 *        Text, CDATASection, Comment, ProcessingInstruction, or XPathNamespace node.
			 *        If the context node is a Text or a CDATASection, then the context is
			 *        interpreted as the whole logical text node as seen by XPath, unless the node
			 *        is empty in which case it may not serve as the XPath context.
			 * @param {number} type If a specific type is specified, then the result will be
			 *        coerced to return the specified type relying on XPath conversions and
			 *        fail if the desired coercion is not possible. This must be one of the
			 *        type codes of XPathResult.
			 * @param {XPathResult} result The result specifies a specific result object which may be reused and
			 *        returned by this method. If this is specified as nullor the implementation does
			 *        not reuse the specified result, a new result object will be constructed and returned.
			 * @return {XPathResult} The result of the evaluation of the XPath expression.
			 * @exception {XPathException} TYPE_ERR: Raised if the result cannot be converted to return the specified type.
			 * @exception {Error} WRONG_DOCUMENT_ERR: The Node is from a document that is not supported by this XPathEvaluator.
			 *        NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath context node or the request
			 *        type is not permitted by this XPathEvaluator.
			 */
			evaluate: function(contextNode, type /*, result*/)
			{
				var context;
				
				// HACK: track current expression being evaluated
				currentExpression = this;
				
				// check if our implementation supports this node type
				nodeSupported(contextNode);
				
				context = new Context(contextNode, 1, 1, {}, functions, this.namespaceMapping, this.opts);
				
				return XPathResult.factory(
					context,
					type,
					evaluateExpressionTree(context, this.parsedExpression.tree)
				);
			}
		};
		
		/**
		 * Expression evaluation occurs with respect to a context.
		 *
		 * @see http://www.w3.org/TR/xpath/#dt-context-node
		 */
		Context = function(node, position, size, vars, functions, namespaceMap, options)
		{
			this.node = node;
			this.pos = position;
			this.size = size;
			this.vars = vars;
			this.fns = functions;
			this.nsMap = namespaceMap;
			this.opts = options || {};
		};
		
		Context.prototype = {
			// a node (the context node)
			node: null,
			
			// a pair of non-zero positive integers (the context position and the context size)
			pos: null,
			size: null,
			
			// a set of variable bindings
			vars: null,
			
			// a function library
			fns: null,
			
			// the set of namespace declarations in scope for the expression
			nsMap: null,
			
			// Options used to tweak expression evaluation
			opts: null,
			
			clone: function(node, position, size)
			{
				return new Context(
					node || this.node,
					(typeof position != 'undefined') ? position : this.pos,
					(typeof size != 'undefined') ? size : this.size,
					this.vars,
					this.fns,
					this.nsMap,
					this.opts
				);
			}
		};
		
		/**
		 * The XPathNSResolver interface permit prefix strings in the expression to be
		 * properly bound to namespaceURI strings. XPathEvaluator can construct an
		 * implementation of XPathNSResolver from a node, or the interface may be
		 * implemented by any application. 
		 *
		 * @see http://www.w3.org/TR/DOM-Lstring-3-XPath/xpath.html#XPathNSResolver
		 */
		XPathNSResolver = function(nodeResolver)
		{
			nodeSupported(nodeResolver);
			this.node = nodeResolver;
		};
		
		XPathNSResolver.prototype = {
			
			/**
			 * Node used as a reference to resolve prefix to a namespace.
			 *
			 * @type {Node}
			 */
			node: null,
			
			/**
			 * Look up the namespace URI associated to the given namespace prefix.
			 * The XPath evaluator must never call this with a null or empty argument,
			 * because the result of doing this is undefined.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathNSResolver-lookupNamespaceURI
			 * @param {string} prefix The prefix to look for.
			 * @return {string} Returns the associated namespace URI or null if none is found.
			 */
			lookupNamespaceURI: function(prefix)
			{
				var node = this.node
					,i
					,namespace
					,tmpNode
				;
				
				switch(prefix)
				{
					case 'xml': // http://www.w3.org/TR/REC-xml-names/#xmlReserved
						return NAMESPACE_URI_XML;
					
					case 'xmlns': // http://www.w3.org/TR/REC-xml-names/#xmlReserved
						return NAMESPACE_URI_XMLNS;
					
					default:
						switch(this.node.nodeType)
						{
							case 9: // Node.DOCUMENT_NODE
								node = node.documentElement;
								break;
								
							case 1: // Node.ELEMENT_NODE
								// leave as is
								break;
								
							default:
								node = nodeParent(node);
								break;
						}
						
						if (node != null && node.nodeType == 1 /*Node.ELEMENT_NODE*/)
						{
							/**
							 * Check the default namespace
							 *
							 * @see http://www.w3.org/TR/xml-names/#defaulting
							 */
							if ('' == prefix)
							{
								namespace = node.getAttribute('xmlns');
								if (namespace  !== null)
								{
									return namespace;
								}

							} else {
								/**
								 * IE puts all namespaces inside document.namespaces for HTML node
								 *
								 * @see http://msdn.microsoft.com/en-us/library/ms537470(VS.85).aspx
								 * @see http://msdn.microsoft.com/en-us/library/ms535854(v=VS.85).aspx
								 */
								if (node.ownerDocument.documentElement === node && typeof node.ownerDocument.namespaces === 'object')
								{
									for(i=0; i<node.ownerDocument.namespaces.length; i++)
									{
										namespace = node.ownerDocument.namespaces.item(i);
										if (namespace.name == prefix)
										{
											return namespace.urn;
										}
									}
								}

								/**
								 * Normal attribute checking for namespace declarations
								 */
								for(i=0; i<node.attributes.length; i++)
								{
									if (!node.attributes[i].specified)
									{
										continue;
									}
									if ('xmlns:' + prefix == node.attributes[i].nodeName)
									{
										return node.attributes[i].nodeValue;
									}
								}
							}
							
							/**
							 * ... resolving the namespaceURI from a given prefix using the
							 * current information available in the node's hierarchy ...
							 *
							 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createNSResolver
							 */
							if (node.ownerDocument.documentElement !== node && node.parentNode)
							{
								// HACK: Maybe replace with a function call and pass in prefix with parentNode
								tmpNode = this.node;
								this.node = node.parentNode;
								namespace = this.lookupNamespaceURI(prefix);
								this.node = tmpNode;
								return namespace;
							}
						}
						return null;
				}
			}
		};
		
		expressions = {
			'/': function(left, right)
			{
				var i,
					nodeset,
					nodeset2,
					resultNodeset,
					newContext
				;
				
				// Evaluate left
				if (left === null)
				{
					// A / by itself selects the root node of the document containing the context node.
					nodeset = new NodeSetType([nodeOwnerDocument(this.node)], 'document-order');
				}
				else
				{
					nodeset = evaluateExpressionTree(this, left);
					
					if (!(nodeset instanceof NodeSetType))
					{
						throw new Error('Left side of path separator (/) must be of node-set type. (type: ' + nodeset.type + ')');
					}
				}
				
				// Evaluate right with respect to left
				if (right === null)
				{
					resultNodeset = nodeset;
				}
				else
				{
					/**
					 * If it is followed by a relative location path, then the location path selects
					 * the set of nodes that would be selected by the relative location path relative
					 * to the root node of the document containing the context node.
					 */
					
					resultNodeset = new NodeSetType([], 'document-order');
					
					for(i=0; i<nodeset.value.length; i++)
					{
						newContext = this.clone(nodeset.value[i]);
						nodeset2 = evaluateExpressionTree(newContext, right);
					
						if (!(nodeset2 instanceof NodeSetType))
						{
							throw new Error('Right side of path separator (/) must be of node-set type. (type: ' + nodeset2.type + ')');
						}
						
						resultNodeset.append(nodeset2);
					}
				}
				
				return resultNodeset;
			},
			
			step: function(axis, nodeTest)
			{
				var nodeset,
					i,
					node,
					nodes,
					qname,
					nodeType,
					expandedName
				;
				
				/*
				 * @ see http://www.w3.org/TR/xpath/#axes
				 */
				switch(axis)
				{
					/*
					 * the child axis contains the children of the context node
					 */
					case 'child':
						nodeset = new NodeSetType(nodeChildren(this.node), 'document-order');
						break;
					
					/*
					 * the descendant axis contains the descendants of the context
					 * node; a descendant is a child or a child of a child and so on;
					 * thus the descendant axis never contains attribute or namespace nodes
					 */
					case 'descendant':
						nodeset = new NodeSetType(nodeDescendant(this.node), 'document-order');
						break;
					
					/*
					 * the parent axis contains the parent of the context node, if there is one
					 */
					case 'parent':
						node = nodeParent(this.node);
						nodeset = new NodeSetType((!node) ? [] : [node], 'document-order');
						break;
					
					/*
					 * the ancestor axis contains the ancestors of the context node; the ancestors
					 * of the context node consist of the parent of context node and the parent's
					 * parent and so on; thus, the ancestor axis will always include the root node,
					 * unless the context node is the root node
					 */
					case 'ancestor':
						nodeset = new NodeSetType(nodeAncestor(this.node), 'reverse-document-order');
						break;
					
					/*
					 * the following-sibling axis contains all the following siblings of the context node;
					 * if the context node is an attribute node or namespace node, the following-sibling axis is empty
					 */
					case 'following-sibling':
						nodeset = new NodeSetType(nodeFollowingSibling(this.node), 'document-order');
						break;
					
					/*
					 * the preceding-sibling axis contains all the preceding siblings of the context node; if the
					 * context node is an attribute node or namespace node, the preceding-sibling axis is empty
					 */
					case 'preceding-sibling':
						nodeset = new NodeSetType(nodePrecedingSibling(this.node), 'reverse-document-order');
						break;
					
					/*
					 * the following axis contains all nodes in the same document as the context node that are after
					 * the context node in document order, excluding any descendants and excluding attribute
					 * nodes and namespace nodes
					 */
					case 'following':
						nodeset = new NodeSetType(nodeFollowing(this.node), 'document-order');
						break;
					
					/*
					 * the preceding axis contains all nodes in the same document as the context node that are before 
					 * the context node in document order, excluding any ancestors and excluding attribute 
					 * nodes and namespace nodes
					 */
					case 'preceding':
						nodeset = new NodeSetType(nodePreceding(this.node), 'reverse-document-order');
						break;
					
					/*
					 * the attribute axis contains the attributes of the context node; the axis will 
					 * be empty unless the context node is an element
					 */
					case 'attribute':
						nodeset = new NodeSetType(nodeAttribute(this.node), 'document-order');
						break;
					
					/*
					 * the namespace axis contains the namespace nodes of the context node; the axis 
					 * will be empty unless the context node is an element
					 */
					case 'namespace':
						nodeset = new NodeSetType(nodeNamespace.call(this, this.node), 'document-order');
						break;
					
					/*
					 * the self axis contains just the context node itself
					 */
					case 'self':
						nodeset = new NodeSetType([this.node], 'document-order');
						break;
					
					/*
					 * the descendant-or-self axis contains the context node and the descendants of the context node
					 */
					case 'descendant-or-self':
						nodes = nodeDescendant(this.node);
						nodes.unshift(this.node);
						nodeset = new NodeSetType(nodes, 'document-order');
						break;
					
					/*
					 * the ancestor-or-self axis contains the context node and the ancestors of the context node; 
					 * thus, the ancestor axis will always include the root node
					 */
					case 'ancestor-or-self':
						nodes = nodeAncestor(this.node);
						nodes.unshift(this.node);
						nodeset = new NodeSetType(nodes, 'reverse-document-order');
						break;
					
					default:
						throw new Error('Axis type not supported: ' + axis);
				}
				
				switch(nodeTest.type)
				{
					case 'nodeType':
						if (nodeTest.args[0] == 'node')
						{
							// leave node as is
							break;
						}
						
						for(i=nodeset.value.length-1; i>=0; i--)
						{
							// TODO-FUTURE: perhaps move the switch outside of the loop
							switch(nodeTest.args[0])
							{
								case 'text':
									if (nodeset.value[i].nodeType != 3 && // text
										nodeset.value[i].nodeType != 4 // cdata
									) {
										nodeset.value.splice(i, 1);
									}
									break;
								
								case 'comment':
									if (nodeset.value[i].nodeType != 8) // comment
									{
										nodeset.value.splice(i, 1);
									}
									break;
								
								case 'processing-instruction':
									if (nodeset.value[i].nodeType != 7 || // processing-instruction
										(nodeTest.args[1].length > 0 &&
											evaluateExpressionTree(this, nodeTest.args[1][0]) != nodeset.value[i].nodeName) // name
									) {
										nodeset.value.splice(i, 1);
									}
									break;
							}
						}
						break;
						
					case 'name':
						qname = evaluateExpressionTree(this, nodeTest);
						
						/**
						 * Every axis has a principal node type. If an axis can contain elements, then the
						 * principal node type is element; otherwise, it is the type of the nodes
						 * that the axis can contain.
						 *
						 * @see http://www.w3.org/TR/xpath/#node-tests
						 */
						switch(axis)
						{
							// For the attribute axis, the principal node type is attribute.
							case 'attribute':
								nodeType = 2;
								break;
							
							// For the namespace axis, the principal node type is namespace.
							case 'namespace':
								nodeType = 13;
								break;
							
							// For other axes, the principal node type is element.
							default:
								nodeType = 1;
								break;
						}
						
						for(i=nodeset.value.length-1; i>=0; i--)
						{
							if (nodeset.value[i].nodeType != nodeType)
							{
								// not of principal node type, so remove node
								nodeset.value.splice(i, 1);
								continue;
							}
							
							// *
							if (qname.ns === null && qname.name === null)
							{
								continue;
							}
							
							// get expanded name
							expandedName = nodeExpandedName.call(this, nodeset.value[i]);
							
							// check namespace
							//alert(expandedName.ns + ' ' + qname.ns + "\r\n" + expandedName.name + ' ' + qname.name);
							if (expandedName === false || expandedName.ns !== qname.ns)
							{
								// namespaces don't match
								nodeset.value.splice(i, 1);
								continue;
							}
							
							// check name
							if (qname.name !== null &&
								// TODO: provide option for case sensitivity
								expandedName.name.toLowerCase() != qname.name.toLowerCase()
							) {
								// names don't match
								nodeset.value.splice(i, 1);
							}
						}
						break;
						
					default:
						throw new Error('NodeTest type not supported in step: ' + nodeTest.type);
				}
				
				return nodeset;
			},
			
			/**
			 * @see http://www.w3.org/TR/xpath/#predicates
			 */
			predicate: function(axis, expr, predicateExprs)
			{
				var nodeset,
					i,
					result,
					j,
					k,
					length
				;
				
				// Evaluate expression
				nodeset = evaluateExpressionTree(this, expr);
				
				// Ensure we get a node-set
				if (!(nodeset instanceof NodeSetType))
				{
					throw new Error('Expected "node-set", got: ' + nodeset.type);
				}
				
				/**
				 * A predicate filters a node-set with respect to an axis to produce a new node-set.
				 */
				switch(axis)
				{
					case 'ancestor':
					case 'ancestor-or-self':
					case 'preceding':
					case 'preceding-sibling':
						nodeset.sortReverseDocumentOrder();
						break;
						
					default:
						nodeset.sortDocumentOrder();
						break;
				}
				
				for (j=0; j<predicateExprs.length; j++)
				{
					/**
					 * For each node in the node-set to be filtered, ...
					 */
					for(i=0,k=1, length=nodeset.value.length; i<nodeset.value.length;k++)
					{
						/**
						 * ... the PredicateExpr is evaluated with that node as the context node, with the
						 * number of nodes in the node-set as the context size, and with the proximity
						 * position of the node in the node-set with respect to the axis as the context
						 * position; if PredicateExpr evaluates to true for that node, the node is
						 * included in the new node-set; otherwise, it is not included.
						 */
						result = evaluateExpressionTree(this.clone(nodeset.value[i], k, length), predicateExprs[j]);
						
						/**
						 * If the result is a number, the result will be converted to true if the number
						 * is equal to the context position and will be converted to false otherwise;
						 */
						if (result instanceof NumberType)
						{
							if (result.value != k)
							{
								nodeset.value.splice(i, 1);
								continue;
							}
						}
						
						/**
						 * if the result is not a number, then the result will be converted as
						 * if by a call to the boolean function.
						 */
						else if (!result.toBoolean())
						{
							nodeset.value.splice(i, 1);
							continue;
						}
						
						i++;
					}
				}

				return nodeset;
			},
			
			/**
			 * @see http://www.w3.org/TR/xpath/#section-Function-Calls
			 */
			'function': function(name, args)
			{
				var qname,
					argVals = [],
					formatName = function(qname)
					{
						return ((qname.ns !== null) ? '{' + qname.ns + '}' : '{}') + qname.name;
					},
					formatFnArgs = function(args)
					{
						var i,
							types = [],
							type
						;
						
						for(i=0; i < args.length; i++)
						{
							type = (args[i].t === undefined) ? 'object' : args[i].t;
							
							if (args[i].r !== false) // required
							{
								if (args[i].rep === true)
								{
									type += '+'; // one or more
								}
							}
							else
							{
								if (args[i].rep === true)
								{
									type += '*'; // zero or more
								}
								else
								{
									type += '?'; // optional
								}
							}
							
							types.push(type);
						}
						
						return '(' + types.join(', ') + ')';
					},
					fnInfo,
					i,
					j = 0,
					argTypes = [],
					val
				;
				
				/**
				 * Does the function exist?
				 * TODO-FUTURE: this should be done during createExpression, not evaluate
				 */
				qname = evaluateExpressionTree(this, name);
				
				if (qname.ns === null)
				{
					// since we cannot use null as key
					qname.ns = '';
				}
				
				if (!this.fns[qname.ns] || !this.fns[qname.ns][qname.name])
				{
					throw new Error('Function "' + formatName(qname) + '" does not exist.');
				}
				
				fnInfo = this.fns[qname.ns][qname.name];
				
				/**
				 * Does the supplied number of arguments match what the function expects?
				 * TODO-FUTURE: this should be done during createExpression, not evaluate
				 */
				if (!fnInfo.args) fnInfo.args = [];

				for(i=0, j=0; i < fnInfo.args.length; j++, i++)
				{
					if (args[j] === undefined)
					{
						// no supplied arg
						if (fnInfo.args[i].r !== false) // required
						{
							// not enough supplied args
							throw new Error('Function "' + formatName(qname) + '" expects ' + formatFnArgs(fnInfo.args) + '.');
						}
					}
					else
					{
						// has supplied arg
						argTypes.push(
							(fnInfo.args[i].t === undefined) ? 'object' : fnInfo.args[i].t
						);
					}
					
					if (fnInfo.args[i].rep === true)
					{
						// repeated args
						for(;j < args.length; j++)
						{
							argTypes.push(
								(fnInfo.args[i].t === undefined) ? 'object' : fnInfo.args[i].t
							);
						}
						break;
					}
				}
				
				if (argTypes.length < args.length)
				{
					// too many supplied args
					throw new Error('Function "' + formatName(qname) + '" expects ' + formatFnArgs(fnInfo.args) + '.');
				}
				
				// Evaluate args
				for(i=0; i<args.length; i++)
				{
					// Evaluate expression
					val = evaluateExpressionTree(this, args[i]);
					
					if (argTypes[i] !== 'object' && !val.canConvertTo(argTypes[i]))
					{
						// TODO-FUTURE: supported arg types should be checked during createExpression
						throw new Error('Function "' + formatName(qname) + '" expects ' + formatFnArgs(fnInfo.args) + '.' +
							'Cannot convert "' + val.type + '" to "' + argTypes[i] +'".' );
					}
					
					argVals.push(val);
				}
				
				var result = fnInfo.fn.apply(this, argVals);
				
				if (!(result instanceof BaseType))
				{
					throw new Error('Function "' + formatName(qname) + '" did not return a value that inherits from BaseType.');
				}
				else if (fnInfo.ret !== 'object' && !result.canConvertTo(fnInfo.ret))
				{
					throw new Error('Function "' + formatName(qname) + '" return "' + result.type + '" type that cannot be converted to "' + fnInfo.ret + '".');
				}
				
				return result;
			},
			
			'|': function(left, right)
			{
				left = evaluateExpressionTree(this, left);
				right = evaluateExpressionTree(this, right);
				
				if (typeof left == 'undefined' ||
					typeof right == 'undefined' ||
					!(left instanceof NodeSetType) ||
					!(right instanceof NodeSetType))
				{
					throw new Error('Unable to perform union on non-"node-set" types.');
				}
				
				left.append(right);
				return left;
			},
			
			/**
			 * An or expression is evaluated by evaluating each operand and converting its value to a boolean
			 * as if by a call to the boolean function. The result is true if either value is true and
			 * false otherwise. The right operand is not evaluated if the left operand evaluates to true.
			 *
			 * @see http://www.w3.org/TR/xpath/#booleans
			 * @return {BooleanType}
			 */
			or: function(left, right)
			{
				if (evaluateExpressionTree(this, left).toBoolean())
				{
					return new BooleanType(true);
				}
				
				return new BooleanType(evaluateExpressionTree(this, right).toBoolean());
			},
			
			/**
			 * An and expression is evaluated by evaluating each operand and converting its value to a boolean
			 * as if by a call to the boolean function. The result is true if both values are true and
			 * false otherwise. The right operand is not evaluated if the left operand evaluates to false.
			 *
			 * @see http://www.w3.org/TR/xpath/#booleans
			 * @return {BooleanType}
			 */
			and: function(left, right)
			{
				if (evaluateExpressionTree(this, left).toBoolean())
				{
					return new BooleanType(evaluateExpressionTree(this, right).toBoolean());
				}
				
				return new BooleanType(false);
			},
			
			'=': function(left, right)
			{
				return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '=', function(left, right) {
					return left == right;
				});
			},
			
			'!=': function(left, right)
			{
				return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '!=', function(left, right) {
					return left != right;
				});
			},
			
			'<=': function(left, right)
			{
				return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '<=', function(left, right) {
					return left <= right;
				});
			},
			
			'<': function(left, right)
			{
				return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '<', function(left, right) {
					return left < right;
				});
			},
			
			'>=': function(left, right)
			{
				return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '>=', function(left, right) {
					return left >= right;
				});
			},
			
			'>': function(left, right)
			{
				return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '>', function(left, right) {
					return left > right;
				});
			},
			
			'+': function(left, right)
			{
				return new NumberType(
					evaluateExpressionTree(this, left).toNumber()
					+
					evaluateExpressionTree(this, right).toNumber()
				);
			},
			
			'-': function(left, right)
			{
				return new NumberType(
					evaluateExpressionTree(this, left).toNumber()
					-
					evaluateExpressionTree(this, right).toNumber()
				);
			},
			
			div: function(left, right)
			{
				return new NumberType(
					evaluateExpressionTree(this, left).toNumber()
					/
					evaluateExpressionTree(this, right).toNumber()
				);
			},
			
			mod: function(left, right)
			{
				return new NumberType(
					evaluateExpressionTree(this, left).toNumber()
					%
					evaluateExpressionTree(this, right).toNumber()
				);
			},
			
			'*': function(left, right)
			{
				return new NumberType(
					evaluateExpressionTree(this, left).toNumber()
					*
					evaluateExpressionTree(this, right).toNumber()
				);
			},
			
			/**
			 * @param {String} string
			 * @return {String}
			 */
			string: function(string)
			{
				return new StringType(string);
			},
			
			/**
			 * @param {Number} number
			 * @return {Number}
			 */
			number: function(number)
			{
				return new NumberType(number);
			},
			
			'$': function(/*name*/)
			{
				throw new Error('TODO: Not implemented.16');
			},
			
			/**
			 * @param {String} ns
			 * @param {String} name
			 * @return {Object}
			 */
			name: function(prefix, name)
			{
				var ns = null;
				
				if (prefix !== null)
				{
					ns = this.nsMap[prefix];
					if (!ns)
					{
						throw new Error('Namespace prefix "' + prefix + '" is not mapped to a namespace.');
					}
				}
				
				return {
					ns: ns,
					name: name
				};
			}
		};
		
		functions = {
			/**
			 * Core Function Library
			 *
			 * This section describes functions that XPath implementations must always include in the function library that is used to evaluate expressions.
			 * Each function in the function library is specified using a function prototype, which gives the return type, the name of the function, and the type of the arguments. If an argument type is followed by a question mark, then the argument is optional; otherwise, the argument is required.
			 */
			'' : {
				// Node Set Functions
				
				last: {
					/**
					 * The last function returns a number equal to the context size from the expression evaluation context.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-last
					 * @return {NumberType}
					 */
					fn: function()
					{
						return new NumberType(this.size);
					},
					
					ret: 'number'
				},
				
	//			position: {
	//				/**
	//				 * The position function returns a number equal to the context position from the expression evaluation context.
	//				 *
	//				 * @see http://www.w3.org/TR/xpath/#function-position
	//				 * @return {NumberType}
	//				 */
	//				fn: function()
	//				{
	//					return new NumberType(this.pos);
	//				},
	//				
	//				ret: 'number'
	//			},
				
				count: {
					/**
					 * The count function returns the number of nodes in the argument node-set.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-count
					 * @param {NodeSetType} nodeset
					 * @return {NumberType}
					 */
					fn: function(nodeset)
					{
						return new NumberType(nodeset.toNodeSet().length);
					},
					
					args: [
						{t: 'node-set'}
					],
					
					ret: 'number'
				},
				
				id: {
					/**
					 * The id function selects elements by their unique ID.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-id
					 * @param {BaseType} object
					 * @return {NodeSetType}
					 */
					fn: function(object)
					{
						var context = this,
							ids = [],
							i,
							j,
							node,
							nodes = [],
							splitStringByWhitespace = function(str)
							{
								var i,
									// split string by whitespace (#x20 | #x9 | #xD | #xA)+
									chunks = str.split(/[\u0020\u0009\u000D\u000A]+/)
								;
								
								for(i = chunks.length - 1; i >= 0; i--)
								{
									// trim left/right
									if (chunks[i].length == 0)
									{
										chunks.splice(i, 1);
									}
								}
								
								return chunks;
							}
						;
						
						if (object instanceof NodeSetType)
						{
							/**
							 * When the argument to id is of type node-set, then the result is the
							 * union of the result of applying id to the string-value of
							 * each of the nodes in the argument node-set.
							 */
							for(i=0; i<object.value.length; i++)
							{
								ids.push.apply(ids, splitStringByWhitespace(nodeStringValue(object.value[i])));
							}
						}
						else
						{
							/**
							 * When the argument to id is of any other type, the argument is
							 * converted to a string as if by a call to the string function
							 */
							object = object.toString();
							
							/**
							 * the string is split into a whitespace-separated list of tokens
							 */
							
							// split string by whitespace (#x20 | #x9 | #xD | #xA)+
							ids = splitStringByWhitespace(object);
						}
						
						// remove duplicate ids
						for(i=ids.length-1; i>=0; i--)
						{
							for(j=i-1; j >= 0; j--)
							{
								if (ids[i] == ids[j] && i != j)
								{
									ids.splice(i, 1);
									break;
								}
							}
						}
						
						/**
						 * the result is a node-set containing the elements in the same document
						 * as the context node that have a unique ID equal to any of the tokens in the list.
						 *
						 * An element node may have a unique identifier (ID). This is the value of the
						 * attribute that is declared in the DTD as type ID.
						 */
						for(i=0; i<ids.length; i++)
						{
							node = nodeOwnerDocument(this.node).getElementById(ids[i]);
							
							if (node)
							{
								// ensure that this node does indeed have a valid id attibute in namespace scope
								if (nodeIdAttribute.call(this, node))
								{
									nodes.push(node);
									continue;
								}
							}
							
							// node not found by id, need to search manually
							nodeAttributeSearch(nodeOwnerDocument(this.node), true, function(element, attribute) {
								
								var idAttribute = nodeIdAttribute.call(context, element, attribute);
								
								if (idAttribute && idAttribute.nodeValue == ids[i])
								{
									nodes.push(element);
									return true;
								}
							});
						}
						
						return new NodeSetType(nodes);
					},
					
					args: [
						{}
					],
					
					ret: 'node-set'
				},
				
				'local-name': {
					/**
					 * The local-name function returns the local part of the expanded-name
					 * of the node in the argument node-set that is first in document order.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-local-name
					 * @param {NodeSetType} nodeset
					 * @return {StringType}
					 */
					fn: function(nodeset)
					{
						var qname,
							localName = ''
						;
						
						/**
						 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
						 */
						if (arguments.length == 0)
						{
							nodeset = new NodeSetType([this.node]);
						}
						
						/**
						 * If the argument node-set is empty or the first node has no expanded-name, an empty string is returned.
						 */
						if (nodeset.toNodeSet().length > 0)
						{
							nodeset.sortDocumentOrder();
							qname = nodeExpandedName.call(this, nodeset.value[0]);
							
							if (qname !== false)
							{
								localName = qname.name;
							}
						}
						
						return new StringType(localName);
					},
					
					args: [
						{t: 'node-set', r: false}
					],
					
					ret: 'string'
				},
				
				'namespace-uri': {
					/**
					 * The namespace-uri function returns the namespace URI of the expanded-name
					 * of the node in the argument node-set that is first in document order.
					 *
					 * The string returned by the namespace-uri function will be empty
					 * except for element nodes and attribute nodes.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-namespace-uri
					 * @param {NodeSetType} nodeset
					 * @return {StringType}
					 */
					fn: function(nodeset)
					{
						var qname,
							namespaceURI = ''
						;
						
						/**
						 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
						 */
						if (arguments.length == 0)
						{
							nodeset = new NodeSetType([this.node]);
						}
						
						/**
						 * If the argument node-set is empty, the first node has no expanded-name,
						 * or the namespace URI of the expanded-name is null, an empty string is returned.
						 */
						if (nodeset.toNodeSet().length > 0)
						{
							nodeset.sortDocumentOrder();
							qname = nodeExpandedName.call(this, nodeset.value[0]);
							
							if (qname !== false && qname.ns !== null)
							{
								namespaceURI = qname.ns;
							}
						}
						
						return new StringType(namespaceURI);
					},
					
					args: [
						{t: 'node-set', r: false}
					],
					
					ret: 'string'
				},
				
				name: {
					/**
					 * The name function returns a string containing a QName representing the expanded-name
					 * of the node in the argument node-set that is first in document order.
					 *
					 * The string returned by the name function will be the same as the string returned
					 * by the local-name function except for element nodes and attribute nodes.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-name
					 * @param {NodeSetType} nodeset
					 * @param {StringType}
					 */
					fn: function(nodeset)
					{
						var qname,
							name = ''
						;
						
						/**
						 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
						 */
						if (arguments.length == 0)
						{
							nodeset = new NodeSetType([this.node]);
						}
						
						if (nodeset.toNodeSet().length > 0)
						{
							nodeset.sortDocumentOrder();
							qname = nodeExpandedName.call(this, nodeset.value[0]);
							
							if (qname !== false)
							{
								name = (qname.prefix && qname.prefix.length > 0)
									? qname.prefix + ':' + qname.name
									: qname.name
								;
							}
						}
						
						return new StringType(name);
					},
					
					args: [
						{t: 'node-set', r: false}
					],
					
					ret: 'string'
				},
				
				// String functions
				
				string: {
					/**
					 * The string function converts an object to a string.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-string
					 * @param {BaseType} object
					 * @return {StringType}
					 */
					fn: function(object)
					{
						/**
						 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
						 */
						if (arguments.length == 0)
						{
							object = new NodeSetType([this.node], 'document-order');
						}
						
						return new StringType(object.toString());
					},
					
					args: [
						{t: 'object', r: false}
					],
					
					ret: 'string'
				},
				
				//native concat() was replaced with a javarosa-style concat() without breaking the native functionality
				//concat: {
				//	/**
				//	 * The concat function returns the concatenation of its arguments.
				//	 *
				//	 * @see http://www.w3.org/TR/xpath/#function-concat
				//	 * @param {StringType} str1
				//	 * @param {StringType} str2
				//	 * @return {StringType}
				//	 */
				//	fn: function(str1, str2 /*, str3 ... */)
				//	{
				//		var i,
				//			value = ''
				//		;
				//		
				//		for(i=0; i < arguments.length; i++)
				//		{
				//			value += arguments[i].toString();
				//		}
				//		
				//		return new StringType(value);
				//	},
				//	
				//	args: [
				//		{t: 'string'},
				//		{t: 'string'},
				//		{t: 'string', r: false, rep: true}
				//	],
				//	
				//	ret: 'string'
				//},
				
				'starts-with': {
					/**
					 * The starts-with function returns true if the first argument string
					 * starts with the second argument string, and otherwise returns false.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-starts-with
					 * @param {StringType} haystack
					 * @param {StringType} needle
					 * @return {StringType}
					 */
					fn: function(haystack, needle)
					{
						return new BooleanType(haystack.toString().substr(0, (needle = needle.toString()).length) == needle);
					},
					
					args: [
						{t: 'string'},
						{t: 'string'}
					],
					
					ret: 'string'
				},
				
				contains: {
					/**
					 * The contains function returns true if the first argument string
					 * contains the second argument string, and otherwise returns false.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-contains
					 * @param {StringType} haystack
					 * @param {StringType} needle
					 * @return {StringType}
					 */
					fn: function(haystack, needle)
					{
						return new BooleanType(haystack.toString().indexOf(needle = needle.toString()) != -1);
					},
					
					args: [
						{t: 'string'},
						{t: 'string'}
					],
					
					ret: 'string'
				},
				
				'substring-before': {
					/**
					 * The substring-before function returns the substring of the first argument
					 * string that precedes the first occurrence of the second argument string
					 * in the first argument string, or the empty string if the first argument
					 * string does not contain the second argument string.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-substring-before
					 * @param {StringType} haystack
					 * @param {StringType} needle
					 * @return {StringType}
					 */
					fn: function(haystack, needle)
					{
						haystack = haystack.toString();
						needle = haystack.indexOf(needle.toString());
						return new StringType(needle == -1 ?  '' : haystack.substr(0, needle));
					},
					
					args: [
						{t: 'string'},
						{t: 'string'}
					],
					
					ret: 'string'
				},
				
				'substring-after': {
					/**
					 * The substring-after function returns the substring of the first argument
					 * string that follows the first occurrence of the second argument string
					 * in the first argument string, or the empty string if the first argument
					 * string does not contain the second argument string.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-substring-after
					 * @param {StringType} haystack
					 * @param {StringType} needle
					 * @return {StringType}
					 */
					fn: function(haystack, needle)
					{
						var pos;
						
						haystack = haystack.toString();
						needle = needle.toString();
						pos = haystack.indexOf(needle);
						
						return new StringType(pos == -1 ?  '' : haystack.substr(pos + needle.length));
					},
					
					args: [
						{t: 'string'},
						{t: 'string'}
					],
					
					ret: 'string'
				},
				
				substring: {
					/**
					 * The substring function returns the substring of the first argument
					 * starting at the position specified in the second argument
					 * with length specified in the third argument.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-substring
					 * @param {StringType} str
					 * @param {NumberType} start
					 * @param {NumberType} length
					 * @return {StringType}
					 */
					fn: function(str, start, length)
					{
						str = str.toString();
						
						start = Math.round(start.toNumber()) - 1;
						
						return new StringType(
							isNaN(start)
								? ''
								: ((arguments.length == 2)
									? str.substring(start < 0 ? 0 : start)
									: str.substring(start < 0 ? 0 : start, start + Math.round(length.toNumber()))
								)
						);
					},
					
					args: [
						{t: 'string'},
						{t: 'number'},
						{t: 'number', r: false}
					],
					
					ret: 'string'
				},
				
				'string-length': {
					/**
					 * The string-length returns the number of characters in the string.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-string-length
					 * @param {StringType} str
					 * @return {NumberType}
					 */
					fn: function(str)
					{
						str = (arguments.length == 0)
							? nodeStringValue(this.node)
							: str.toString()
						;
						return new NumberType(str.length);
					},
					
					args: [
						{t: 'string', r: false}
					],
					
					ret: 'number'
				},
				
				'normalize-space': {
					/**
					 * The normalize-space function returns the argument string with whitespace
					 * normalized by stripping leading and trailing whitespace and replacing
					 * sequences of whitespace characters by a single space.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-normalize-space
					 * @param {StringType} str
					 * @return {StringType}
					 */
					fn: function(str)
					{
						str = (arguments.length == 0)
							? nodeStringValue(this.node)
							: str.toString()
						;
						return new StringType(str.replace(/^[\u0020\u0009\u000D\u000A]+/,'').replace(/[\u0020\u0009\u000D\u000A]+$/,'').replace(/[\u0020\u0009\u000D\u000A]+/g, ' '));
					},
					
					args: [
						{t: 'string', r: false}
					],
					
					ret: 'string'
				},
								
				translate: {
					/**
					 * The translate function returns the first argument string with occurrences
					 * of characters in the second argument string replaced by the character
					 * at the corresponding position in the third argument string.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-normalize-space
					 * @param {StringType} haystack
					 * @param {StringType} search
					 * @param {StringType} replace
					 * @return {StringType}
					 */
					fn: function(haystack, search, replace)
					{
						var result = '',
							i,
							j,
							x
						;
						
						haystack = haystack.toString();
						search = search.toString();
						replace = replace.toString();
						
						for(i = 0; i < haystack.length; i++)
						{
							if ((j = search.indexOf(x = haystack.charAt(i))) == -1 ||
								(x = replace.charAt(j)))
								result += x;
						}
						
						return new StringType(result);
					},
					
					args: [
						{t: 'string'},
						{t: 'string'},
						{t: 'string'}
					],
					
					ret: 'string'
				},
				
				// Boolean Functions
				
				'boolean': {
					/**
					 * The boolean function converts its argument to a boolean.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-boolean
					 * @param {BaseType}
					 * @return {BooleanType} 
					 */
					fn: function(object)
					{
						return new BooleanType(object.toBoolean());
					},
					
					args: [
						{r: true}
					],
					
					ret: 'boolean'
				},
				
				not: {
					/**
					 * The not function returns true if its argument is false, and false otherwise.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-not
					 * @param {BooleanType}
					 * @return {BooleanType} 
					 */
					fn: function(bool)
					{
						return new BooleanType(!bool.toBoolean());
					},
					
					args: [
						{t: 'boolean'}
					],
					
					ret: 'boolean'
				},
				
				'true': {
					/**
					 * The true function returns true.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-true
					 * @return {BooleanType} 
					 */
					fn: function()
					{
						return new BooleanType(true);
					},
					
					ret: 'boolean'
				},
				
				'false': {
					/**
					 * The false function returns false.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-false
					 * @return {BooleanType} 
					 */
					fn: function()
					{
						return new BooleanType(false);
					},
					
					ret: 'boolean'
				},
				
				/**
				 * The lang function returns true or false depending on whether the language
				 * of the context node as specified by xml:lang attributes is the same
				 * as or is a sublanguage of the language specified by the argument string.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-lang
				 * @param {StringType}
				 * @return {BooleanType} 
				 */
				lang: {
					fn: function(string)
					{
						var node = this.node,
							attributes,
							attributeName,
							attributeValueParts,
							langParts = string.toString().toLowerCase().split('-'),
							namespaceNodes,
							i,
							j,
							partsEqual
						;
						
						for(;node.nodeType != 9; node = nodeParent(node)) // document node
						{
							attributes = nodeAttribute(node);
							
							for(i = 0; i < attributes.length; i++)
							{
								// parse attribute name and namespace prefix
								attributeName = attributes[i].nodeName.split(':');
								if (attributeName.length === 1)
								{
									// set default namespace
									attributeName[1] = attributeName[0];
									attributeName[0] = '';
								}
								
								// compare attribute name
								if (attributeName[1] == 'lang')
								{
									attributeValueParts = attributes[i].nodeValue.toLowerCase().split('-');
									
									if (attributeValueParts.length < langParts.length)
										continue;
									
									// compare attribute value
									partsEqual = true;
									for(j=0; j < langParts.length; j++)
									{
										if (langParts[j] != attributeValueParts[j])
										{
											partsEqual = false;
											break;
										}
									}
									
									if (partsEqual)
									{
										// ensure xml namespace
										namespaceNodes = nodeNamespace.call(this, node);
										
										for(j=0; j < namespaceNodes.length; j++)
										{
											if(namespaceNodes[j].prefix == attributeName[0]
												&& namespaceNodes[j].nodeValue == NAMESPACE_URI_XML)
											{
												return new BooleanType(true);
											}
										}
									}
								}
							}
						}
						
						return new BooleanType(false);
					},
					
					args: [
						{t: 'string'}
					],
					
					ret: 'boolean'
				},
				
				// Number Functions
				
				number: {
					/**
					 * The number function converts its argument to a number.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-number
					 * @param {BaseType} object
					 * @return {NumberType}
					 */
					fn: function(object)
					{
						/**
						 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
						 */
						if (arguments.length == 0)
						{
							object = new NodeSetType([this.node], 'document-order');
						}
						
						return new NumberType(object.toNumber());
					},
					
					args: [
						{t: 'object', r: false}
					],
					
					ret: 'number'
				},
				
				sum: {
					/**
					 * The sum function returns the sum, for each node in the argument node-set,
					 * of the result of converting the string-values of the node to a number.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-sum
					 * @param {NodeSetType} 
					 * @return {NumberType}
					 */
					fn: function(nodeset)
					{
						var i,
							sum = 0
						;
						
						nodeset = nodeset.toNodeSet();
						
						for(i = 0; i < nodeset.length; i++)
						{
							sum += (new StringType(nodeStringValue(nodeset[i]))).toNumber();
						}
						
						return new NumberType(sum);
					},
					
					args: [
						{t: 'node-set'}
					],
					
					ret: 'number'
				},
				
				floor: {
					/**
					 * The floor function returns the largest (closest to positive infinity)
					 * number that is not greater than the argument and that is an integer.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-floor
					 * @param {NumberType} 
					 * @return {NumberType}
					 */
					fn: function(number)
					{
						return new NumberType(Math.floor(number));
					},
					
					args: [
						{t: 'number'}
					],
					
					ret: 'number'
				},
				
				ceiling: {
					/**
					 * The ceiling function returns the smallest (closest to negative infinity)
					 * number that is not less than the argument and that is an integer.
					 *
					 * @see http://www.w3.org/TR/xpath/#function-ceiling
					 * @param {NumberType} 
					 * @return {NumberType}
					 */
					fn: function(number)
					{
						return new NumberType(Math.ceil(number));
					},
					
					args: [
						{t: 'number'}
					],
					
					ret: 'number'
				},
				
				//Native round() function is overwritten with a custom javarosa round()
				//round: {
				//	/**
				//	 * The round function returns the number that is closest
				//	 * to the argument and that is an integer.
				//	 *
				//	 * @see http://www.w3.org/TR/xpath/#function-round
				//	 * @param {NumberType} 
				//	 * @return {NumberType}
				//	 */
				//	fn: function(number)
				//	{
				//		return new NumberType(Math.round(number));
				//	},
				//	
				//	args: [
				//		{t: 'number'}
				//	],
				//	
				//	ret: 'number'
				//},

				/********************************************************************/	
				/**** OpenRosa-specific XPath functions (or XPath 2.0 functions) ****/
				/********************************************************************/

				'count-non-empty': {
					/**
					 * The count-non-empty function returns the number of non-empty nodes in argument node-set. 
					 * A node is considered non-empty if it is convertible into a string with a greater-than zero length.
					 *
					 * @see https://www.w3.org/TR/2003/REC-xforms-20031014/slice7.html#fn-count-non-empty
					 * @param {NodeSetType} nodeset
					 * @return {NumberType}
					 */
					fn: function(nodeset)
					{
						var i;
						var count=0;

						nodeset = nodeset.toNodeSet();

						for ( i=0 ; i < nodeset.length ; i++){
							if ((new StringType(nodeStringValue(nodeset[i]))).toString().length > 0) {
								count++;
							}
						}

						return new NumberType(count);
					},
					
					args: [
						{t: 'node-set'}
					],
					
					ret: 'number'
				},

				position: {
					/**
					 * Hacked OpenRosa function to return the position of a nodeset argument
					 * the native position function accepts no arguments and always returns one.
					 * 
					 * This should not break proper XPath functioning with /path/to/node[position() < 3],
					 * but this is not supported in JavaRosa anyway.
					 *
					 * Note that these are actually two different functions into one...
					 *
					 * @param {NodeSetType?} node
					 * @return {NumberType}
					 */
					fn: function(nodeset)
					{

						// this is the JavaRosa behaviour
						if (nodeset) {
							var node, nodeName, position;
						
							nodeset = nodeset.toNodeSet();

							if (nodeset.length === 1) {
								node = nodeset[0];
								position = 1;
								nodeName = node.tagName;
								
								while (node.previousElementSibling && node.previousElementSibling.tagName === nodeName) {
									node = node.previousElementSibling;
									position++;
								}

								return new NumberType(position);
							} else {
								throw new Error('nodeset provided to position() contained multiple nodes');
							}
						}
						// this is the native XPath behaviour
						return new NumberType(this.pos);
					},

					args: [
						{t: 'node-set', r: false}
					],
					
					ret: 'number'
				},

				concat: {
					/**
					 * The concat function returns the concatenation of its arguments. This function
					 * goes beyond the XPath Native function by also accepting only 1 argument as well
					 * as node-set arguments that contain multiple nodes
					 *
					 * @see https://bitbucket.org/m.sundt/javarosa/src/62409ae3b803/core/src/org/javarosa/xpath/expr/XPathFuncExpr.java#cl-129
					 * @param {Object} o1
					 * @return {StringType}
					 */
					fn: function( /*o1, o2 ... */)
					{
						var i, add,
							value = '';
						
						for(i=0; i < arguments.length; i++)
						{
							if (arguments[i] instanceof NodeSetType)
							{
								add = arguments[i].stringValues().join('');
							}
							else
							{
								add = arguments[i].toString();
							}

							value += add;
						}
						
						return new StringType(value);
					},
					
					args: [
						{t: 'object', r:false, rep: true}
					],
					
					ret: 'string'
				},

				round: {
					/**
					 * The round function returns the number rounded to the amount of desired decimal places
					 * or nearest integer if the decimal places argument is not provided. The latter is the
					 * same behaviour of the native round().
					 *
					 * @see http://opendatakit.org/help/form-design/binding/
					 * @param {NumberType} number
					 * @param {NumberType} decimals [description]
					 * @return {NumberType}
					 */
					fn: function(number, decimals)
					{
						decimals = Math.round(decimals) || 0;
						return new NumberType(Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals));
					},
					
					args: [
						{t: 'number'},
						{t: 'number', r: false}
					],
					
					ret: 'number'
				},

				selected: {
					/**
					 * The selected function returns true or false if the argument
					 * is included in the space-separated list of selected multiselect values
					 * 
					 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
					 * @param {Object} object
					 * @param {StringType} value
					 * @return {BooleanType}
					 * 
					 */
					fn: function(node, value)
					{
						var values;

						value = value.toString().trim();
						values = node.toString();
						
						return new BooleanType( (' '+values+' ').indexOf(' '+value+' ') != -1 );
					},

					args: [
						{t: 'object'},
						{t: 'string'}
					],
					
					ret: 'boolean'
				},

				'selected-at' : {

					fn: function(node, position)
					{
						var value, values, selectValue;

						position = Math.round(position.toNumber());
						value = node.toString();
						values = value.split(' ');
						selectValue = (position >= 0 && position < values.length) ? values[position] : '';

						return new StringType(selectValue);
					},

					args: [
						{t: 'object'},
						{t: 'number'}
					],

					ret: 'string'

				},

				'count-selected': {
					/**
					 * The count-selected function returns the number of multiselect values currently selected
					 * 
					 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
					 * @param {NodeSetType} nodeset
					 * @return {NumberType}
					 * 
					 */
					fn: function(nodeset)
					{
						var values = [];

						nodeset = nodeset.toNodeSet();

						if (nodeset.length > 0){
							
							//only value of first node
							values = nodeStringValue(nodeset[0]).trim().split(' ');
							//return new Number(1);
							return (values.length == 1 && values[0] === '') ? new NumberType(0) : new NumberType(values.length);
						}

						return new NumberType(0);
					},

					args: [
						{t: 'node-set'}
					],

					ret: 'number'
				},

				checklist: {
					/**
					 * The checklist function returns true if the amount of 'yes' answers (take as true())
					 * is between min and max inclusive. Min or max may be -1 to indicate 'not applicable'.
					 * 
					 * @see http://opendatakit.org/help/form-design/binding/
					 * @param {NumberType} min
					 * @param {NumberType} max
					 * @param {BaseType} oA, oB, oC etc...
					 * @return {BooleanType}
					 * 
					 */

					fn: function(min, max /*,oA , oB .... */)
					{
						var i, j, 
							trues = 0
						;
						min = min.toNumber();
						max = max.toNumber();

						for (i=2 ; i<arguments.length ; i++)
						{
							if (arguments[i] instanceof NodeSetType)
							{
								for (j=0; j<arguments[i].stringValues().length ; j++)
								{
									if (arguments[i].stringValues()[j].toBoolean() === true)
									{
										trues++;
									}
								}
							}
							else if (arguments[i].toBoolean() === true)
							{
								trues++;
							}
						}

						return new BooleanType((min < 0 || trues >= min) && (max < 0 || trues <= max));
					},

					args: [
						{t: 'number'},
						{t: 'number'},
						{t: 'object'},
						{t: 'object', r: false, rep: true}
					],

					ret: 'boolean'
				},

				'weighted-checklist': {
					/**
					 * The weighted-checklist function returns true if the amount of 'yes' answers (take as true())
					 * multiplied by each weight, is between min and max inclusive. 
					 * Min or max may be -1 to indicate 'not applicable'.
					 * 
					 * @see http://opendatakit.org/help/form-design/binding/
					 * @param {NumberType} min
					 * @param {NumberType} max
					 * @param {BaseType} vA, vB, vC etc...
					 * @return {BooleanType}
					 * 
					 */

					fn: function(min, max /*,vA , wA, vB , wB.... */)
					{
						var i, 
							values = [], 
							weights = [], 
							weightedTrues = 0;

						min = min.toNumber();
						max = max.toNumber();

						for (i=2 ; i < arguments.length ; i=i+2)
						{
							var v = arguments[i]; 
							var w = arguments[i+1];
							if (v && w)
							{
								if (v instanceof NodeSetType)
								{
									values = values.concat(v.stringValues());
								}
								else
								{
									values.push(v);
								}
								if (w instanceof NodeSetType)
								{	
									weights = weights.concat(w.stringValues());
								}
								else
								{
									weights.push(w);
								}
							}
						}

						for (i=0 ; i < values.length ; i++)
						{
							if (values[i].toBoolean() === true)
							{
								weightedTrues += weights[i].toNumber();
							}
						}

						return new BooleanType((min < 0 || weightedTrues >= min) && (max < 0 || weightedTrues <= max));
					},

					args: [
						{t: 'number'},
						{t: 'number'},
						{t: 'object'},
						{t: 'object'},
						{t: 'object', r: false, rep: true}
					],

					ret: 'boolean'
				},

				'boolean-from-string': {
					/**
					 * The boolean-from-string function returns true if the string is 'true' or '1'. 
					 * Note that a number is cast to a string.
					 * 
					 * @see http://opendatakit.org/help/form-design/binding/
					 * @param {StrType} str
					 * @return {BooleanType}
					 * 
					 */
					fn: function(str)
					{
						return new BooleanType(str.toString().toLowerCase() === 'true' || String(str) === '1');
					},

					args: [
						{t: 'string'}
					],

					ret: 'boolean'
				},

				'if': {

					fn: function(cond, a, b)
					{
						return ( cond.toBoolean() ? a : b );
					},

					args: [
						{t: 'object'},
						{t: 'object'},
						{t: 'object'}
					],

					ret: 'object'

				},

				'date': {

					fn: function(obj)
					{
						return new DateType(obj.toDate());
					},

					args: [
						{t: 'object'}
					],

					ret: 'string'
				},

				/**
				 * Alias of "date"
				 * Note: Javarosa makes a distinction between date and date-time() in that
				 * time is removed from date(). We have to do that too, but all date() tests pass.
				 */
				'date-time': {

					fn: function(obj)
					{
						return new DateType(obj.toDate());
					},

					args: [
						{t: 'object'}
					],

					ret: 'string'
				},

				/** 
				 * @see https://opendatakit.github.io/xforms-spec/#fn:decimal-date-time
				 */
				'decimal-date-time': {

					fn: function(dt)
					{
						var MS_IN_DAY = 1000 * 60 * 60 * 24;
						var PRECISION = 1000;
						var d = dt.toDate();
						var dec;

						if ( d.toString() !== 'Invalid Date' ) {
							dec = Math.round(d.getTime() * PRECISION / MS_IN_DAY) / PRECISION;
						} else {
							dec = Number.NaN;
						}

						return new NumberType(  dec );
					},

					args: [
						{t: 'object'}
					],

					ret: 'number'
				},

				/** 
				 * @see https://opendatakit.github.io/xforms-spec/#fn:decimal-time
				 */
				'decimal-time': {

					fn: function(time)
					{
						// There is no Time type, and so far we don't need it so we do all validation 
						// and conversion here, manually.
						var	m = time.toString().match( /^(\d\d):(\d\d):(\d\d)(\.\d\d?\d?)?(\+|-)(\d\d):(\d\d)$/ );
						//var ERR = new Error('Invalid time format provided.');
						var PRECISION = 1000;
						var dec;
						
						if ( m && 
							m[ 1 ] < 24 && m[ 1 ] >= 0 &&
							m[ 2 ] < 60 && m[ 2 ] >= 0 &&
							m[ 3 ] < 60 && m[ 3 ] >= 0 &&
							m[ 6 ] < 24 && m[ 6 ] >= 0 && // this could be tighter
							m[ 7 ] < 60 && m[ 7 ] >= 0 // this is probably either 0 or 30
						) {
							var pad2 = function( x ) { return ( x < 10 ) ? '0' + x : x;};
							var today = new Date(); // use today to cater to daylight savings time.
							var d = new Date( today.getFullYear() + '-' + pad2( today.getMonth() + 1 ) + '-' + pad2(today.getDate()) + 'T' + time);

							if ( d.toString() === 'Invalid Date' ){
								dec = Number.NaN;
							} else {
								dec =  Math.round( (d.getSeconds() / 3600 + d.getMinutes() / 60 + d.getHours() )* PRECISION / 24) / PRECISION;
							}
						} else {
							dec = Number.NaN;
						}

						return new NumberType(  dec );
					},

					args: [
						{t: 'string'}
					],

					ret: 'number'
				},

				today: {
					
					fn: function()
					{
						var today = new Date();
						return new DateType(new Date(today.getFullYear(), today.getMonth(), today.getDate()));
					},

					ret: 'string'
				},

				now: {
					/**
					 * The now function returns the current datetime.
					 * 
					 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
					 * @return {NumberType}
					 * 
					 */

					fn: function()
					{
						return new DateType(new Date());
					},

					ret: 'string'
				},

				regex: {
					/**
					 * The regex function evaluates a regular expression and returns true or false.
					 * 
					 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
					 * @return {BooleanType}
					 * 
					 */
					fn: function(obj, expr)
					{
						var value, patt;

						value = obj.toString();

						patt = new RegExp(expr);

						return new BooleanType(patt.test(value));
					},

					args: [
						{t: 'object'},
						{t: 'string'}
					],

					ret: 'boolean'

				}, 

				uuid: {
					/**
					 * The uuid function returns an RFC 4122 Version 4 UUID string.
					 * 
					 * @see http://opendatakit.org/help/form-design/binding/
					 * @return {StringType}
					 * 
					 */
					fn: function()
					{
						//from broofa: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
						var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
							var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
							return v.toString(16);
						});
						return new StringType(uuid);
					}, 

					ret: 'string'
				},

				'int': {
					/**
					 * The int function turns a parameter into a number and truncates the fractional part
					 * 
					 * @see http://opendatakit.org/help/form-design/binding/
					 * @return {NumberType}
					 * 
					 */
					fn: function(str)
					{
						// Using ParseInt, creates a problem for very small or large numbers that are displayed in scientific
						// notation. E.g. parseInt(1/47999799999, 10) is 2 instead of 0 (2.08e-11)
						return new NumberType( ( str.toNumber() >= 0 ) ? Math.floor( str.toNumber() ) : -Math.floor( Math.abs( str.toNumber() ) ) );
					}, 
					args: [
						{t: 'string'}
					],

					ret: 'number'
				},

				substr: {
					/**
					 * The substr function returns the substring of the first argument
					 * starting at the position specified in the second argument
					 * with end character position specified in the third argument.
					 * 
					 * THE DIFFERENCE WITH THE XPATH 1.0 NATIVE FUNCTION IS THAT POSITIONS ARE 0-BASED HERE,
					 * THE LENGTH IS GIVEN AS A CHARACTER POSITION (END) AND NEGATIVE VALUES ARE DEALT WITH 
					 * DIFFERENTLY
					 *
					 * @see http://opendatakit.org/help/form-design/binding/
					 * @param {StringType} str
					 * @param {NumberType} start
					 * @param {NumberType} end
					 * @return {StringType}
					 */
					fn: function(str, start, end)
					{
						str = str.toString();
						var length = str.length;

						start = Math.round(start.toNumber());
						end = (end) ? Math.round(end.toNumber()) : length;
						
						return new StringType(
							isNaN(start)
								? ''
								: str.substring( start < 0 ? length + start : start, end < 0 ? length + end : end )
						);
					},
					
					args: [
						{t: 'string'},
						{t: 'number'},
						{t: 'number', r: false}
					],
					
					ret: 'string'
				},

				random: {
					/**
					 * The random function returns a random number between 0.0 (inclusive) and 1.0 (exclusive).
					 * 
					 * @see http://opendatakit.org/help/form-design/binding/
					 * @return {NumberType}
					 */
					fn: function()
					{

						return new NumberType(Math.random().toFixed(15));
					
					},
					
					ret: 'number'
				}, 

				min: {
					/**
					 * The min function returns the smallest values in the argument node-sets,
					 * of the result of converting the string-values of the nodes to a number.
					 *
					 * A slight improvement over JavaRosa is that each argument can be a nodeset
					 *
					 * @see https://www.w3.org/TR/xpath-functions/#func-min
					 * @param {BaseType} object1
					 * @param {BaseType} object2
					 * @return {NumberType}
					 */
					fn: function(/*object1, object2, object3 ... */)
					{
						var i, j, min, val, nodeset;

						for ( i = 0; i < arguments.length; i++ )
						{

							if (arguments[i] instanceof NodeSetType ){

								nodeset = arguments[i].toNodeSet();
							
								for( j = 0; j < nodeset.length; j++ )
								{
									val = new StringType( nodeStringValue( nodeset[j] ) );
									if (val)
									{
										min = typeof min !== 'undefined' ? Math.min( min, val.toNumber() ) : val.toNumber();
									}
								}
								if ( nodeset.length === 0 ){
									min = NaN;
								}
							} 
							else 
							{
								val = new StringType( arguments[i].toString() );
								if ( val )
								{
									min = typeof min !== 'undefined' ? Math.min( min, val.toNumber() ) : val.toNumber();
								}
							}
						}
						
						return new NumberType( min );
					},
					
					args: [
						{t: 'object'}, 
						{t: 'object', r: false, rep: true}
					],
					
					ret: 'number'
				}, 

				max: {
					/**
					 * The max function returns the largest value in the argument node-sets,
					 * of the result of converting the string-values of the nodes to a number.
					 *
					 * A slight improvement over JavaRosa is that each argument can be a nodeset
					 *
					 * @see https://www.w3.org/TR/xpath-functions/#func-max
					 * @param {BaseType}  object1
					 * @param {BaseType}  object2
					 * @return {NumberType}
					 */
					fn: function(/*object1, object2, object3 ... */)
					{
						var i, j, max, val, nodeset;
						
						for ( i = 0; i < arguments.length; i++ )
						{
							if ( arguments[i] instanceof NodeSetType ){
								
								nodeset = arguments[i].toNodeSet();
							
								for( j = 0; j < nodeset.length; j++ )
								{
									val = new StringType( nodeStringValue(nodeset[j]) );
									if ( val )
									{
										max = typeof max !== 'undefined' ? Math.max( max, val.toNumber() ) : val.toNumber();
									}
								}
								if ( nodeset.length === 0 ){
									max = NaN;
								}
							}
							else {
								val = new StringType( arguments[i].toString() );
								if ( val )
								{
									max = typeof max !== 'undefined'  ? Math.max( max, val.toNumber() ) : val.toNumber();
								}
							}
							
						}
						
						return new NumberType( max );
					},
					
					args: [
						{t: 'object'}, 
						{t: 'object', r: false, rep: true}
					],
					
					ret: 'number'
				},

				join: {
					/**
					 * The join function returns the concatenation of arguments, separated by the
					 * first argument string.
					 *
					 * @see http://opendatakit.org/help/form-design/binding/
					 * @param {StringType} str1
					 * @param {Object} obj1
					 * @return {StringType}
					 */
					fn: function(str1/*, obj1, obj2 ... */)
					{
						var i, 
							values = []
						;

						for (i=1; i < arguments.length; i++)
						{
							if (arguments[i] instanceof NodeSetType){
								values = values.concat(arguments[i].stringValues());
							}
							else{
								values.push(arguments[i].toString());
							} 
						}
						
						var value = values[0] || ''; 

						for (i = 1; i < values.length; i++ )
						{
							value += str1.toString() + values[i];
						}

						return new StringType(value);
					},
					
					args: [
						{t: 'string'},
						{t: 'object', r: false, rep: true}
					],
					
					ret: 'string'
				},

				/**
				 * The coalesce function returns the first non-empty value for the two
				 * arguments provided.
				 *
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @param {Object} a
				 * @param {Object} b
				 * @return {StringType}
				 */
				coalesce : {

					fn: function(a, b)
					{
						return ( a.toString().length > 0 ) ? a : b ;
					},

					args: [
						{t: 'object'},
						{t: 'object'}
					],

					ret: 'string'

				},

				/**
				 * The date-format function returns the first non-empty value for the two
				 * arguments provided. It returns date properties in the LOCAL timezone. 
				 * TODO: check how ODK Collect deals with timezones
				 *
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @param {Object} a
				 * @param {Object} b
				 * @return {StringType}
				 */
				'format-date' : {

					fn: function(dateO, format)
					{
						var j;
						dateO = new DateType(dateO); //not sure why this did not happen automatically
						var	date = dateO.toDate();
						var	result = format.toString();
						var	intPad = function(num, l)
							{
								var str = num.toString(),
									zeros = l - str.length;
								for (j=0 ; j < zeros ; j++)
								{
									str = '0'+str;
								}
								return str;
							};
						var locale = window ? window.enketoFormLocale : undefined;

						if (!dateO.toBoolean())
						{
							return new StringType(date.toString());
						}

						var props = {
							'Y'	: date.getFullYear(),
							'y'	: date.getFullYear().toString().substring(2,4),
							'm'	: intPad((date.getMonth()+1), 2),
							'n'	: date.getMonth()+1,
							'b'	: date.toLocaleDateString( locale, { month: 'short' } ),
							'd'	: intPad(date.getDate(), 2),
							'e'	: date.getDate(),
							'H'	: intPad(date.getHours(), 2),
							'h'	: date.getHours(),
							'M'	: intPad(date.getMinutes(), 2),
							'S'	: intPad(date.getSeconds(), 2),
							'3'	: intPad(date.getMilliseconds(), 3),
							'a'	: date.toLocaleDateString( locale, { weekday: 'short' } )
						};

						for (var prop in props)
						{
							result = result.replace('%'+prop, props[prop]);
						}

						return new StringType(result);
					},

					args: [
						{t: 'date'},
						{t: 'string'}
					],

					ret: 'string'

				},

				/**
				 * The pow function returns exponentiated result
				 * arguments provided.
				 *
				 * @see temporary: https://bitbucket.org/m.sundt/javarosa/pull-request/2/adding-pow-support/diff
				 * @param {NumberType} a
				 * @param {NumberType} b
				 * @return {NumberType}
				 */
				pow : {

					fn: function(a, b)
					{
						return new NumberType( Math.pow(a, b) ) ;
					},

					args: [
						{t: 'number'},
						{t: 'number'}
					],

					ret: 'number'

				},


				/**
				 * The sin function returns the sine of the argument, expressed in radians.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-sin
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				sin : {

					fn: function(a)
					{
						return new NumberType( Math.sin(a) ) ;
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},


				/**
				 * The cos function returns the cosine of the argument, expressed in radians.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-cos
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				cos : {

					fn: function(a)
					{
						return new NumberType( Math.cos(a) ) ;
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},

				/**
				 * The tan function returns the tangent of the argument, expressed in radians.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-tan
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				tan : {

					fn: function(a)
					{
						return new NumberType( Math.tan(a) ) ;
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},


				/**
				 * The acos function returns the arc cosine of the argument, the result being in the range zero to +π radians.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-acos
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				acos : {

					fn: function(a)
					{
						return new NumberType( Math.acos(a) ) ;
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},

				/**
				 * The asin function returns the arc sine of the argument, the result being in the range -π/2 to +π/2 radians.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-asin
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				asin : {

					fn: function(a)
					{
						return new NumberType( Math.asin(a) ) ;
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},


				/**
				 * The atan function returns the arc tangent of the argument, the result being in the range -π/2 to +π/2 radians.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-atan
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				atan : {

					fn: function(a)
					{
						return new NumberType( Math.atan(a) ) ;
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},

				/**
				 * The atan2 function returns the angle in radians subtended at the origin by the point on a plane 
				 * with coordinates (x, y) and the positive x-axis, the result being in the range -π to +π.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-atan2
				 * @param {NumberType} a
				 * @param {NumberType} b
				 * @return {NumberType}
				 */
				atan2 : {

					fn: function(a, b)
					{
						return new NumberType( Math.atan2(a, b) ) ;
					},

					args: [
						{t: 'number'},
						{t: 'number'}
					],

					ret: 'number'
				},

				/**
				 * The log10 function returns the base-ten logarithm of the argument.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-log10
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				log10 : {

					fn: function(a)
					{
						// Math.log10 doesn't have cross-browser support. The polyfill has a smallrounding error.
						if (typeof Math.log10 !== 'undefined'){
							return new NumberType( Math.log10(a) );
						} else {
							return new NumberType( Math.log(a) / Math.LN10 ) ;
						}
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},

				/**
				 * The log function returns the natural logarithm of the argument.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-log
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				log : {

					fn: function(a)
					{
						return new NumberType( Math.log(a) ) ;
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},

				/**
				 * The pi function returns an approximation to the mathematical constant π.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-pi
				 * @return {NumberType}
				 */
				pi : {

					fn: function()
					{
						return new NumberType( Math.PI ) ;
					},

					args: [],

					ret: 'number'
				},

				/**
				 * The exp function returns the value of e^x.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-exp
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				exp : {

					fn: function(a)
					{
						return new NumberType( Math.exp(a) ) ;
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},


				/**
				 * The exp10 function returns the value of 10^x.
				 *
				 * @see https://www.w3.org/TR/xpath-functions-30/#func-math-exp10
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				exp10 : {

					fn: function(a)
					{
						return new NumberType( Math.pow(10, a) ) ;
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},

				/**
				 * The sqrt function returns the non-negative square root of the argument.
				 *
				 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-sqrt
				 * @param {NumberType} a
				 * @return {NumberType}
				 */
				sqrt : {

					fn: function(a)
					{
						return new NumberType( Math.sqrt(a) ) ;
					},

					args: [
						{t: 'number'}
					],

					ret: 'number'
				},

				/**
				 * The once function returns the value of the parameter if its own value
				 * is not empty, NaN, [Infinity or -Infinity]. The naming is therefore misleading! 
				 * Also note that the parameter expr is always evaluated.
				 * This function simply decides whether to return the new result or the old value.
				 *
				 * @return {StringType}
				 */
				once : {

					fn: function(a)
					{
						var curValue = nodeStringValue(this.node),
							newValue = a.toString();

						// disable NaN, Infinity and -Infinity...
						newValue = (newValue === 'NaN' /*|| newValue === 'Infinity' || newValue === '-Infinity'*/) ? '' : newValue;

						return (curValue !== '') ? new StringType(curValue) : new StringType(newValue); 
					},

					args: [
						{t: 'string'}
					],

					ret: 'string'

				},

				/**
				 * The area function returns the area in m2 of a single geoshape
				 * value, or of a nodeset of ordered geopoints.
				 *
				 * @see https://opendatakit.github.io/xforms-spec/#fn:area
				 * 
				 * @return {NumberType}
				 */
				area : {

					fn: function(a)
					{
						var	geopoints = [];

						if ( a instanceof NodeSetType && a.value.length > 1 ){
							a.value.forEach(function(node){
								geopoints.push(nodeStringValue(node));
							});
						} else if ( a instanceof NodeSetType ) {
							geopoints = nodeStringValue(a.value[0]).split(';');
						} else if ( a instanceof StringType ) {
							geopoints = a.value.split(';');	
						}
						
						return new NumberType( geo.area( geopoints ) ); 
					},

					args: [
						{t: 'string'}
					],

					ret: 'number'
				},

				/**
				 * The distance function returns the distance in m of a single geoshape
				 * value, or a geotrace value, or of a nodeset of ordered geopoints.
				 * 
				 * @see https://opendatakit.github.io/xforms-spec/#fn:distance
				 *
				 * @return {NumberType}
				 */
				distance : {

					fn: function(a)
					{
						var	geopoints = [];

						if ( a instanceof NodeSetType && a.value.length > 1 ){
							a.value.forEach(function(node){
								geopoints.push(nodeStringValue(node));
							});
						} else if ( a instanceof NodeSetType ) {
							geopoints = nodeStringValue(a.value[0]).split(';');
						} else if ( a instanceof StringType ) {
							geopoints = a.value.split(';');	
						}
						
						return new NumberType( geo.distance( geopoints ) ); 
					},

					args: [
						{t: 'string'}
					],

					ret: 'number'
				},

				'ends-with': {
					/**
					 * The ends-with function returns true if the first argument string
					 * ends with the second argument string, and otherwise returns false.
					 *
					 * An alternative (faster?) would be to reverse the first argument and use starts-with (in Enketo Core)?
					 *
					 * @see https://www.w3.org/TR/xpath-functions-30/#func-ends-with
					 * @param {StringType} haystack
					 * @param {StringType} needle
					 * @return {StringType}
					 */
					fn: function(haystack, needle)
					{
						return new BooleanType(haystack.toString().substr(haystack.toString().length - needle.toString().length) === needle.toString());
					},
					
					args: [
						{t: 'string'},
						{t: 'string'}
					],
					
					ret: 'string'
				},

				abs: {
					/**
					 * Returns the absolute value of the argument.
					 *
					 * @see https://www.w3.org/TR/xpath-functions-30/#func-abs
					 * @param {NumberType} 
					 * @return {NumberType}
					 */
					fn: function(number)
					{
						return new NumberType(Math.abs(number));
					},
					
					args: [
						{t: 'number'}
					],
					
					ret: 'number'
				},

				randomize: {
					/**
					 * Randomizes nodesets
					 * 
					 * @see https://opendatakit.github.io/xforms-spec/#fn:randomize
					 * @param {NodesetType}  nodeset
					 * @param {NumberType}   seed
					 * @return {NodesetType}
					 */
					fn: function(nodeset, seed)
					{
						var seedValue = seed ? seed.toNumber() : undefined;
						return new NodeSetType( shuffle_1( nodeset.toNodeSet(), seedValue ), 'document-order' );
					},

					args: [
						{t: 'node-set'},
						{t: 'number', r: false}
					],
					
					ret: 'node-set'
				},

				/**
				 * MOVED TO ENKETO-CORE WHERE IT TRANSFORMED INTO REGULAR XPATH
				 *
				 * @param { NodeSetType} nodeset 	 	Collection of nodes of which to select one
				 * @param { NodeSetType} r1,r2,r3,r4,r5 The repeat nodes 
				 * @param { NumberType}  p1,p2,p3,p4,p5 The position of the repeat that contains the node to return
				 * @return {NodeSetType}
				 */
				/*'indexed-repeat': {

					fn: function(nodeset, r1, p1, r2, p2, r3, p3, r4, p4, r5, p5) {
						var tagName, node, repeat, position, repeats, positions, i;

						nodeset = nodeset.toNodeSet();

						if (nodeset.length === 0) {
							throw new Error('indexed-repeat called with empty nodeset in first parameter');
							return;
						} 
						if (arguments.length % 2 !== 1) {
							throw new Error('indexed-repeat received invalid number of arguments');
							return;
						}

						for ( i = 1; i < arguments.length - 1; i += 2) {
							position = arguments[ i + 1 ].toNumber();
							repeats = arguments[ i ].toNodeSet();
							if (repeats.length === 0) {
								throw new Error('indexed-repeat called with empty nodeset as repeat parameter');
							}
							tagName = repeats[0].tagName;
							repeat = (repeat) ? repeat.getElementsByTagName(tagName)[position - 1] : repeats[position - 1];
						}

						tagName = nodeset[0].tagName;
						node = repeat.getElementsByTagName(tagName);

						return new NodeSetType(node, 'document-order');
					},

					args: [
						{ t: 'node-set' }, 
						{ t: 'node-set' }, 
						{ t: 'number' },
						{ t: 'node-set', r: false}, 
						{ t: 'number', r: false },
						{ t: 'node-set', r:false }, 
						{ t: 'number', r: false},
						{ t: 'node-set', r: false }, 
						{ t: 'number', r:false },
						{ t: 'node-set', r:false }, 
						{ t: 'number', r:false }
					],

					ret: 'node-set'

				}*/
			}
		};
		/**
		 * Alias functions
		 */
		functions['']['format-date-time'] = functions['']['format-date'];
		
		/**
		 * Evaluate parsed expression tree.
		 *
		 * @param {Object} context
		 * @param {Object} tree
		 * @return {Object}
		 */
		evaluateExpressionTree = function(context, tree)
		{
			if (typeof expressions[tree.type] != 'function')
			{
				throw new Error('Internal Error: Expression type does not exist: ' + tree.type);
			}
			
			return expressions[tree.type].apply(context, tree.args);
		};
		
		/**
		 * The XPathResult interface represents the result of the evaluation of a
		 * XPath 1.0 expression within the context of a particular node. Since
		 * evaluation of an XPath expression can result in various result types,
		 * this object makes it possible to discover and manipulate the type
		 * and value of the result.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult
		 *
		 * @param {Context} context
		 * @param {Number} type
		 * @param {BaseType} value
		 */
		XPathResult = function(context, type, value)
		{
			switch(type)
			{
				case XPathResult.NUMBER_TYPE:
					this.resultType = XPathResult.NUMBER_TYPE;
					this.numberValue = value.toNumber();
					break;
					
				case XPathResult.STRING_TYPE:
					this.resultType = XPathResult.STRING_TYPE;
					this.stringValue = value.toString();
					break;
				
				case XPathResult.BOOLEAN_TYPE:
					this.resultType = XPathResult.BOOLEAN_TYPE;
					this.booleanValue = value.toBoolean();
					break;
				
				case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
				case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
				case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
				case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
				case XPathResult.ANY_UNORDERED_NODE_TYPE:
				case XPathResult.FIRST_ORDERED_NODE_TYPE:
					if (!(value instanceof NodeSetType))
					{
						throw new Error('Expected result of type "node-set", got: "' + value.type + '"');
					}
					
					this.resultType = type;
					
					switch(type)
					{
						case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
						case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
							this._value = value.toNodeSet();
							this.snapshotLength = this._value.length;
							break;
						
						case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
						case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
							// ensure in document order
							value.sortDocumentOrder();
							
							this._value = value.toNodeSet();
							this.snapshotLength = this._value.length;
							break;
						
						case XPathResult.ANY_UNORDERED_NODE_TYPE:
							value = value.toNodeSet();
							this.singleNodeValue = (value.length) ? value[0] : null;
							break;
						
						case XPathResult.FIRST_ORDERED_NODE_TYPE:
							// ensure in document order
							value.sortDocumentOrder();
							value = value.toNodeSet();
							this.singleNodeValue = (value.length) ? value[0] : null;
							break;
						
						default:
							throw new XPathException(XPathException.TYPE_ERR, 'XPath result type not supported. (type: ' + type + ')');
					}
					
					break;
				
				default:
					throw new XPathException(XPathException.TYPE_ERR, 'XPath result type not supported. (type: ' + type + ')');
			}
		};
		
		XPathResult.factory = function(context, type, value)
		{
			var result;
			
			if (type !== XPathResult.ANY_TYPE)
			{
				return new XPathResult(context, type, value);
			}
			
			// handle any type result
			if (value instanceof NodeSetType)
			{
				result = new XPathResult(context, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, value);
			}
			else if (value instanceof NumberType)
			{
				result = new XPathResult(context, XPathResult.NUMBER_TYPE, value);
			}
			else if (value instanceof BooleanType)
			{
				result = new XPathResult(context, XPathResult.BOOLEAN_TYPE, value);
			}
			else if (value instanceof StringType)
			{
				result = new XPathResult(context, XPathResult.STRING_TYPE, value);
			}
			else
			{
				throw new XPathException(XPathException.TYPE_ERR, 'Internal Error: Unsupported value type: ' + typeof value);
			}
			
			return result;
		};
		
		XPathResult.prototype = {
			/**
			 * A code representing the type of this result, as defined by the type constants.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-resultType
			 * @type {number}
			 */
			resultType: null,
			
			/**
			 * The value of this number result.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-numberValue
			 * @type {number}
			 */
			numberValue: null,
			
			/**
			 * The value of this string result.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-stringValue
			 * @type {String}
			 */
			stringValue: null,
			
			/**
			 * The value of this boolean result.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-booleanValue
			 * @type {boolean}
			 */
			booleanValue: null,
			
			/**
			 * The value of this single node result, which may be null.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-singleNodeValue
			 * @type {Node}
			 */
			singleNodeValue: null,
			
			/**
			 * Signifies that the iterator has become invalid. True if resultType is
			 * UNORDERED_NODE_ITERATOR_TYPE or ORDERED_NODE_ITERATOR_TYPE and the
			 * document has been modified since this result was returned.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-invalid-iterator-state
			 * @type {boolean}
			 */
			invalidIteratorState: null,
			
			/**
			 * The number of nodes in the result snapshot.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-snapshot-length
			 * @type {number}
			 */
			snapshotLength: null,
			
			_iteratorIndex: 0,
			
			iterateNext: function()
			{
				if (
					this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE &&
					this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE
				) {
					throw new XPathException(XPathException.TYPE_ERR, 'iterateNext() method may only be used with results of type UNORDERED_NODE_ITERATOR_TYPE or ORDERED_NODE_ITERATOR_TYPE');
				}
				
				if (this._iteratorIndex < this._value.length)
				{
					return this._value[this._iteratorIndex++];
				}
				
				return null;
			},
			
			snapshotItem: function(index)
			{
				if (
					this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE &&
					this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE
				) {
					throw new XPathException(XPathException.TYPE_ERR, 'snapshotItem() method may only be used with results of type UNORDERED_NODE_SNAPSHOT_TYPE or ORDERED_NODE_SNAPSHOT_TYPE');
				}
				
				return this._value[index];
			}
		};
		
		/**
		 * XPathResultType
		 *
		 * An integer indicating what type of result this is.
		 *
		 * If a specific type is specified, then the result will be returned as the corresponding
		 * type, using XPath type conversions where required and possible.
		 */
		
		XPathResult.ANY_TYPE = 0;
		XPathResult.NUMBER_TYPE = 1;
		XPathResult.STRING_TYPE = 2;
		XPathResult.BOOLEAN_TYPE = 3;
		XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
		XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
		XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
		XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
		XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
		XPathResult.FIRST_ORDERED_NODE_TYPE = 9;
		
		/**
		 * The XPathNamespace interface is returned by XPathResult interfaces to
		 * represent the XPath namespace node type that DOM lacks. There is no public
		 * constructor for this node type. Attempts to place it into a hierarchy or a
		 * NamedNodeMap result in a DOMException with the code HIERARCHY_REQUEST_ERR.
		 * This node is read only, so methods or setting of attributes that would
		 * mutate the node result in a DOMException with the code NO_MODIFICATION_ALLOWED_ERR.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathNamespace
		 * @param {string} prefix Prefix of the namespace represented by the node.
		 * @param {string} namespaceURI Namespace URI of the namespace represented by the node.
		 * @param {Element} ownerElement The Element on which the namespace was in scope when it was requested.
		 */
		XPathNamespace = function(prefix, namespaceURI, ownerElement)
		{
			if(ownerElement.nodeType != 1)
			{
				throw new Error('Internal Error: XPathNamespace owner element must be an Element node.');
			}
			this.ownerElement = ownerElement;
			
			// ownerDocument matches the ownerDocument of the ownerElement even if the element is later adopted.
			// TODO-FUTURE: ownerDocument == ownerElement.ownerDocument when ownerElement changes ownerDocument
			this.ownerDocument = ownerElement.ownerDocument;
			
			// nodeName is always the string "#namespace".
			this.nodeName = '#namespace';
			
			// prefix is the prefix of the namespace represented by the node.
			this.prefix = prefix;
			
			// localName is the same as prefix.
			this.localName = prefix;
			
			// nodeType is equal to XPATH_NAMESPACE_NODE.
			this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
			
			// namespaceURI is the namespace URI of the namespace represented by the node.
			this.namespaceURI = namespaceURI;
			
			// nodeValue is the same as namespaceURI.
			this.nodeValue = namespaceURI;
			
			// adoptNode, cloneNode, and importNode fail on this node type by raising a DOMException with the code NOT_SUPPORTED_ERR.
			// TODO-FUTURE: implement exceptions above, see: http://www.w3.org/TR/DOM-Level-3-Core/
			
			// TODO-FUTURE: find all other attributes of Node not set above, and set the to null or false
			// see: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1950641247
		};
		
		/**
		 * An integer indicating which type of node this is.
		 *
		 * Note: There is currently only one type of node which is specific to XPath. The numbers in this list must not collide with the values assigned to core node types.
		 * 
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPATH_NAMESPACE_NODE
		 * @property {number} The node is a Namespace.
		 */
		XPathNamespace.XPATH_NAMESPACE_NODE = 13;
		
		module = {
			XPathException: XPathException,
			XPathEvaluator: XPathEvaluator,
			XPathNSResolver: XPathNSResolver,
			XPathExpression: XPathExpression,
			XPathResult: XPathResult,
			XPathNamespace: XPathNamespace,
			customXPathFunction: {
				type: {
					StringType: StringType,
					NumberType: NumberType,
					NodeSetType: NodeSetType,
					BooleanType: BooleanType
				},
				add: function(name, fnObj){
					functions[''][name] = fnObj;
				},
				remove: function(name) {
					delete functions[''][name];
				}
			},
			
			/**
			 * Get the current list of DOM Level 3 XPath window and document objects
			 * that are in use.
			 *
			 * @return {Object} List of DOM Level 3 XPath window and document objects
			 *         that are currently in use.
			 */
			getCurrentDomLevel3XPathBindings: function()
			{
				return {
					'window': {
						XPathException: window.XPathException,
						XPathExpression: window.XPathExpression,
						XPathNSResolver: window.XPathNSResolver,
						XPathResult: window.XPathResult,
						XPathNamespace: window.XPathNamespace
					},
					'document': {
						createExpression: document.createExpression,
						createNSResolver: document.createNSResolver,
						evaluate: document.evaluate
					}
				};
			},
			
			/**
			 * Get the list of DOM Level 3 XPath objects that are implemented by
			 * the XPathJS module.
			 *
			 * @return {Object} List of DOM Level 3 XPath objects implemented by
			 *         the XPathJS module.
			 */
			createDomLevel3XPathBindings: function(options)
			{
				var evaluator = new XPathEvaluator(options)
				;
				
				return {
					'window': {
						XPathException: XPathException,
						XPathExpression: XPathExpression,
						XPathNSResolver: XPathNSResolver,
						XPathResult: XPathResult,
						XPathNamespace: XPathNamespace
					},
					'document': {
						createExpression: function() {
							return evaluator.createExpression.apply(evaluator, arguments);
						},
						createNSResolver: function() {
							return evaluator.createNSResolver.apply(evaluator, arguments);
						},
						evaluate: function() {
							return evaluator.evaluate.apply(evaluator, arguments);
						}
					}
				};
			},
			
			/**
			 * Bind DOM Level 3 XPath interfaces to the DOM.
			 *
			 * @param {Object} doc the document or (Document.prototype!) to bind the evaluator etc. to
			 * @return List of original DOM Level 3 XPath objects that has been replaced
			 */
			bindDomLevel3XPath: function(doc, bindings)
			{
				var newBindings = (bindings || module.createDomLevel3XPathBindings()),
					currentBindings = module.getCurrentDomLevel3XPathBindings(),
					i
				;

				doc = doc || document;
				
				for(i in newBindings['window'])
				{
					window[i] = newBindings['window'][i];
				}
				
				for(i in newBindings['document'])
				{
					doc[i] = newBindings['document'][i];
				}
				
				return currentBindings;
			}
		};
		
		return module;
		
	})();

	function bindJsEvaluator( addExtensions ) {
	    const evaluator = new engine.XPathEvaluator();

	    /*
	     * Note: it's inefficient to extend XPathJS here (for every model instance)
	     * instead of just once in the prototype.
	     * 
	     * However, this is done to prevent breaking Medic Mobile.
	     * The performance impact is probably negligible, since we don't instantiate
	     * models very often.
	     * 
	     * In any case, you don't have to use it like this. It was done for 
	     * Enketo Validate only. In an app that doesn't override enketo-xpathjs, 
	     * I'd recommend using `require('extension')(require('enketo-xpathjs'))` instead
	     * and leave the addExtensions parameter empty here.
	     */
	    if ( typeof addExtensions === 'function' ) {
	        addExtensions( engine );
	    }

	    engine.bindDomLevel3XPath( this.xml, {
	        'window': {
	            JsXPathException: true,
	            JsXPathExpression: true,
	            JsXPathNSResolver: true,
	            JsXPathResult: true,
	            JsXPathNamespace: true
	        },
	        'document': {
	            jsCreateExpression( ...args ) {
	                return evaluator.createExpression( ...args );
	            },
	            jsCreateNSResolver( ...args ) {
	                return evaluator.createNSResolver( ...args );
	            },
	            jsEvaluate( ...args ) {
	                return evaluator.evaluate( ...args );
	            }
	        }
	    } );
	}

	const REPEAT_COMMENT_PREFIX = 'repeat:/';
	const INSTANCE = /instance\(\s*(["'])((?:(?!\1)[A-z0-9.\-_]+))\1\s*\)/g;
	const OPENROSA = /(decimal-date-time\(|pow\(|indexed-repeat\(|format-date\(|coalesce\(|join\(|max\(|min\(|random\(|substr\(|int\(|uuid\(|regex\(|now\(|today\(|date\(|if\(|boolean-from-string\(|checklist\(|selected\(|selected-at\(|round\(|area\(|position\([^)])/;
	const OPENROSA_XFORMS_NS = 'http://openrosa.org/xforms';
	const JAVAROSA_XFORMS_NS = 'http://openrosa.org/javarosa';
	const ENKETO_XFORMS_NS = 'http://enketo.org/xforms';

	const parser$1 = new DOMParser();
	let FormModel;
	let Nodeset;

	/**
	 * Class dealing with the XML Model of a form
	 *
	 * @constructor
	 * @param {{modelStr: string, ?instanceStr: string, ?external: <{id: string, xml: xmlDocument }>, ?submitted: boolean }} data:
	 *                            data object containing XML model, 
	 *                            (partial) XML instance to load, 
	 *                            external data array
	 *                            flag to indicate whether data was submitted before
	 * @param {?{?full:boolean}} options Whether to initialize the full model or only the primary instance
	 */
	FormModel = function( data, options ) {

	    if ( typeof data === 'string' ) {
	        data = {
	            modelStr: data
	        };
	    }

	    data.external = data.external || [];
	    data.submitted = ( typeof data.submitted !== 'undefined' ) ? data.submitted : true;
	    options = options || {};
	    options.full = ( typeof options.full !== 'undefined' ) ? options.full : true;

	    this.events = document.createElement( 'div' );
	    this.convertedExpressions = {};
	    this.templates = {};
	    this.loadErrors = [];

	    this.data = data;
	    this.options = options;
	    this.namespaces = {};
	};

	/**
	 * Getter and setter functions
	 * @type {Object}
	 */
	FormModel.prototype = {
	    get version() {
	        return this.evaluate( '/node()/@version', 'string', null, null, true );
	    },
	    /**
	     * Gets the instance ID
	     *
	     * @return {string} instanceID
	     */
	    get instanceID() {
	        return this.getMetaNode( 'instanceID' ).getVal();
	    },
	    /**
	     * Gets the deprecated ID
	     *
	     * @return {string} deprecatedID
	     */
	    get deprecatedID() {
	        return this.getMetaNode( 'deprecatedID' ).getVal() || '';
	    },
	    /**
	     * Gets the instance Name
	     *
	     * @return {string} instanceID
	     */
	    get instanceName() {
	        return this.getMetaNode( 'instanceName' ).getVal();
	    },
	};

	/**
	 * Initializes FormModel
	 */
	FormModel.prototype.init = function() {
	    let id;
	    let i;
	    let instanceDoc;
	    let secondaryInstanceChildren;
	    const that = this;

	    /**
	     * Default namespaces (on a primary instance, instance child, model) would create a problem using the **native** XPath evaluator.
	     * It wouldn't find any regular /path/to/nodes. The solution is to ignore these by renaming these attributes to data-xmlns.
	     *
	     * If the regex is later deemed too aggressive, it could target the model, primary instance and primary instance child only, after creating an XML Document.
	     */
	    this.data.modelStr = this.data.modelStr.replace( /\s(xmlns=("|')[^\s>]+("|'))/g, ' data-$1' );

	    if ( !this.options.full ) {
	        // Strip all secondary instances from string before parsing
	        // This regex works because the model never includes itext in Enketo
	        this.data.modelStr = this.data.modelStr.replace( /^(<model\s*><instance((?!<instance).)+<\/instance\s*>\s*)(<instance.+<\/instance\s*>)*/, '$1' );
	    }

	    // Create the model
	    try {
	        id = 'model';
	        // the default model
	        this.xml = parser$1.parseFromString( this.data.modelStr, 'text/xml' );
	        this.throwParserErrors( this.xml, this.data.modelStr );
	        // add external data to model 
	        this.data.external.forEach( instance => {
	            id = `instance "${instance.id}"` || 'instance unknown';
	            instanceDoc = that.getSecondaryInstance( instance.id );
	            // remove any existing content that is just an XLSForm hack to pass ODK Validate
	            secondaryInstanceChildren = instanceDoc.children;
	            for ( i = secondaryInstanceChildren.length - 1; i >= 0; i-- ) {
	                instanceDoc.removeChild( secondaryInstanceChildren[ i ] );
	            }
	            let rootEl;
	            // instanceof Document is only supported for Enketo Validate. It is not meant to be used otherwise as it could create problems.
	            if ( instance.xml instanceof XMLDocument || instance.xml instanceof Document ) {
	                if ( window.navigator.userAgent.indexOf( 'Trident/' ) >= 0 ) {
	                    // IE does not support importNode
	                    rootEl = that.importNode( instance.xml.documentElement, true );
	                } else {
	                    // Create a clone of the root node
	                    rootEl = that.xml.importNode( instance.xml.documentElement, true );
	                }
	            }
	            if ( rootEl ) {
	                instanceDoc.appendChild( rootEl );
	            }
	        } );

	        // TODO: in the future, we should search for jr://instance/session and 
	        // populate that one. This is just moving in that direction to implement preloads.
	        this.createSession( '__session', this.data.session );
	    } catch ( e ) {
	        console.error( 'parseXML error' );
	        this.loadErrors.push( `Error trying to parse XML ${id}. ${e.message}` );
	    }

	    // Initialize/process the model
	    if ( this.xml ) {
	        try {
	            this.hasInstance = !!this.xml.querySelector( 'model > instance' );
	            this.rootElement = this.xml.querySelector( 'instance > *' ) || this.xml.documentElement;
	            this.setNamespaces();

	            // Check if instanceID is present
	            if ( !this.getMetaNode( 'instanceID' ).getElement() ) {
	                that.loadErrors.push( 'Invalid primary instance. Missing instanceID node.' );
	            }

	            // Check if all secondary instances with an external source have been populated
	            Array.prototype.slice.call( this.xml.querySelectorAll( 'model > instance[src]:empty' ) ).forEach( instance => {
	                that.loadErrors.push( `External instance "${instance.id}" is empty.` );
	            } );

	            this.trimValues();
	            this.extractTemplates();
	        } catch ( e ) {
	            console.error( e );
	            this.loadErrors.push( `${e.name}: ${e.message}` );
	        }
	        // Merge an existing instance into the model, AFTER templates have been removed
	        try {
	            id = 'record';
	            if ( this.data.instanceStr ) {
	                this.mergeXml( this.data.instanceStr );
	            }
	            // Set the two most important meta fields before any field 'dataupdate' event fires.
	            this.setInstanceIdAndDeprecatedId();
	        } catch ( e ) {
	            console.error( e );
	            this.loadErrors.push( `Error trying to parse XML ${id}. ${e.message}` );
	        }
	    }

	    return this.loadErrors;
	};

	FormModel.prototype.throwParserErrors = ( xmlDoc, xmlStr ) => {
	    if ( !xmlDoc || xmlDoc.querySelector( 'parsererror' ) ) {
	        throw new Error( `Invalid XML: ${xmlStr}` );
	    }
	};

	FormModel.prototype.createSession = function( id, sessObj ) {
	    let instance;
	    let session;
	    const model = this.xml.querySelector( 'model' );
	    const fixedProps = [ 'deviceid', 'username', 'email', 'phonenumber', 'simserial', 'subscriberid' ];
	    if ( !model ) {
	        return;
	    }

	    sessObj = ( typeof sessObj === 'object' ) ? sessObj : {};
	    instance = model.querySelector( `instance[id="${id}"]` );

	    if ( !instance ) {
	        instance = parser$1.parseFromString( `<instance id="${id}"/>`, 'text/xml' ).documentElement;
	        this.xml.adoptNode( instance );
	        model.appendChild( instance );
	    }

	    // fixed: /sesssion/context properties
	    fixedProps.forEach( prop => {
	        sessObj[ prop ] = sessObj[ prop ] || readCookie( `__enketo_meta_${prop}` ) || `${prop} not found`;
	    } );

	    session = parser$1.parseFromString( `<session><context>${fixedProps.map( prop => `<${prop}>${sessObj[ prop ]}</${prop}>` ).join( '' )}</context></session>`, 'text/xml' ).documentElement;

	    // TODO: custom properties could be added to /session/user/data or to /session/data

	    this.xml.adoptNode( session );
	    instance.appendChild( session );
	};

	/**
	 * For some unknown reason we cannot use doc.getElementById(id) or doc.querySelector('#'+id)
	 * in IE11. This function is a replacement for this specifically to find a secondary instance.
	 * 
	 * @param  {string} id [description]
	 * @return {Element}    [description]
	 */
	FormModel.prototype.getSecondaryInstance = function( id ) {
	    let instanceEl;

	    [].slice.call( this.xml.querySelectorAll( 'model > instance' ) ).some( el => {
	        const idAttr = el.getAttribute( 'id' );
	        if ( idAttr === id ) {
	            instanceEl = el;
	            return true;
	        } else {
	            return false;
	        }
	    } );

	    return instanceEl;
	};

	/**
	 * Returns a new Nodeset instance
	 *
	 * @param {(string|null)=} selector - [type/description]
	 * @param {(string|number|null)=} index    - [type/description]
	 * @param {(Object|null)=} filter   - [type/description]
	 * @param filter.onlyLeaf
	 * @param filter.noEmpty
	 * @return {Nodeset}
	 */
	FormModel.prototype.node = function( selector, index, filter ) {
	    return new Nodeset( selector, index, filter, this );
	};

	/**
	 * Alternative adoptNode on IE11 (http://stackoverflow.com/questions/1811116/ie-support-for-dom-importnode)
	 * TODO: remove to be replaced by separate IE11-only polyfill file/service
	 */
	FormModel.prototype.importNode = function( node, allChildren ) {
	    let i;
	    let il;
	    switch ( node.nodeType ) {
	        case document.ELEMENT_NODE:
	            {
	                const newNode = document.createElementNS( node.namespaceURI, node.nodeName );
	                if ( node.attributes && node.attributes.length > 0 ) {
	                    for ( i = 0, il = node.attributes.length; i < il; i++ ) {
	                        const attr = node.attributes[ i ];
	                        if ( attr.namespaceURI ) {
	                            newNode.setAttributeNS( attr.namespaceURI, attr.nodeName, node.getAttributeNS( attr.namespaceURI, attr.localName ) );
	                        } else {
	                            newNode.setAttribute( attr.nodeName, node.getAttribute( attr.nodeName ) );
	                        }
	                    }
	                }
	                if ( allChildren && node.children.length ) {
	                    for ( i = 0, il = node.children.length; i < il; i++ ) {
	                        newNode.appendChild( this.importNode( node.children[ i ], allChildren ) );
	                    }
	                }
	                if ( !node.children.length && node.textContent ) {
	                    newNode.textContent = node.textContent;
	                }
	                return newNode;
	            }
	        case document.TEXT_NODE:
	        case document.CDATA_SECTION_NODE:
	        case document.COMMENT_NODE:
	            return document.createTextNode( node.nodeValue );
	    }
	};
	/**
	 * Merges an XML instance string into the XML Model
	 *
	 * @param  {string} recordStr The XML record as string
	 * @param  {string} modelDoc  The XML model to merge the record into
	 */
	FormModel.prototype.mergeXml = function( recordStr ) {
	    let modelInstanceChildStr;
	    let merger;
	    let modelInstanceEl;
	    let modelInstanceChildEl;
	    let mergeResultDoc;
	    const that = this;
	    let templateEls;
	    let record;

	    if ( !recordStr ) {
	        return;
	    }

	    modelInstanceEl = this.xml.querySelector( 'instance' );
	    modelInstanceChildEl = this.xml.querySelector( 'instance > *' ); // do not use firstChild as it may find a #textNode

	    if ( !modelInstanceChildEl ) {
	        throw new Error( 'Model is corrupt. It does not contain a childnode of instance' );
	    }

	    /** 
	     * A Namespace merge problem occurs when ODK decides to invent a new namespace for a submission
	     * that is different from the XForm model namespace... So we just remove this nonsense.
	     */
	    recordStr = recordStr.replace( /\s(xmlns=("|')[^\s>]+("|'))/g, '' );
	    /**
	     * Comments aren't merging in document order (which would be impossible also). 
	     * This may mess up repeat functionality, so until we actually need
	     * comments, we simply remove them (multiline comments are probably not removed, but we don't care about them).
	     */
	    recordStr = recordStr.replace( /<!--[^>]*-->/g, '' );
	    record = parser$1.parseFromString( recordStr, 'text/xml' );

	    /**
	     * Normally records will not contain the special "jr:template" attribute. However, we should still be able to deal with
	     * this if they do, including the old hacked non-namespaced "template" attribute. 
	     * https://github.com/enketo/enketo-core/issues/376
	     * 
	     * The solution if these are found is to delete the node.
	     * 
	     * Since the record is not a FormModel instance we revert to a very aggressive querySelectorAll that selects all 
	     * nodes with a template attribute name IN ANY NAMESPACE.
	     */

	    templateEls = record.querySelectorAll( '[*|template]' );

	    for ( let i = 0; i < templateEls.length; i++ ) {
	        templateEls[ i ].remove();
	    }

	    /**
	     * To comply with quirky behaviour of repeats in XForms, we manually create the correct number of repeat instances
	     * before merging. This resolves these two issues:
	     *  a) Multiple repeat instances in record are added out of order when merged into a record that contains fewer 
	     *     repeat instances, see https://github.com/kobotoolbox/enketo-express/issues/223
	     *  b) If a repeat node is missing from a repeat instance (e.g. the 2nd) in a record, and that repeat instance is not 
	     *     in the model, that node will be missing in the result.
	     */
	    // TODO: ES6 for (var node of record.querySelectorAll('*')){}
	    Array.prototype.slice.call( record.querySelectorAll( '*' ) )
	        .forEach( node => {
	            let path;
	            let repeatIndex = 0;
	            let positionedPath;
	            let repeatParts;
	            try {
	                path = that.getXPath( node, 'instance', false );
	                // If this is a templated repeat (check templates)
	                // or a repeat without templates
	                if ( typeof that.templates[ path ] !== 'undefined' || that.getRepeatIndex( node ) > 0 ) {
	                    positionedPath = that.getXPath( node, 'instance', true );
	                    if ( !that.evaluate( positionedPath, 'node', null, null, true ) ) {
	                        repeatParts = positionedPath.match( /([^[]+)\[(\d+)\]\//g );
	                        // If the positionedPath has a non-0 repeat index followed by (at least) 1 node, avoid cloning out of order.
	                        if ( repeatParts && repeatParts.length > 0 ) {
	                            // TODO: Does this work for triple-nested repeats. I don't really care though.
	                            // repeatIndex of immediate parent repeat of deepest nested repeat in positionedPath
	                            repeatIndex = repeatParts[ repeatParts.length - 1 ].match( /\[(\d+)\]/ )[ 1 ] - 1;
	                        }
	                        that.addRepeat( path, repeatIndex, true );
	                    }
	                }
	            } catch ( e ) {
	                console.log( 'Ignored error:', e );
	            }
	        } );

	    /** 
	     * Any default values in the model, may have been emptied in the record.
	     * MergeXML will keep those default values, which would be bad, so we manually clear defaults before merging.
	     */
	    // first find all empty leaf nodes in record
	    Array.prototype.slice.call( record.querySelectorAll( '*' ) )
	        .filter( recordNode => {
	            const val = recordNode.textContent;
	            return recordNode.children.length === 0 && val.trim().length === 0;
	        } )
	        .forEach( leafNode => {
	            const path = that.getXPath( leafNode, 'instance', true );
	            const instanceNode = that.node( path, 0 ).getElement();
	            if ( instanceNode ) {
	                // TODO: after dropping support for IE11, we can also use instanceNode.children.length
	                if ( that.evaluate( './*', 'nodes', path, 0, true ).length === 0 ) {
	                    // Select all text nodes (excluding repeat COMMENT nodes!)
	                    that.evaluate( './text()', 'nodes', path, 0, true ).forEach( node => {
	                        node.textContent = '';
	                    } );
	                } else {
	                    // If the node in the default instance is a group (empty in record, so appears to be a leaf node
	                    // but isn't), empty all true leaf node descendants.
	                    that.evaluate( './/*[not(*)]', 'nodes', path, 0, true ).forEach( node => {
	                        node.textContent = '';
	                    } );
	                }
	            }
	        } );

	    merger = new mergexml( {
	        join: false
	    } );

	    modelInstanceChildStr = ( new XMLSerializer() ).serializeToString( modelInstanceChildEl );
	    recordStr = ( new XMLSerializer() ).serializeToString( record );

	    // first the model, to preserve DOM order of that of the default instance
	    merger.AddSource( modelInstanceChildStr );
	    // then merge the record into the model
	    merger.AddSource( recordStr );

	    if ( merger.error.code ) {
	        throw new Error( merger.error.text );
	    }

	    /**
	     * Beware: merge.Get(0) returns an ActiveXObject in IE11. We turn this 
	     * into a proper XML document by parsing the XML string instead.
	     */
	    mergeResultDoc = parser$1.parseFromString( merger.Get( 1 ), 'text/xml' );

	    /** 
	     * To properly show 0 repeats, if the form definition contains multiple default instances
	     * and the record contains none, we have to iterate trough the templates object, and
	     * 1. check for each template path, whether the record contained more than 0 of these nodes
	     * 2. remove all nodes on that path if the answer was no.
	     *
	     * Since this requires complex handcoded XForms it is unlikely to ever be needed, so I left this
	     * functionality out.
	     */

	    // Remove the primary instance childnode from the original model
	    this.xml.querySelector( 'instance' ).removeChild( modelInstanceChildEl );
	    // checking if IE
	    if ( window.navigator.userAgent.indexOf( 'Trident/' ) >= 0 ) {
	        // IE does not support adoptNode
	        modelInstanceChildEl = this.importNode( mergeResultDoc.documentElement, true );
	    } else {
	        // adopt the merged instance childnode
	        modelInstanceChildEl = this.xml.adoptNode( mergeResultDoc.documentElement, true );
	    }
	    // append the adopted node to the primary instance
	    modelInstanceEl.appendChild( modelInstanceChildEl );
	    // reset the rootElement
	    this.rootElement = modelInstanceChildEl;

	};

	/**
	 * Creates an XPath from a node
	 * @param { XMLElement} node XML node
	 * @param  {string=} rootNodeName   if absent the root is #document
	 * @param  {boolean=} includePosition whether or not to include the positions /path/to/repeat[2]/node
	 * @return {string}                 XPath
	 */
	FormModel.prototype.getXPath = function( node, rootNodeName, includePosition ) {
	    let index;
	    const steps = [];
	    let position = '';
	    if ( !node || node.nodeType !== 1 ) {
	        return null;
	    }
	    const nodeName = node.nodeName;
	    let parent = node.parentElement;
	    let parentName = parent ? parent.nodeName : null;

	    rootNodeName = rootNodeName || '#document';
	    includePosition = includePosition || false;

	    if ( includePosition ) {
	        index = this.getRepeatIndex( node );
	        if ( index > 0 ) {
	            position = `[${index + 1}]`;
	        }
	    }

	    steps.push( nodeName + position );

	    while ( parent && parentName !== rootNodeName && parentName !== '#document' ) {
	        if ( includePosition ) {
	            index = this.getRepeatIndex( parent );
	            position = ( index > 0 ) ? `[${index + 1}]` : '';
	        }
	        steps.push( parentName + position );
	        parent = parent.parentElement;
	        parentName = parent ? parent.nodeName : null;
	    }

	    return `/${steps.reverse().join( '/' )}`;
	};

	/** 
	 * Obtains the index of a repeat instance within its own series.
	 * 
	 * @param  {[type]} node [description]
	 * @return {[type]}      [description]
	 */
	FormModel.prototype.getRepeatIndex = node => {
	    let index = 0;
	    const nodeName = node.nodeName;
	    let prevSibling = node.previousSibling;

	    while ( prevSibling ) {
	        // ignore any sibling text and comment nodes (e.g. whitespace with a newline character)
	        if ( prevSibling.nodeName && prevSibling.nodeName === nodeName ) {
	            index++;
	        }
	        prevSibling = prevSibling.previousSibling;
	    }

	    return index;
	};

	/**
	 * Trims values
	 * 
	 */
	FormModel.prototype.trimValues = function() {
	    this.node( null, null, {
	        noEmpty: true
	    } ).getElements().forEach( element => {
	        element.textContent = element.textContent.trim();
	    } );
	};

	/**
	 * [deprecateId description]
	 * @return {[type]} [description]
	 */
	FormModel.prototype.setInstanceIdAndDeprecatedId = function() {
	    let instanceIdObj;
	    let instanceIdEl;
	    let deprecatedIdEl;
	    let metaEl;
	    let instanceIdExistingVal;

	    instanceIdObj = this.getMetaNode( 'instanceID' );
	    instanceIdEl = instanceIdObj.getElement();
	    instanceIdExistingVal = instanceIdObj.getVal();

	    if ( this.data.instanceStr && this.data.submitted ) {
	        deprecatedIdEl = this.getMetaNode( 'deprecatedID' ).getElement();

	        // set the instanceID value to empty
	        instanceIdEl.textContent = '';

	        // add deprecatedID node if necessary
	        if ( !deprecatedIdEl ) {
	            deprecatedIdEl = parser$1.parseFromString( '<deprecatedID/>', 'text/xml' ).documentElement;
	            this.xml.adoptNode( deprecatedIdEl );
	            metaEl = this.xml.querySelector( '* > meta' );
	            metaEl.appendChild( deprecatedIdEl );
	        }
	    }

	    if ( !instanceIdObj.getVal() ) {
	        instanceIdObj.setVal( this.evaluate( 'concat("uuid:", uuid())', 'string' ) );
	    }

	    // after setting instanceID, give deprecatedID element the old value of the instanceId
	    // ensure dataupdate event fires by using setVal
	    if ( deprecatedIdEl ) {
	        this.getMetaNode( 'deprecatedID' ).setVal( instanceIdExistingVal );
	    }
	};

	FormModel.prototype.bindJsEvaluator = bindJsEvaluator;

	FormModel.prototype.getMetaNode = function( localName ) {
	    const orPrefix = this.getNamespacePrefix( OPENROSA_XFORMS_NS );
	    let n = this.node( `/*/${orPrefix}:meta/${orPrefix}:${localName}` );

	    if ( !n.getElement() ) {
	        n = this.node( `/*/meta/${localName}` );
	    }

	    return n;
	};

	FormModel.prototype.getRepeatCommentText = path => {
	    path = path.trim();
	    return REPEAT_COMMENT_PREFIX + path;
	};

	FormModel.prototype.getRepeatCommentSelector = function( repeatPath ) {
	    return `//comment()[self::comment()="${this.getRepeatCommentText( repeatPath )}"]`;
	};

	FormModel.prototype.getRepeatCommentEl = function( repeatPath, repeatSeriesIndex ) {
	    return this.evaluate( this.getRepeatCommentSelector( repeatPath ), 'nodes', null, null, true )[ repeatSeriesIndex ];
	};

	/**
	 * Adds a <repeat>able instance node in a particular series of a repeat.
	 *
	 * @param  {string} repeatPath absolute path of a repeat 
	 * @param  {number} repeatSeriesIndex    index of the repeat series that gets a new repeat (this is always 0 for non-nested repeats)
	 * @param  {boolean} merge   whether this operation is part of a merge operation (won't send dataupdate event, clears all values and 
	 *                           will not add ordinal attributes as these should be provided in the record)
	 */
	FormModel.prototype.addRepeat = function( repeatPath, repeatSeriesIndex, merge ) {
	    let templateClone;
	    const that = this;

	    if ( !this.templates[ repeatPath ] ) {
	        // This allows the model itself without requiring the controller to cal call .extractFakeTemplates()
	        // to extract non-jr:templates by assuming that addRepeat would only called for a repeat.
	        this.extractFakeTemplates( [ repeatPath ] );
	    }

	    const template = this.templates[ repeatPath ];
	    const repeatSeries = this.getRepeatSeries( repeatPath, repeatSeriesIndex );
	    const insertAfterNode = repeatSeries.length ? repeatSeries[ repeatSeries.length - 1 ] : this.getRepeatCommentEl( repeatPath, repeatSeriesIndex );

	    // if not exists and not a merge operation
	    if ( !merge ) {
	        repeatSeries.forEach( el => {
	            that.addOrdinalAttribute( el, repeatSeries[ 0 ] );
	        } );
	    }

	    /**
	     * If templatenodes and insertAfterNode(s) have been identified 
	     */
	    if ( template && insertAfterNode ) {
	        templateClone = template.cloneNode( true );
	        insertAfterNode.after( templateClone );

	        this.removeOrdinalAttributes( templateClone );
	        // We should not automatically add ordinal attributes for an existing record as the ordinal values cannot be determined. 
	        // They should be provided in the instanceStr (record).
	        if ( !merge ) {
	            this.addOrdinalAttribute( templateClone, repeatSeries[ 0 ] );
	        }

	        // If part of a merge operation (during form load) where the values will be populated from the record, defaults are not desired.
	        if ( merge ) {
	            Array.prototype.slice.call( templateClone.querySelectorAll( '*' ) )
	                .filter( node => node.children.length === 0 )
	                .forEach( node => { node.textContent = ''; } );
	        }

	        // Note: the addrepeat eventhandler in Form.js takes care of initializing branches etc, so no need to fire an event here.
	    } else {
	        console.error( 'Could not find template node and/or node to insert the clone after' );
	    }
	};

	FormModel.prototype.addOrdinalAttribute = function( repeat, firstRepeatInSeries ) {
	    const enkNs = this.getNamespacePrefix( ENKETO_XFORMS_NS );
	    firstRepeatInSeries = firstRepeatInSeries || repeat;
	};

	FormModel.prototype.removeOrdinalAttributes = el => {
	};

	/**
	 * Obtains a single series of repeat element;
	 * 
	 * @param  {string} repeatPath        The absolute path of the repeat.
	 * @param  {number} repeatSeriesIndex The index of the series of that repeat.
	 * @return {<Element>}                Array of all repeat elements in a series.
	 */
	FormModel.prototype.getRepeatSeries = function( repeatPath, repeatSeriesIndex ) {
	    let pathSegments;
	    let nodeName;
	    let checkEl;
	    const repeatCommentEl = this.getRepeatCommentEl( repeatPath, repeatSeriesIndex );
	    const result = [];

	    // RepeatCommentEl is null if the requested repeatseries is a nested repeat and its ancestor repeat
	    // has 0 instances.
	    if ( repeatCommentEl ) {
	        pathSegments = repeatCommentEl.textContent.substr( REPEAT_COMMENT_PREFIX.length ).split( '/' );
	        nodeName = pathSegments[ pathSegments.length - 1 ];
	        checkEl = repeatCommentEl.nextSibling;

	        // then add all subsequent repeats
	        while ( checkEl ) {
	            // Ignore any sibling text and comment nodes (e.g. whitespace with a newline character)
	            // also deal with repeats that have non-repeat siblings in between them, event though that would be a bug.
	            if ( checkEl.nodeName && checkEl.nodeName === nodeName ) {
	                result.push( checkEl );
	            }
	            checkEl = checkEl.nextSibling;
	        }
	    }

	    return result;
	};

	FormModel.prototype.hasPreviousSiblingElementSameName = el => {
	    let found = false;
	    const nodeName = el.nodeName;
	    el = el.previousSibling;

	    while ( el ) {
	        // Ignore any sibling text and comment nodes (e.g. whitespace with a newline character)
	        // also deal with repeats that have non-repeat siblings in between them, event though that would be a bug.
	        if ( el.nodeName && el.nodeName === nodeName ) {
	            found = true;
	            break;
	        }
	        el = el.previousSibling;
	    }
	    return found;
	};

	FormModel.prototype.hasPreviousCommentSiblingWithContent = ( node, content ) => {
	    let found = false;
	    node = node.previousSibling;

	    while ( node ) {
	        if ( node.nodeType === Node.COMMENT_NODE && node.textContent === content ) {
	            found = true;
	            break;
	        }
	        node = node.previousSibling;
	    }
	    return found;
	};

	/**
	 * Determines the index of a repeated node amongst all nodes with the same XPath selector
	 *
	 * @param  {Element} element element
	 * @return {number}       [description]
	 */
	FormModel.prototype.determineIndex = function( element ) {
	    const that = this;

	    if ( element ) {
	        const nodeName = element.nodeName;
	        const path = this.getXPath( element, 'instance' );
	        const family = Array.prototype.slice.call( this.xml.querySelectorAll( nodeName.replace( /\./g, '\\.' ) ) )
	            .filter( node => path === that.getXPath( node, 'instance' ) );
	        return family.length === 1 ? null : family.indexOf( element );
	    } else {
	        console.error( 'no node, or multiple nodes, provided to determineIndex function' );
	        return -1;
	    }
	};

	/**
	 * Extracts all templates from the model and stores them in a Javascript object poperties as Jquery collections
	 * @return {[type]} [description]
	 */
	FormModel.prototype.extractTemplates = function() {
	    const that = this;

	    // in reverse document order to properly deal with nested repeat templates
	    this.getTemplateNodes().reverse().forEach( templateEl => {
	        const xPath = that.getXPath( templateEl, 'instance' );
	        that.addTemplate( xPath, templateEl );
	        /*
	         * Nested repeats that have a template attribute are correctly add to that.templates.
	         * The template of the repeat ancestor of the nested repeat contains the correct comment.
	         * However, since the ancestor repeat (template)
	         */
	        templateEl.remove();
	    } );
	};

	FormModel.prototype.extractFakeTemplates = function( repeatPaths ) {
	    const that = this;
	    let repeat;

	    repeatPaths.forEach( repeatPath => {
	        // Filter by elements that are the first in a series. This means that multiple instances of nested repeats
	        // all get a comment insertion point.
	        repeat = that.evaluate( repeatPath, 'node', null, null, true );
	        if ( repeat ) {
	            that.addTemplate( repeatPath, repeat, true );
	        }
	    } );
	};

	FormModel.prototype.addRepeatComments = function( repeatPath ) {
	    const comment = this.getRepeatCommentText( repeatPath );
	    const that = this;
	    // Find all repeat series.
	    this.evaluate( repeatPath, 'nodes', null, null, true ).forEach( repeat => {
	        if ( !that.hasPreviousSiblingElementSameName( repeat ) && !that.hasPreviousCommentSiblingWithContent( repeat, comment ) ) {
	            // Add a comment to the primary instance that serves as an insertion point for each repeat series,
	            repeat.before( document.createComment( comment ) );
	        }
	    } );
	};

	FormModel.prototype.addTemplate = function( repeatPath, repeat, empty ) {
	    this.addRepeatComments( repeatPath );

	    if ( !this.templates[ repeatPath ] ) {
	        const clone = repeat.cloneNode( true );
	        clone.removeAttribute( 'template' );
	        clone.removeAttribute( 'jr:template' );
	        if ( empty ) {
	            Array.prototype.slice.call( clone.querySelectorAll( '*' ) )
	                .filter( node => node.children.length === 0 )
	                .forEach( node => {
	                    node.textContent = '';
	                } );
	        }
	        // Add to templates object.
	        this.templates[ repeatPath ] = clone;
	    }
	};

	FormModel.prototype.getTemplateNodes = function() {
	    const jrPrefix = this.getNamespacePrefix( JAVAROSA_XFORMS_NS );
	    // For now we support both the official namespaced template and the hacked non-namespaced template attributes
	    // Note: due to an MS Edge bug, we use the slow JS XPath evaluator here. It would be VERY GOOD for performance 
	    // to switch back once the Edge bug is fixed. The bug results in not finding any templates.
	    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9544701/
	    return this.evaluate( `/model/instance[1]/*//*[@template] | /model/instance[1]/*//*[@${jrPrefix}:template]`, 'nodes', null, null, false );
	};

	/**
	 * Obtains a cleaned up string of the data instance
	 *
	 * @return {string}           XML string
	 */
	FormModel.prototype.getStr = function() {
	    let dataStr = ( new XMLSerializer() ).serializeToString( this.xml.querySelector( 'instance > *' ) || this.xml.documentElement, 'text/xml' );
	    // restore default namespaces
	    dataStr = dataStr.replace( /\s(data-)(xmlns=("|')[^\s>]+("|'))/g, ' $2' );
	    // remove repeat comments
	    dataStr = dataStr.replace( new RegExp( `<!--${REPEAT_COMMENT_PREFIX}\\/[^>]+-->`, 'g' ), '' );
	    // If not IE, strip duplicate namespace declarations. IE doesn't manage to add a namespace declaration to the root element.
	    if ( navigator.userAgent.indexOf( 'Trident/' ) === -1 ) {
	        dataStr = this.removeDuplicateEnketoNsDeclarations( dataStr );
	    }
	    return dataStr;
	};

	FormModel.prototype.removeDuplicateEnketoNsDeclarations = function( xmlStr ) {
	    let i = 0;
	    const declarationExp = new RegExp( `( xmlns:${this.getNamespacePrefix( ENKETO_XFORMS_NS )}="${ENKETO_XFORMS_NS}")`, 'g' );
	    return xmlStr.replace( declarationExp, match => {
	        i++;
	        if ( i > 1 ) {
	            return '';
	        } else {
	            return match;
	        }
	    } );
	};

	/**
	 * There is a huge historic issue (stemming from JavaRosa) that has resulted in the usage of incorrect formulae 
	 * on nodes inside repeat nodes.
	 * Those formulae use absolute paths when relative paths should have been used. See more here:
	 * http://opendatakit.github.io/odk-xform-spec/#a-big-deviation-with-xforms
	 *
	 * Tools such as pyxform also build forms in this incorrect manner. See https://github.com/modilabs/pyxform/issues/91
	 * It will take time to correct this so makeBugCompliant() aims to mimic the incorrect
	 * behaviour by injecting the 1-based [position] of repeats into the XPath expressions. The resulting expression
	 * will then be evaluated in a way users expect (as if the paths were relative) without having to mess up
	 * the XPath Evaluator.
	 *
	 * E.g. '/data/rep_a/node_a' could become '/data/rep_a[2]/node_a' if the context is inside
	 * the second rep_a repeat.
	 *
	 * This function should be removed when we can reasonbly expect not many 'old XForms' to be in use any more.
	 * 
	 * Already it should leave proper XPaths untouched.
	 *
	 * @param  {string} expr        the XPath expression
	 * @param  {string} selector    of the (context) node on which expression is evaluated
	 * @param  {number} index       of the instance node with that selector
	 */
	FormModel.prototype.makeBugCompliant = function( expr, selector, index ) {
	    let target = this.node( selector, index ).getElement();

	    // target is null for nested repeats if no repeats exist
	    if ( !target ) {
	        return expr;
	    }

	    const parents = [ target ];
	    const that = this;

	    while ( target && target.parentElement && target.nodeName.toLowerCase() !== 'instance' ) {
	        target = target.parentElement;
	        parents.push( target );
	    }

	    // traverse collection in reverse
	    parents.forEach( element => {
	        // escape any dots in the node name
	        const nodeName = element.nodeName.replace( /\./g, '\\.' );
	        const siblingsAndSelf = getSiblingElementsAndSelf( element, `${nodeName}:not([template])` );

	        // if the node is a repeat node that has been cloned at least once (i.e. if it has siblings with the same nodeName)
	        if ( siblingsAndSelf.length > 1 ) {
	            const parentSelector = that.getXPath( element, 'instance' );
	            const parentIndex = siblingsAndSelf.indexOf( element );
	            // Add position to segments that do not have an XPath predicate.
	            expr = expr.replace( new RegExp( `${parentSelector}/`, 'g' ), `${parentSelector}[${parentIndex + 1}]/` );
	        }
	    } );

	    return expr;
	};

	FormModel.prototype.setNamespaces = function() {
	    /**
	     * Passing through all nodes would be very slow with an XForms model that contains lots of nodes such as large secondary instances. 
	     * (The namespace XPath axis is not support in native browser XPath evaluators unfortunately).
	     * 
	     * For now it has therefore been restricted to only look at the top-level node in the primary instance and in the secondary instances.
	     * We can always expand that later.
	     */
	    const start = this.hasInstance ? '/model/instance' : '';
	    const nodes = this.evaluate( `${start}/*`, 'nodes', null, null, true );
	    const that = this;
	    let prefix;

	    nodes.forEach( node => {
	        if ( node.hasAttributes() ) {
	            Array.from( node.attributes ).forEach( attribute => {
	                if ( attribute.name.indexOf( 'xmlns:' ) === 0 ) {
	                    that.namespaces[ attribute.name.substring( 6 ) ] = attribute.value;
	                }
	            } );
	        }
	        // add required namespaces to resolver and document if they are missing
	        [
	            [ 'orx', OPENROSA_XFORMS_NS, false ],
	            [ 'jr', JAVAROSA_XFORMS_NS, false ],
	            [ 'enk', ENKETO_XFORMS_NS, config.repeatOrdinals === true ]
	        ].forEach( arr => {
	            if ( !that.getNamespacePrefix( arr[ 1 ] ) ) {
	                prefix = ( !that.namespaces[ arr[ 0 ] ] ) ? arr[ 0 ] : `__${arr[ 0 ]}`;
	                // add to resolver
	                that.namespaces[ prefix ] = arr[ 1 ];
	                // add to document
	                if ( arr[ 2 ] ) {
	                    node.setAttributeNS( 'http://www.w3.org/2000/xmlns/', `xmlns:${prefix}`, arr[ 1 ] );
	                }
	            }
	        } );
	    } );

	};

	FormModel.prototype.getNamespacePrefix = function( namespace ) {
	    const found = Object.entries( this.namespaces ).find( arr => arr[ 1 ] === namespace );
	    return found ? found[ 0 ] : undefined;


	};

	FormModel.prototype.getNsResolver = function() {
	    const namespaces = ( typeof this.namespaces === 'undefined' ) ? {} : this.namespaces;

	    return {
	        lookupNamespaceURI( prefix ) {
	            return namespaces[ prefix ] || null;
	        }
	    };
	};


	/**
	 * Shift root to first instance for all absolute paths not starting with /model
	 *
	 * @param  {string} expr original expression
	 * @return {string}      new expression
	 */
	FormModel.prototype.shiftRoot = function( expr ) {
	    const LITERALS = /"([^"]*)(")|'([^']*)(')/g;
	    if ( this.hasInstance ) {
	        // Encode all string literals in order to exclude them, without creating a monsterly regex
	        expr = expr.replace( LITERALS, ( m, p1, p2, p3, p4 ) => {
	            const encoded = typeof p1 !== 'undefined' ? encodeURIComponent( p1 ) : encodeURIComponent( p3 );
	            const quote = p2 || p4;
	            return quote + encoded + quote;
	        } );
	        // Insert /model/instance[1]
	        expr = expr.replace( /^(\/(?!model\/)[^/][^/\s,"']*\/)/g, '/model/instance[1]$1' );
	        expr = expr.replace( /([^a-zA-Z0-9.\])/*_-])(\/(?!model\/)[^/][^/\s,"']*\/)/g, '$1/model/instance[1]$2' );
	        // Decode string literals
	        expr = expr.replace( LITERALS, ( m, p1, p2, p3, p4 ) => {
	            const decoded = typeof p1 !== 'undefined' ? decodeURIComponent( p1 ) : decodeURIComponent( p3 );
	            const quote = p2 || p4;
	            return quote + decoded + quote;
	        } );
	    }
	    return expr;
	};

	/** 
	 * Replace instance('id') with an absolute path
	 * Doing this here instead of adding an instance() function to the XPath evaluator, means we can keep using
	 * the much faster native evaluator in most cases!
	 *
	 * @param  {string} expr original expression
	 * @return {string}      new expression
	 */
	FormModel.prototype.replaceInstanceFn = function( expr ) {
	    let prefix;
	    const that = this;

	    // TODO: would be more consistent to use utls.parseFunctionFromExpression() and utils.stripQuotes
	    return expr.replace( INSTANCE, ( match, quote, id ) => {
	        prefix = `/model/instance[@id="${id}"]`;
	        // check if referred instance exists in model
	        if ( that.evaluate( prefix, 'nodes', null, null, true ).length ) {
	            return prefix;
	        } else {
	            throw new FormLogicError( `instance "${id}" does not exist in model` );
	        }
	    } );
	};

	/** 
	 * Replaces current() with /absolute/path/to/node to ensure the context is shifted to the primary instance
	 * 
	 * Doing this here instead of adding a current() function to the XPath evaluator, means we can keep using
	 * the much faster native evaluator in most cases!
	 *
	 * Root will be shifted, and repeat positions injected, **later on**, so it's not included here.
	 *
	 * @param  {string} expr            original expression
	 * @param  {string} contextSelector context selector 
	 * @return {string}                 new expression
	 */
	FormModel.prototype.replaceCurrentFn = ( expr, contextSelector ) => {
	    // relative paths
	    if ( contextSelector ) {
	        expr = expr.replace( 'current()/.', `${contextSelector}/.` );
	    }
	    // absolute paths
	    expr = expr.replace( 'current()/', '/' );

	    return expr;
	};

	/**
	 * Replaces indexed-repeat(node, path, position, path, position, etc) substrings by converting them
	 * to their native XPath equivalents using [position() = x] predicates
	 *
	 * @param  {string} expr the XPath expression
	 * @return {string}      converted XPath expression
	 */
	FormModel.prototype.replaceIndexedRepeatFn = function( expr, selector, index ) {
	    const that = this;
	    const indexedRepeats = parseFunctionFromExpression( expr, 'indexed-repeat' );

	    indexedRepeats.forEach( indexedRepeat => {
	        let i, positionedPath;
	        let position;
	        const params = indexedRepeat[ 1 ];

	        if ( params.length % 2 === 1 ) {

	            positionedPath = params[ 0 ];

	            for ( i = params.length - 1; i > 1; i -= 2 ) {
	                // The position will become an XPath predicate. The context for an XPath predicate, is not the same
	                // as the context for the complete expression, so we have to evaluate the position separately. Otherwise 
	                // relative paths would break.
	                position = !isNaN( params[ i ] ) ? params[ i ] : that.evaluate( params[ i ], 'number', selector, index, true );
	                positionedPath = positionedPath.replace( params[ i - 1 ], `${params[ i - 1 ]}[position() = ${position}]` );
	            }

	            expr = expr.replace( indexedRepeat[ 0 ], positionedPath );

	        } else {
	            throw new FormLogicError( `indexed repeat with incorrect number of parameters found: ${indexedRepeat[ 0 ]}` );
	        }
	    } );

	    return expr;
	};

	FormModel.prototype.replaceVersionFn = function( expr ) {
	    const that = this;
	    let version;
	    const versions = parseFunctionFromExpression( expr, 'version' );

	    versions.forEach( versionPart => {
	        version = version || that.evaluate( '/node()/@version', 'string', null, 0, true );
	        // ignore arguments
	        expr = expr.replace( versionPart[ 0 ], `"${version}"` );
	    } );

	    return expr;
	};

	FormModel.prototype.replacePullDataFn = function( expr, selector, index ) {
	    let pullDataResult;
	    const that = this;
	    const replacements = this.convertPullDataFn( expr, selector, index );

	    for ( const pullData in replacements ) {
	        if ( replacements.hasOwnProperty( pullData ) ) {
	            // We evaluate this here, so we can use the native evaluator safely. This speeds up pulldata() by about a factor *740*!
	            pullDataResult = that.evaluate( replacements[ pullData ], 'string', selector, index, true );
	            expr = expr.replace( pullData, `"${pullDataResult}"` );
	        }
	    }
	    return expr;
	};

	FormModel.prototype.convertPullDataFn = function( expr, selector, index ) {
	    const that = this;
	    const pullDatas = parseFunctionFromExpression( expr, 'pulldata' );
	    const replacements = {};

	    if ( !pullDatas.length ) {
	        return replacements;
	    }

	    pullDatas.forEach( pullData => {
	        let searchValue;
	        let searchXPath;
	        const params = pullData[ 1 ];

	        if ( params.length === 4 ) {

	            // strip quotes
	            params[ 1 ] = stripQuotes( params[ 1 ] );
	            params[ 2 ] = stripQuotes( params[ 2 ] );

	            // TODO: the 2nd and 3rd parameter could probably also be expressions.

	            // The 4th argument will become an XPath predicate. The context for an XPath predicate, is not the same
	            // as the context for the complete expression, so we have to evaluate the position separately. Otherwise
	            // relative paths would break.
	            searchValue = that.evaluate( params[ 3 ], 'string', selector, index, true );
	            searchValue = searchValue === '' || isNaN( searchValue ) ? `'${searchValue}'` : searchValue;
	            searchXPath = `instance(${params[ 0 ]})/root/item[${params[ 2 ]} = ${searchValue}]/${params[ 1 ]}`;

	            replacements[ pullData[ 0 ] ] = searchXPath;

	        } else {
	            throw new FormLogicError( `pulldata with incorrect number of parameters found: ${pullData[ 0 ]}` );
	        }
	    } );

	    return replacements;
	};

	/**
	 * Evaluates an XPath Expression using XPathJS_javarosa (not native XPath 1.0 evaluator)
	 *
	 * This function does not seem to work properly for nodeset resulttypes otherwise:
	 * muliple nodes can be accessed by returned node.snapshotItem(i)(.textContent)
	 * a single node can be accessed by returned node(.textContent)
	 *
	 * @param  { string }     expr        the expression to evaluate
	 * @param  { string= }    resTypeStr  boolean, string, number, node, nodes (best to always supply this)
	 * @param  { string= }    selector    query selector which will be use to provide the context to the evaluator
	 * @param  { number= }    index       0-based index of selector in document
	 * @param  { boolean= }   tryNative   whether an attempt to try the Native Evaluator is safe (ie. whether it is
	 *                                    certain that there are no date comparisons)
	 * @return { ?(number|string|boolean|Array<element>) } the result
	 */
	FormModel.prototype.evaluate = function( expr, resTypeStr, selector, index, tryNative ) {
	    let j, context, doc, resTypeNum, resultTypes, result, collection, response, repeats, cacheKey, original, cacheable;

	    // console.debug( 'evaluating expr: ' + expr + ' with context selector: ' + selector + ', 0-based index: ' +
	    //    index + ' and result type: ' + resTypeStr );
	    original = expr;
	    tryNative = tryNative || false;
	    resTypeStr = resTypeStr || 'any';
	    index = index || 0;
	    doc = this.xml;
	    repeats = null;

	    if ( selector ) {
	        collection = this.node( selector ).getElements();
	        repeats = collection.length;
	        context = collection[ index ];
	    } else {
	        // either the first data child of the first instance or the first child (for loaded instances without a model)
	        context = this.rootElement;
	    }

	    if ( !context ) {
	        console.error( 'no context element found', selector, index );
	    }

	    // cache key includes the number of repeated context nodes, 
	    // to force a new cache item if the number of repeated changes to > 0
	    // TODO: these cache keys can get quite large. Would it be beneficial to get the md5 of the key?
	    cacheKey = [ expr, selector, index, repeats ].join( '|' );

	    // These functions need to come before makeBugCompliant.
	    // An expression transformation with indexed-repeat or pulldata cannot be cached because in 
	    // "indexed-repeat(node, repeat nodeset, index)" the index parameter could be an expression.
	    expr = this.replaceIndexedRepeatFn( expr, selector, index );
	    expr = this.replacePullDataFn( expr, selector, index );
	    cacheable = ( original === expr );

	    // if no cached conversion exists
	    if ( !this.convertedExpressions[ cacheKey ] ) {
	        expr = expr.trim();
	        expr = this.replaceInstanceFn( expr );
	        expr = this.replaceVersionFn( expr );
	        expr = this.replaceCurrentFn( expr, this.getXPath( context, 'instance', true ) );
	        // shiftRoot should come after replaceCurrentFn
	        expr = this.shiftRoot( expr );
	        // path corrections for repeated nodes: http://opendatakit.github.io/odk-xform-spec/#a-big-deviation-with-xforms
	        if ( repeats && repeats > 1 ) {
	            expr = this.makeBugCompliant( expr, selector, index );
	        }
	        // decode
	        expr = expr.replace( /&lt;/g, '<' );
	        expr = expr.replace( /&gt;/g, '>' );
	        expr = expr.replace( /&quot;/g, '"' );
	        if ( cacheable ) {
	            this.convertedExpressions[ cacheKey ] = expr;
	        }
	    } else {
	        expr = this.convertedExpressions[ cacheKey ];
	    }

	    resultTypes = {
	        0: [ 'any', 'ANY_TYPE' ],
	        1: [ 'number', 'NUMBER_TYPE', 'numberValue' ],
	        2: [ 'string', 'STRING_TYPE', 'stringValue' ],
	        3: [ 'boolean', 'BOOLEAN_TYPE', 'booleanValue' ],
	        7: [ 'nodes', 'ORDERED_NODE_SNAPSHOT_TYPE' ],
	        9: [ 'node', 'FIRST_ORDERED_NODE_TYPE', 'singleNodeValue' ]
	    };

	    // translate typeStr to number according to DOM level 3 XPath constants
	    for ( resTypeNum in resultTypes ) {
	        if ( resultTypes.hasOwnProperty( resTypeNum ) ) {
	            resTypeNum = Number( resTypeNum );
	            if ( resultTypes[ resTypeNum ][ 0 ] === resTypeStr ) {
	                break;
	            } else {
	                resTypeNum = 0;
	            }
	        }
	    }

	    // try native to see if that works... (will not work if the expr contains custom OpenRosa functions)
	    if ( tryNative && typeof doc.evaluate !== 'undefined' && !OPENROSA.test( expr ) ) {
	        try {
	            // console.log( 'trying the blazing fast native XPath Evaluator for', expr, index );
	            result = doc.evaluate( expr, context, this.getNsResolver(), resTypeNum, null );
	        } catch ( e ) {
	            console.log( '%cWell native XPath evaluation did not work... No worries, worth a shot, the expression probably ' +
	                'contained unknown OpenRosa functions or errors:', 'color:orange', expr );
	        }
	    }

	    // if that didn't work, try the slow XPathJS evaluator 
	    if ( !result ) {
	        try {
	            if ( typeof doc.jsEvaluate === 'undefined' ) {
	                this.bindJsEvaluator();
	            }
	            // console.log( 'trying the slow enketo-xpathjs "openrosa" evaluator for', expr, index );
	            result = doc.jsEvaluate( expr, context, this.getNsResolver(), resTypeNum, null );
	        } catch ( e ) {
	            throw new FormLogicError( `Could not evaluate: ${expr}, message: ${e.message}` );
	        }
	    }

	    // get desired value from the result object
	    if ( result ) {
	        // for type = any, see if a valid string, number or boolean is returned
	        if ( resTypeNum === 0 ) {
	            for ( resTypeNum in resultTypes ) {
	                if ( resultTypes.hasOwnProperty( resTypeNum ) ) {
	                    resTypeNum = Number( resTypeNum );
	                    if ( resTypeNum === Number( result.resultType ) && resTypeNum > 0 && resTypeNum < 4 ) {
	                        response = result[ resultTypes[ resTypeNum ][ 2 ] ];
	                        break;
	                    }
	                }
	            }
	            console.error( `Expression: ${expr} did not return any boolean, string or number value as expected` );
	        } else if ( resTypeNum === 7 ) {
	            // response is an array of Elements
	            response = [];
	            for ( j = 0; j < result.snapshotLength; j++ ) {
	                response.push( result.snapshotItem( j ) );
	            }
	        } else {
	            response = result[ resultTypes[ resTypeNum ][ 2 ] ];
	        }
	        return response;
	    }
	};

	/**
	 * Class dealing with nodes and nodesets of the XML instance
	 *
	 * @constructor
	 * @param {string=} selector simpleXPath or jQuery selectedor
	 * @param {number=} index    the index of the target node with that selector
	 * @param {?{onlyLeaf: boolean, noEmpty: boolean}=} filter   filter object for the result nodeset
	 * @param { FormModel } model instance of FormModel
	 */
	Nodeset = function( selector, index, filter, model ) {
	    const defaultSelector = model.hasInstance ? '/model/instance[1]//*' : '//*';

	    this.model = model;
	    this.originalSelector = selector;
	    this.selector = ( typeof selector === 'string' && selector.length > 0 ) ? selector : defaultSelector;
	    filter = ( typeof filter !== 'undefined' && filter !== null ) ? filter : {};
	    this.filter = filter;
	    this.filter.onlyLeaf = ( typeof filter.onlyLeaf !== 'undefined' ) ? filter.onlyLeaf : false;
	    this.filter.noEmpty = ( typeof filter.noEmpty !== 'undefined' ) ? filter.noEmpty : false;
	    this.index = index;
	};

	Nodeset.prototype.getElement = function() {
	    return this.getElements()[ 0 ];
	};

	Nodeset.prototype.getElements = function() {
	    let nodes;
	    let /** @type {string} */ val;

	    // cache evaluation result
	    if ( !this._nodes ) {
	        this._nodes = this.model.evaluate( this.selector, 'nodes', null, null, true );
	        // noEmpty automatically excludes non-leaf nodes
	        if ( this.filter.noEmpty === true ) {
	            this._nodes = this._nodes
	                .filter( node => {
	                    val = node.textContent;
	                    return node.children.length === 0 && val.trim().length > 0;
	                } );
	        }
	        // this may still contain empty leaf nodes
	        else if ( this.filter.onlyLeaf === true ) {
	            this._nodes = this._nodes
	                .filter( node => node.children.length === 0 );
	        }
	    }

	    nodes = this._nodes;

	    if ( typeof this.index !== 'undefined' && this.index !== null ) {
	        nodes = typeof nodes[ this.index ] === 'undefined' ? [] : [ nodes[ this.index ] ];
	    }

	    return nodes;
	};

	/**
	 * Sets the index of the Nodeset instance
	 *
	 * @param {=number?} index The 0-based index
	 */
	Nodeset.prototype.setIndex = function( index ) {
	    this.index = index;
	};

	/**
	 * Sets data node values.
	 *
	 * @param {(string|Array.<string>)=} newVals    The new value of the node.
	 * @param {?string=} xmlDataType XML data type of the node
	 *
	 * @return {?*} wrapping {?boolean}; null is returned when the node is not found or multiple nodes were selected,
	 *                            otherwise an object with update information is returned.
	 */
	Nodeset.prototype.setVal = function( newVals, xmlDataType ) {
	    let /**@type {string}*/ newVal;
	    let updated;
	    let customData;

	    const curVal = this.getVal();

	    if ( typeof newVals !== 'undefined' && newVals !== null ) {
	        newVal = ( Array.isArray( newVals ) ) ? newVals.join( ' ' ) : newVals.toString();
	    } else {
	        newVal = '';
	    }

	    newVal = this.convert( newVal, xmlDataType );
	    const targets = this.getElements();

	    if ( targets.length === 1 && newVal.toString() !== curVal.toString() ) {
	        const target = targets[ 0 ];
	        // first change the value so that it can be evaluated in XPath (validated)
	        target.textContent = newVal.toString();
	        // then return validation result
	        updated = this.getClosestRepeat();
	        updated.nodes = [ target.nodeName ];

	        customData = this.model.getUpdateEventData( target, xmlDataType );
	        updated = ( customData ) ? jquery.extend( {}, updated, customData ) : updated;

	        this.model.events.dispatchEvent( event.DataUpdate( updated ) );

	        //add type="file" attribute for file references
	        if ( xmlDataType === 'binary' ) {
	            if ( newVal.length > 0 ) {
	                target.setAttribute( 'type', 'file' );
	            } else {
	                target.removeAttribute( 'type' );
	            }
	        }
	        return updated;
	    }
	    if ( targets.length > 1 ) {
	        console.error( 'nodeset.setVal expected nodeset with one node, but received multiple' );
	        return null;
	    }
	    if ( targets.length === 0 ) {
	        console.log( `Data node: ${this.selector} with null-based index: ${this.index} not found. Ignored.` );
	        return null;
	    }

	    return null;
	};

	/**
	 * Obtains the data value of the first node.
	 *
	 * @return {string} [description]
	 */
	Nodeset.prototype.getVal = function() {
	    const nodes = this.getElements();
	    return nodes.length ? nodes[ 0 ].textContent : undefined;
	};

	// If repeats have not been cloned yet, they are not considered a repeat by this function
	Nodeset.prototype.getClosestRepeat = function() {
	    let el = this.getElement();
	    let nodeName = el.nodeName;

	    while ( nodeName && nodeName !== 'instance' && !( el.nextElementSibling && el.nextElementSibling.nodeName === nodeName ) && !( el.previousElementSibling && el.previousElementSibling.nodeName === nodeName ) ) {
	        el = el.parentElement;
	        nodeName = el ? el.nodeName : null;
	    }

	    return ( !nodeName || nodeName === 'instance' ) ? {} : {
	        repeatPath: this.model.getXPath( el, 'instance' ),
	        repeatIndex: this.model.determineIndex( el )
	    };
	};

	/**
	 * Remove a repeat node
	 */
	Nodeset.prototype.remove = function() {
	    const dataNode = this.getElement();

	    if ( dataNode ) {
	        const nodeName = dataNode.nodeName;
	        const repeatPath = this.model.getXPath( dataNode, 'instance' );
	        let repeatIndex = this.model.determineIndex( dataNode );
	        const removalEventData = this.model.getRemovalEventData( dataNode );

	        if ( !this.model.templates[ repeatPath ] ) {
	            // This allows the model itseldataNodeout requiring the controller to call .extractFakeTemplates()
	            // to extract non-jr:templates by assuming that node.remove() would only called for a repeat.
	            this.model.extractFakeTemplates( [ repeatPath ] );
	        }
	        // warning: jQuery.next() to be avoided to support dots in the nodename
	        let nextNode = dataNode.nextElementSibling;

	        dataNode.remove();
	        this._nodes = null;

	        // For internal use
	        this.model.events.dispatchEvent( event.DataUpdate( {
	            nodes: null,
	            repeatPath,
	            repeatIndex
	        } ) );

	        // For all next sibling repeats to update formulas that use e.g. position(..)
	        // For internal use
	        while ( nextNode && nextNode.nodeName == nodeName ) {
	            nextNode = nextNode.nextElementSibling;

	            this.model.events.dispatchEvent( event.DataUpdate( {
	                nodes: null,
	                repeatPath,
	                repeatIndex: repeatIndex++
	            } ) );
	        }

	        // For external use, if required with custom data.
	        this.model.events.dispatchEvent( event.Removed( removalEventData ) );

	    } else {
	        console.error( `could not find node ${this.selector} with index ${this.index} to remove ` );
	    }
	};

	/**
	 * Convert a value to a specified data type( though always stringified )
	 * @param  {?string=} x           value to convert
	 * @param  {?string=} xmlDataType XML data type
	 * @return {string}               string representation of converted value
	 */
	Nodeset.prototype.convert = ( x, xmlDataType ) => {
	    if ( x.toString() === '' ) {
	        return x;
	    }
	    if ( typeof xmlDataType !== 'undefined' && xmlDataType !== null &&
	        typeof types[ xmlDataType.toLowerCase() ] !== 'undefined' &&
	        typeof types[ xmlDataType.toLowerCase() ].convert !== 'undefined' ) {
	        return types[ xmlDataType.toLowerCase() ].convert( x );
	    }
	    return x;
	};

	Nodeset.prototype.validate = function( constraintExpr, requiredExpr, xmlDataType ) {
	    const that = this;
	    const result = {};

	    // Avoid checking constraint if required is invalid
	    return this.validateRequired( requiredExpr )
	        .then( passed => {
	            result.requiredValid = passed;
	            return ( passed === false ) ? null : that.validateConstraintAndType( constraintExpr, xmlDataType );
	        } )
	        .then( passed => {
	            result.constraintValid = passed;
	            return result;
	        } );
	};

	/**
	 * Validate a value with an XPath Expression and /or xml data type
	 * @param  {?string=} expr        XPath expression
	 * @param  {?string=} xmlDataType XML datatype
	 * @return {Promise} wrapping a boolean indicating if the value is valid or not; error also indicates invalid field, or problem validating it
	 */
	Nodeset.prototype.validateConstraintAndType = function( expr, xmlDataType ) {
	    const that = this;
	    let value;

	    if ( !xmlDataType || typeof types[ xmlDataType.toLowerCase() ] === 'undefined' ) {
	        xmlDataType = 'string';
	    }

	    // This one weird trick results in a small validation performance increase.
	    // Do not obtain *the value* if the expr is empty and data type is string, select, select1, binary knowing that this will always return true.
	    if ( !expr && ( xmlDataType === 'string' || xmlDataType === 'select' || xmlDataType === 'select1' || xmlDataType === 'binary' ) ) {
	        return Promise.resolve( true );
	    }

	    value = that.getVal();

	    if ( value.toString() === '' ) {
	        return Promise.resolve( true );
	    }

	    return Promise.resolve()
	        .then( () => types[ xmlDataType.toLowerCase() ].validate( value ) )
	        .then( typeValid => {
	            const exprValid = ( typeof expr !== 'undefined' && expr !== null && expr.length > 0 ) ? that.model.evaluate( expr, 'boolean', that.originalSelector, that.index ) : true;

	            return ( typeValid && exprValid );
	        } );
	};

	// TODO: rename to isTrue?
	Nodeset.prototype.isRequired = function( expr ) {
	    return !expr || expr.trim() === 'false()' ? false : expr.trim() === 'true()' || this.model.evaluate( expr, 'boolean', this.originalSelector, this.index );
	};

	Nodeset.prototype.validateRequired = function( expr ) {
	    const that = this;

	    // if the node has a value or there is no required expression
	    if ( !expr || this.getVal() ) {
	        return Promise.resolve( true );
	    }

	    // if the node does not have a value and there is a required expression
	    return Promise.resolve()
	        .then( () => // if the expression evaluates to true, the field is required, and the function returns false.
	            !that.isRequired( expr ) );
	};

	// Placeholder function meant to be overwritten
	FormModel.prototype.getUpdateEventData = () => /*node, type*/ {};

	// Placeholder function meant to be overwritten
	FormModel.prototype.getRemovalEventData = () => /* node */ {};

	// Expose types to facilitate extending with custom types
	FormModel.prototype.types = types;

	// This is NOT a complete list of all enketo-core UI strings. Use a parser to find 
	// all strings. E.g. https://github.com/i18next/i18next-parser
	const SOURCE_STRINGS = {
	    'constraint': {
	        'invalid': 'Value not allowed',
	        'required': 'This field is required'
	    },
	    'esri-geopicker': {
	        'coordinate-mgrs': 'MGRS coordinate',
	        'decimal': 'decimal',
	        'degrees': 'degrees, minutes, seconds',
	        'latitude-degrees': 'latitude (d° m’ s” N)',
	        'longitude-degrees': 'longitude (d° m’ s” W)',
	        'mgrs': 'MGRS',
	        'notavailable': 'Not Available',
	        'utm': 'UTM',
	        'utm-easting': 'easting (m)',
	        'utm-hemisphere': 'hemisphere',
	        'utm-north': 'North',
	        'utm-northing': 'northing (m)',
	        'utm-south': 'South',
	        'utm-zone': 'zone'
	    },
	    'filepicker': {
	        'placeholder': 'Click here to upload file. (< __maxSize__)',
	        'notFound': 'File __existing__ could not be found (leave unchanged if already submitted and you want to preserve it).',
	        'waitingForPermissions': 'Waiting for user permissions.',
	        'resetWarning': 'This will remove the __item__. Are you sure you want to do this?',
	        'toolargeerror': 'File too large (> __maxSize__)',
	        'file': 'file'
	    },
	    'drawwidget': {
	        'drawing': 'drawing',
	        'signature': 'signature',
	        'annotation': 'file and drawing'
	    },
	    'form': {
	        'required': 'required'
	    },
	    'geopicker': {
	        'accuracy': 'accuracy (m)',
	        'altitude': 'altitude (m)',
	        'closepolygon': 'close polygon',
	        'kmlcoords': 'KML coordinates',
	        'kmlpaste': 'paste KML coordinates here',
	        'latitude': 'latitude (x.y °)',
	        'longitude': 'longitude (x.y °)',
	        'points': 'points',
	        'searchPlaceholder': 'search for place or address',
	        'removePoint': 'This will completely remove the current geopoint from the list of geopoints and cannot be undone. Are you sure you want to do this?'
	    },
	    'selectpicker': {
	        'noneselected': 'none selected',
	        'numberselected': '__number__ selected'
	    },
	    'imagemap': {
	        'svgNotFound': 'SVG image could not be found'
	    },
	    'rankwidget': {
	        'tapstart': 'Tap to start',
	        'clickstart': 'Click to start'
	    },
	    'widget': {
	        'comment': {
	            'update': 'Update'
	        }
	    },
	    'alert': {
	        'gotonotfound': {
	            'msg': 'Failed to find question \'__path__\' in form. Is it a valid path?'
	        }
	    },
	    'confirm': {
	        'repeatremove': {
	            'heading': 'Delete this group of responses?',
	            'msg': 'This action is irreversible. Are you sure you want to proceed?'
	        }
	    }
	};

	/**
	 * Add keys from XSL stylesheets manually so i18next-parser will detect them.
	 *
	 * t('constraint.invalid');
	 * t('constraint.required');
	 */

	/**
	 * Meant to be replaced by a real translator in the app that consumes enketo-core
	 *
	 * @param  {String} key translation key
	 * @param  {*} key translation options
	 * @return {String} translation output
	 */
	function t( key, options ) {
	    let str = '';
	    let target = SOURCE_STRINGS;

	    // crude string getter
	    key.split( '.' ).forEach( part => {
	        target = target ? target[ part ] : '';
	        str = target;
	    } );
	    // crude interpolator
	    options = options || {};
	    str = str.replace( /__([^_]+)__/, ( match, p1 ) => options[ p1 ] );

	    // Enable line below to switch to fake Arabic, very useful for testing RTL
	    // var AR = 'العربية '; return str.split( '' ).map( function( char, i ) { return AR[ i % AR.length ];} ).join( '' );
	    return str;
	}

	/**
	 * Form control (input, select, textarea) helper functions.
	 */

	var input = {
	    // Multiple nodes are limited to ones of the same input type (better implemented as JQuery plugin actually)
	    getWrapNodes( $inputs ) {
	        const type = this.getInputType( $inputs.eq( 0 ) );
	        return ( type === 'fieldset' ) ? $inputs : $inputs.closest( '.question, .calculation' );
	    },
	    /** very inefficient, should actually not be used **/
	    getProps( $input ) {
	        if ( $input.length !== 1 ) {
	            return console.error( 'getProps(): no input node provided or multiple' );
	        }
	        return {
	            path: this.getName( $input ),
	            ind: this.getIndex( $input ),
	            inputType: this.getInputType( $input ),
	            xmlType: this.getXmlType( $input ),
	            constraint: this.getConstraint( $input ),
	            calculation: this.getCalculation( $input ),
	            relevant: this.getRelevant( $input ),
	            readonly: this.getReadonly( $input ),
	            val: this.getVal( $input ),
	            required: this.getRequired( $input ),
	            enabled: this.isEnabled( $input ),
	            multiple: this.isMultiple( $input )
	        };
	    },
	    getInputType( $input ) {
	        let nodeName;
	        if ( $input.length !== 1 ) {
	            return ''; //console.error('getInputType(): no input node provided or multiple');
	        }
	        nodeName = $input.prop( 'nodeName' ).toLowerCase();
	        if ( nodeName === 'input' ) {
	            if ( $input.data( 'drawing' ) ) {
	                return 'drawing';
	            }
	            if ( $input.attr( 'type' ).length > 0 ) {
	                return $input.attr( 'type' ).toLowerCase();
	            }
	            return console.error( '<input> node has no type' );

	        } else if ( nodeName === 'select' ) {
	            return 'select';
	        } else if ( nodeName === 'textarea' ) {
	            return 'textarea';
	        } else if ( nodeName === 'fieldset' || nodeName === 'section' ) {
	            return 'fieldset';
	        } else {
	            return console.error( 'unexpected input node type provided' );
	        }
	    },
	    getConstraint( $input ) {
	        return $input.attr( 'data-constraint' );
	    },
	    getRequired( $input ) {
	        // only return value if input is not a table heading input
	        if ( $input.parentsUntil( '.or', '.or-appearance-label' ).length === 0 ) {
	            return $input.attr( 'data-required' );
	        }
	    },
	    getRelevant( $input ) {
	        return $input.attr( 'data-relevant' );
	    },
	    getReadonly( $input ) {
	        return $input.is( '[readonly]' );
	    },
	    getCalculation( $input ) {
	        return $input.attr( 'data-calculate' );
	    },
	    getXmlType( $input ) {
	        if ( $input.length !== 1 ) {
	            return console.error( 'getXMLType(): no input node provided or multiple' );
	        }
	        return $input.attr( 'data-type-xml' );
	    },
	    getName( $input ) {
	        let name;
	        if ( $input.length !== 1 ) {
	            return console.error( 'getName(): no input node provided or multiple' );
	        }
	        name = $input.attr( 'data-name' ) || $input.attr( 'name' );
	        return name || console.error( 'input node has no name' );
	    },
	    /**
	     * Used to retrieve the index of a question amidst all questions with the same name.
	     * The index that can be used to find the corresponding node in the model.
	     * NOTE: this function should be used sparingly, as it is CPU intensive!
	     */
	    getIndex( $input ) {
	        if ( $input.length !== 1 ) {
	            return console.error( 'getIndex(): no input node provided or multiple' );
	        }
	        return this.form.repeats.getIndex( $input[ 0 ].closest( '.or-repeat' ) );
	    },
	    isMultiple( $input ) {
	        return ( this.getInputType( $input ) === 'checkbox' || $input.attr( 'multiple' ) !== undefined ) ? true : false;
	    },
	    isEnabled( $input ) {
	        return !( $input.prop( 'disabled' ) || $input.parentsUntil( '.or', '.disabled' ).length > 0 );
	    },
	    getVal( $input ) {
	        let inputType;
	        const values = [];
	        let name;

	        if ( $input.length !== 1 ) {
	            return console.error( 'getVal(): no inputNode provided or multiple' );
	        }
	        inputType = this.getInputType( $input );
	        name = this.getName( $input );

	        if ( inputType === 'radio' ) {
	            return this.getWrapNodes( $input ).find( 'input:checked' ).val() || '';
	        }
	        // checkbox values bug in jQuery as (node.val() should work)
	        if ( inputType === 'checkbox' ) {
	            this.getWrapNodes( $input ).find( `input[name="${name}"]:checked` ).each( function() {
	                values.push( this.value );
	            } );
	            return values;
	        }
	        return $input.val() || '';
	    },
	    find( name, index ) {
	        let attr = 'name';
	        if ( this.getInputType( this.form.view.$.find( `[data-name="${name}"]:not(.ignore)` ).eq( 0 ) ) === 'radio' ) {
	            attr = 'data-name';
	        }
	        return this.getWrapNodes( this.form.view.$.find( `[${attr}="${name}"]` ) ).eq( index ).find( `[${attr}="${name}"]:not(.ignore)` ).eq( 0 );
	    },
	    setVal( $input, value, event$1 = event.InputUpdate() ) {
	        let $inputs;
	        const type = this.getInputType( $input );
	        const $question = this.getWrapNodes( $input );
	        const name = this.getName( $input );

	        if ( type === 'radio' ) {
	            // TODO: should this revert to name if data-name is not present. Is data-name always present on radiobuttons?
	            $inputs = $question.find( `[data-name="${name}"]:not(.ignore)` );
	        } else {
	            // why not use this.getIndex?
	            $inputs = $question.find( `[name="${name}"]:not(.ignore)` );

	            if ( type === 'file' ) {
	                // value of file input can be reset to empty but not to a non-empty value
	                if ( value ) {
	                    $input.attr( 'data-loaded-file-name', value );
	                    // console.error('Cannot set value of file input field (value: '+value+'). If trying to load '+
	                    //  'this record for editing this file input field will remain unchanged.');
	                    return false;
	                }
	            }

	            if ( type === 'date' || type === 'datetime' ) {
	                // convert current value (loaded from instance) to a value that a native datepicker understands
	                // TODO: test for IE, FF, Safari when those browsers start including native datepickers
	                value = types[ type ].convert( value );
	            }

	            if ( type === 'time' ) {
	                // convert to a local time value that HTML time inputs and the JS widget understand (01:02)
	                if ( /(\+|-)/.test( value ) ) {
	                    // Use today's date to incorporate daylight savings changes,
	                    // Strip the thousands of a second, because most browsers fail to parse such a time.
	                    // Add a space before the timezone offset to satisfy some browsers.
	                    // For IE11, we also need to strip the Left-to-Right marks \u200E...
	                    const ds = `${new Date().toLocaleDateString( 'en', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
} ).replace( /\u200E/g, '' )} ${value.replace( /(\d\d:\d\d:\d\d)(\.\d{1,3})(\s?((\+|-)\d\d))(:)?(\d\d)?/, '$1 GMT$3$7' )}`;
	                    const d = new Date( ds );
	                    if ( d.toString() !== 'Invalid Date' ) {
	                        value = `${d.getHours().toString().pad( 2 )}:${d.getMinutes().toString().pad( 2 )}`;
	                    } else {
	                        console.error( 'could not parse time:', value );
	                    }
	                }
	            }
	        }

	        if ( this.isMultiple( $input ) === true ) {
	            // TODO: It's weird that setVal does not take an array value but getVal returns an array value for multiple selects!
	            value = value.split( ' ' );
	        } else if ( type === 'radio' ) {
	            value = [ value ];
	        }

	        // Trigger an 'inputupdate' event which can be used in widgets to update the widget when the value of its 
	        // original input element has changed **programmatically**.
	        if ( $inputs.length ) {
	            const curVal = this.getVal( $input );
	            if ( curVal === undefined || curVal.toString() !== value.toString() ) {
	                $inputs.val( value );
	                // don't trigger on all radiobuttons/checkboxes
	                if ( event$1 ) {
	                    $inputs[ 0 ].dispatchEvent( event$1 );
	                }
	            }
	        }

	        return $inputs[ 0 ];
	    },
	    validate( $input ) {
	        return this.form.validateInput( $input );
	    }
	};

	/*
	 * This file is meant to be overidden with one that uses the app's dialogs.
	 */

	/**
	 * @param {String | {message: String, heading: String}} content Dialog content
	 */
	function alert( content ) {
	    window.alert( content );
	    return Promise.resolve();
	}

	/**
	 * @param {String | {message: String, heading: String}} content Dialog content
	 */
	function confirm( content ) {
	    const msg = content.message ? content.message : content;
	    return Promise.resolve( window.confirm( msg ) );
	}

	function prompt( content, def ) {
	    return Promise.resolve( window.prompt( content, def ) );
	}

	var dialog = {
	    alert,
	    confirm,
	    prompt
	};

	/**
	 * Repeats module.
	 * 
	 * Two important concepts are used:
	 * 1. The first XLST-added repeat view is cloned to serve as a template of that repeat.
	 * 2. Each repeat series has a sibling .or-repeat-info element that stores info that is relevant to that series.
	 *
	 * Note that with nested repeats you may have many more series of repeats than templates, because a nested repeat
	 * may have multiple series.
	 */
	const disableFirstRepeatRemoval = config.repeatOrdinals === true;

	var repeatModule = {
	    /**
	     * Initializes all Repeat Groups in form (only called once).
	     * @param  {Form} form the parent form object
	     */
	    init() {
	        const that = this;
	        let $repeatInfos;

	        if ( !this.form ) {
	            throw new Error( 'Repeat module not correctly instantiated with form property.' );
	        }

	        $repeatInfos = this.form.view.$.find( '.or-repeat-info' );
	        this.templates = {};
	        // Add repeat numbering elements
	        $repeatInfos
	            .siblings( '.or-repeat' )
	            .prepend( '<span class="repeat-number"></span>' )
	            // add empty class for calculation-only repeats
	            .addBack()
	            .filter( function() {
	                // remove whitespace
	                if ( this.firstChild && this.firstChild.nodeType === 3 ) {
	                    this.firstChild.textContent = '';
	                }
	                return !this.querySelector( '.question' );
	            } )
	            .addClass( 'empty' );
	        // Add repeat buttons
	        $repeatInfos.filter( '*:not([data-repeat-fixed]):not([data-repeat-count])' )
	            .append( '<button type="button" class="btn btn-default add-repeat-btn"><i class="icon icon-plus"> </i></button>' )
	            .siblings( '.or-repeat' )
	            .append( `<div class="repeat-buttons"><button type="button" ${' '}class="btn btn-default remove"><i class="icon icon-minus"> </i></button></div>` );
	        /**
	         * The model also requires storing repeat templates for repeats that do not have a jr:template.
	         * Since the model has no knowledge of which node is a repeat, we direct this here.
	         */
	        this.form.model.extractFakeTemplates( $repeatInfos.map( function() {
	            return this.dataset.name;
	        } ).get() );

	        /**
	         * Clone all repeats to serve as templates
	         * in reverse document order to properly deal with nested repeat templates
	         *
	         * Widgets not yet initialized. Values not yet set.
	         */
	        $repeatInfos.siblings( '.or-repeat' ).reverse().each( function() {
	            const templateEl = this.cloneNode( true );
	            const xPath = templateEl.getAttribute( 'name' );
	            this.remove();
	            jquery( templateEl ).removeClass( 'contains-current current' ).find( '.current' ).removeClass( 'current' );
	            that.templates[ xPath ] = templateEl;
	        } );

	        $repeatInfos.filter( '*:not([data-repeat-count])' ).reverse()
	            .each( function() {
	                // don't do nested repeats here, they will be dealt with recursively
	                if ( !jquery( this ).closest( '.or-repeat' ).length ) {
	                    that.updateDefaultFirstRepeatInstance( null, this );
	                }
	            } )
	            // If there is no repeat-count attribute, check how many repeat instances 
	            // are in the model, and update view if necessary.
	            .each( that.updateViewInstancesFromModel.bind( this ) );

	        // delegated handlers (strictly speaking not required, but checked for doubling of events -> OK)
	        this.form.view.$.on( 'click', 'button.add-repeat-btn:enabled', function() {
	            // Create a clone
	            that.add( jquery( this ).closest( '.or-repeat-info' )[ 0 ] );
	            // Prevent default
	            return false;
	        } );
	        this.form.view.$.on( 'click', 'button.remove:enabled', function() {
	            that.confirmDelete( this.closest( '.or-repeat' ) );
	            //prevent default
	            return false;
	        } );

	        this.countUpdate();
	    },
	    // Make this function overwritable
	    confirmDelete( repeatEl ) {
	        const that = this;
	        dialog.confirm( { heading: t( 'confirm.repeatremove.heading' ), msg: t( 'confirm.repeatremove.msg' ) } )
	            .then( confirmed => {
	                if ( confirmed ) {
	                    //remove clone
	                    that.remove( jquery( repeatEl ) );
	                }
	            } )
	            .catch( console.error );
	    },
	    /*
	     * Obtains the absolute index of the provided repeat or repeat-info element
	     * The goal of this function is to make non-nested repeat index determination as fast as possible.
	     */
	    getIndex( el ) {
	        if ( !el || !this.form.repeatsPresent ) {
	            return 0;
	        }
	        let checkEl = el.parentElement.closest( '.or-repeat' );
	        const info = el.classList.contains( 'or-repeat-info' );
	        let count = info ? 1 : Number( el.querySelector( '.repeat-number' ).textContent );
	        let name;
	        while ( checkEl ) {
	            while ( checkEl.previousElementSibling && checkEl.previousElementSibling.matches( '.or-repeat' ) ) {
	                checkEl = checkEl.previousElementSibling;
	                if ( info ) {
	                    count++;
	                } else {
	                    name = name || el.getAttribute( 'name' );
	                    count += checkEl.querySelectorAll( `.or-repeat[name="${name}"]` ).length;
	                }
	            }
	            const parent = checkEl.parentElement;
	            checkEl = parent ? parent.closest( '.or-repeat' ) : null;
	        }
	        return count - 1;
	    },
	    /*
	     * Obtains the absolute index of the provided repeat-info element
	     */
	    getInfoIndex( repeatInfo ) {
	        if ( !this.form.repeatsPresent ) {
	            return 0;
	        }
	        if ( !repeatInfo || !repeatInfo.classList.contains( 'or-repeat-info' ) ) {
	            return null;
	        }
	        const name = repeatInfo.dataset.name;
	        return [ ...repeatInfo.closest( 'form.or' ).querySelectorAll( `.or-repeat-info[data-name="${name}"]` ) ].indexOf( repeatInfo );
	    },
	    /**
	     * [updateViewInstancesFromModel description]
	     * @param  {[type]} idx           not used but part of jQuery.each
	     * @param   {Element} repeatInfo  repeatInfo element
	     * @return {[type]}            [description]
	     */
	    updateViewInstancesFromModel( idx, repeatInfo ) {
	        const that = this;
	        const $repeatInfo = jquery( repeatInfo );
	        const repeatPath = repeatInfo.dataset.name;
	        // All we need is to find out in which series we are.
	        const repeatSeriesIndex = this.getIndex( repeatInfo );
	        const repInModelSeries = this.form.model.getRepeatSeries( repeatPath, repeatSeriesIndex );
	        const repInViewSeries = $repeatInfo.siblings( '.or-repeat' );
	        // First rep is already included (by XSLT transformation)
	        if ( repInModelSeries.length > repInViewSeries.length ) {
	            this.add( repeatInfo, repInModelSeries.length - repInViewSeries.length );
	            // Now check the repeat counts of all the descendants of this repeat and its new siblings
	            // Note: not tested with triple-nested repeats, but probably taking the better safe-than-sorry approach,
	            // so should be okay except for performance.
	            $repeatInfo.siblings( '.or-repeat' )
	                .find( '.or-repeat-info:not([data-repeat-count])' )
	                .each( function() {
	                    that.updateViewInstancesFromModel( null, this );
	                } );
	        }
	        return repInModelSeries.length;
	    },
	    /**
	     * [updateDefaultFirstRepeatInstance description]
	     * @param  {[type]} idx             not use but part of jQeury.each
	     * @param   {Element} repeatInfo    repeatInfo element
	     * @return {[type]}            [description]
	     */
	    updateDefaultFirstRepeatInstance( idx, repeatInfo ) {
	        let repeatSeriesIndex;
	        let repeatSeriesInModel;
	        const that = this;
	        const $repeatInfo = jquery( repeatInfo );
	        const repeatPath = repeatInfo.dataset.name;
	        if ( !that.form.model.data.instanceStr && !this.templates[ repeatPath ].classList.contains( 'or-appearance-minimal' ) ) {
	            repeatSeriesIndex = this.getIndex( repeatInfo );
	            repeatSeriesInModel = this.form.model.getRepeatSeries( repeatPath, repeatSeriesIndex );
	            if ( repeatSeriesInModel.length === 0 ) {
	                // explicitly provide a count, so that byCountUpdate is passed to the addrepeat event
	                this.add( repeatInfo, 1 );
	            }
	            $repeatInfo.siblings( '.or-repeat' )
	                .find( '.or-repeat-info:not([data-repeat-count])' )
	                .each( that.updateDefaultFirstRepeatInstance.bind( that ) );
	        }
	    },
	    /**
	     * [updateRepeatInstancesFromCount description]
	     * @param  {[type]} idx             not use but part of jQeury.each
	     * @param   {Element} repeatInfo repeatInfo element
	     * @return {[type]}            [description]
	     */
	    updateRepeatInstancesFromCount( idx, repeatInfo ) {
	        const that = this;
	        let $last;
	        let numRepsInCount;
	        const $repeatInfo = jquery( repeatInfo );
	        const repCountPath = repeatInfo.dataset.repeatCount || '';

	        if ( !repCountPath ) {
	            return;
	        }

	        /*
	         * We cannot pass an .or-repeat context to model.evaluate() if the number or repeats in a series is zero.
	         * However, but we do still need a context for nested repeats where the count of the nested repeat
	         * is determined in a node inside the parent repeat. To do so we use the repeat comment in model as context.
	         */
	        const repPath = repeatInfo.dataset.name;
	        const repCountNode = this.form.model.evaluate( repCountPath, 'node', this.form.model.getRepeatCommentSelector( repPath ), this.getInfoIndex( repeatInfo ), true );

	        if ( repCountNode ) {
	            numRepsInCount = Number( repCountNode.textContent );
	        } else {
	            console.error( 'Unexpectedly, could not obtain repeat count node' );
	        }

	        numRepsInCount = isNaN( numRepsInCount ) ? 0 : numRepsInCount;
	        const numRepsInView = $repeatInfo.siblings( `.or-repeat[name="${repPath}"]` ).length;
	        let toCreate = numRepsInCount - numRepsInView;

	        if ( toCreate > 0 ) {
	            that.add( repeatInfo, toCreate );
	        } else if ( toCreate < 0 ) {
	            toCreate = Math.abs( toCreate ) >= numRepsInView ? -numRepsInView + ( 0 ) : toCreate;
	            for ( ; toCreate < 0; toCreate++ ) {
	                $last = $repeatInfo.siblings( '.or-repeat' ).last();
	                this.remove( $last, 0 );
	            }
	        }
	        // Now check the repeat counts of all the descendants of this repeat and its new siblings, level-by-level.
	        // TODO: this does not find .or-repeat > .or-repeat (= unusual syntax)
	        $repeatInfo.siblings( '.or-repeat' )
	            .children( '.or-group, .or-group-data' )
	            .children( '.or-repeat-info[data-repeat-count]' )
	            .each( that.updateRepeatInstancesFromCount.bind( that ) );
	    },
	    /**
	     * Checks whether repeat count value has been updated and updates repeat instances
	     * accordingly.
	     * 
	     * @param  {[type]} updated [description]
	     * @return {[type]}         [description]
	     */
	    countUpdate( updated ) {
	        let $repeatInfos;
	        updated = updated || {};
	        $repeatInfos = this.form.getRelatedNodes( 'data-repeat-count', '.or-repeat-info', updated );
	        $repeatInfos.each( this.updateRepeatInstancesFromCount.bind( this ) );
	    },
	    /**s
	     * clone a repeat group/node
	     * @param   {Element} repeatInfo repeatInfo element
	     * @param   {number=} count number of clones to create
	     * @return  {boolean}       [description]
	     */
	    add( repeatInfo, count ) {
	        let $repeats;
	        let $clone;
	        let repeatIndex;
	        let repeatSeriesIndex;
	        let repeatPath;
	        let i;
	        const that = this;
	        const $repeatInfo = jquery( repeatInfo );
	        const byCountUpdate = !!count;
	        let modelRepeatSeriesLength;

	        count = count || 1;

	        if ( !repeatInfo ) {
	            console.error( 'Nothing to clone' );
	            return false;
	        }

	        repeatPath = repeatInfo.dataset.name;
	        $repeats = $repeatInfo.siblings( '.or-repeat' );

	        $clone = jquery( this.templates[ repeatPath ] ).clone();

	        // Determine the index of the repeat series.
	        repeatSeriesIndex = this.getIndex( repeatInfo );
	        modelRepeatSeriesLength = this.form.model.getRepeatSeries( repeatPath, repeatSeriesIndex ).length;
	        // Determine the index of the repeat inside its series
	        const prevSibling = repeatInfo.previousElementSibling;
	        let repeatIndexInSeries = prevSibling && prevSibling.classList.contains( 'or-repeat' ) ?
	            Number( prevSibling.querySelector( '.repeat-number' ).textContent ) : 0;

	        // Add required number of repeats
	        for ( i = 0; i < count; i++ ) {
	            // Fix names of radio button groups
	            $clone.find( '.option-wrapper' ).each( this.fixRadioNames );
	            $clone.find( 'datalist' ).each( this.fixDatalistIds );

	            // Insert the clone
	            $clone.insertBefore( repeatInfo );

	            if ( repeatIndexInSeries > 0 ) {
	                // Also add the clone class for all 2+ numbers as this is
	                // used for performance optimization in several places.
	                $clone.addClass( 'clone' );
	            }

	            // Update the repeat number
	            $clone[ 0 ].querySelector( '.repeat-number' ).textContent = repeatIndexInSeries + 1;

	            // Update the variable containing the view repeats in the current series.
	            $repeats = $repeats.add( $clone );

	            // Create a repeat in the model if it doesn't already exist
	            if ( $repeats.length > modelRepeatSeriesLength ) {
	                this.form.model.addRepeat( repeatPath, repeatSeriesIndex );
	                modelRepeatSeriesLength++;
	            }
	            // This is the index of the new repeat in relation to all other repeats of the same name,
	            // even if they are in different series.
	            repeatIndex = repeatIndex || this.getIndex( $clone[ 0 ] );
	            // This will trigger setting default values, calculations, readonly, relevancy, language updates, and automatic page flips.
	            $clone[ 0 ].dispatchEvent( event.AddRepeat( [ repeatIndex, byCountUpdate ] ) );
	            // Initialize widgets in clone after default values have been set
	            if ( this.form.widgetsInitialized ) {
	                this.form.widgets.init( $clone, this.form.options );
	            } else {
	                // Upon inital formload the eventhandlers for calculated items have not yet been set.
	                // Calculations have already been initialized before the repeat clone(s) were created.
	                // Therefore, we manually trigger a calculation update for the cloned repeat.
	                that.form.calc.update( {
	                    repeatPath,
	                    repeatIndex
	                } );
	            }
	            // now create the first instance of any nested repeats if necessary
	            $clone.find( '.or-repeat-info:not([data-repeat-count])' ).each( this.updateDefaultFirstRepeatInstance.bind( this ) );

	            $clone = jquery( this.templates[ repeatPath ] ).clone();

	            repeatIndex++;
	            repeatIndexInSeries++;
	        }

	        // number the repeats
	        //this.numberRepeats( repeatInfo );
	        // enable or disable + and - buttons
	        this.toggleButtons( repeatInfo );

	        return true;
	    },
	    remove( $repeat, delay ) {
	        const that = this;
	        const $next = $repeat.next( '.or-repeat, .or-repeat-info' );
	        const repeatPath = $repeat.attr( 'name' );
	        const repeatIndex = this.getIndex( $repeat[ 0 ] );
	        const repeatInfo = $repeat.siblings( '.or-repeat-info' )[ 0 ];

	        delay = typeof delay !== 'undefined' ? delay : 600;

	        $repeat.hide( delay, () => {
	            $repeat.remove();
	            that.numberRepeats( repeatInfo );
	            that.toggleButtons( repeatInfo );
	            // Trigger the removerepeat on the next repeat or repeat-info(always present)
	            // so that removerepeat handlers know where the repeat was removed
	            $next[ 0 ].dispatchEvent( event.RemoveRepeat() );
	            // Now remove the data node
	            that.form.model.node( repeatPath, repeatIndex ).remove();
	        } );
	    },
	    fixRadioNames( index, element ) {
	        jquery( element ).find( 'input[type="radio"]' )
	            .attr( 'name', Math.floor( ( Math.random() * 10000000 ) + 1 ) );
	    },
	    fixDatalistIds( index, element ) {
	        const newId = element.id + Math.floor( ( Math.random() * 10000000 ) + 1 );
	        element.parentNode.querySelector( `input[list="${element.id}"]` ).setAttribute( 'list', newId );
	        element.id = newId;
	    },
	    toggleButtons( repeatInfo ) {
	        jquery( repeatInfo )
	            .siblings( '.or-repeat' )
	            .children( '.repeat-buttons' )
	            .find( 'button.remove' )
	            .prop( 'disabled', false )
	            .first()
	            .prop( 'disabled', disableFirstRepeatRemoval );
	    },
	    numberRepeats( repeatInfo ) {
	        jquery( repeatInfo )
	            .siblings( '.or-repeat' )
	            .each( ( idx, repeat ) => {
	                jquery( repeat ).children( '.repeat-number' ).text( idx + 1 );
	            } );
	    }
	};

	var jquery_touchSwipe_min = createCommonjsModule(function (module) {
	/*!
	 * @fileOverview TouchSwipe - jQuery Plugin
	 * @version 1.6.18
	 *
	 * @author Matt Bryson http://www.github.com/mattbryson
	 * @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
	 * @see http://labs.rampinteractive.co.uk/touchSwipe/
	 * @see http://plugins.jquery.com/project/touchSwipe
	 * @license
	 * Copyright (c) 2010-2015 Matt Bryson
	 * Dual licensed under the MIT or GPL Version 2 licenses.
	 *
	 */
	!function(factory){factory(module.exports?jquery:jQuery);}(function($){function init(options){return !options||void 0!==options.allowPageScroll||void 0===options.swipe&&void 0===options.swipeStatus||(options.allowPageScroll=NONE),void 0!==options.click&&void 0===options.tap&&(options.tap=options.click),options||(options={}),options=$.extend({},$.fn.swipe.defaults,options),this.each(function(){var $this=$(this),plugin=$this.data(PLUGIN_NS);plugin||(plugin=new TouchSwipe(this,options),$this.data(PLUGIN_NS,plugin));})}function TouchSwipe(element,options){function touchStart(jqEvent){if(!(getTouchInProgress()||$(jqEvent.target).closest(options.excludedElements,$element).length>0)){var event=jqEvent.originalEvent?jqEvent.originalEvent:jqEvent;if(!event.pointerType||"mouse"!=event.pointerType||0!=options.fallbackToMouseEvents){var ret,touches=event.touches,evt=touches?touches[0]:event;return phase=PHASE_START,touches?fingerCount=touches.length:options.preventDefaultEvents!==!1&&jqEvent.preventDefault(),distance=0,direction=null,currentDirection=null,pinchDirection=null,duration=0,startTouchesDistance=0,endTouchesDistance=0,pinchZoom=1,pinchDistance=0,maximumsMap=createMaximumsData(),cancelMultiFingerRelease(),createFingerData(0,evt),!touches||fingerCount===options.fingers||options.fingers===ALL_FINGERS||hasPinches()?(startTime=getTimeStamp(),2==fingerCount&&(createFingerData(1,touches[1]),startTouchesDistance=endTouchesDistance=calculateTouchesDistance(fingerData[0].start,fingerData[1].start)),(options.swipeStatus||options.pinchStatus)&&(ret=triggerHandler(event,phase))):ret=!1,ret===!1?(phase=PHASE_CANCEL,triggerHandler(event,phase),ret):(options.hold&&(holdTimeout=setTimeout($.proxy(function(){$element.trigger("hold",[event.target]),options.hold&&(ret=options.hold.call($element,event,event.target));},this),options.longTapThreshold)),setTouchInProgress(!0),null)}}}function touchMove(jqEvent){var event=jqEvent.originalEvent?jqEvent.originalEvent:jqEvent;if(phase!==PHASE_END&&phase!==PHASE_CANCEL&&!inMultiFingerRelease()){var ret,touches=event.touches,evt=touches?touches[0]:event,currentFinger=updateFingerData(evt);if(endTime=getTimeStamp(),touches&&(fingerCount=touches.length),options.hold&&clearTimeout(holdTimeout),phase=PHASE_MOVE,2==fingerCount&&(0==startTouchesDistance?(createFingerData(1,touches[1]),startTouchesDistance=endTouchesDistance=calculateTouchesDistance(fingerData[0].start,fingerData[1].start)):(updateFingerData(touches[1]),endTouchesDistance=calculateTouchesDistance(fingerData[0].end,fingerData[1].end),pinchDirection=calculatePinchDirection(fingerData[0].end,fingerData[1].end)),pinchZoom=calculatePinchZoom(startTouchesDistance,endTouchesDistance),pinchDistance=Math.abs(startTouchesDistance-endTouchesDistance)),fingerCount===options.fingers||options.fingers===ALL_FINGERS||!touches||hasPinches()){if(direction=calculateDirection(currentFinger.start,currentFinger.end),currentDirection=calculateDirection(currentFinger.last,currentFinger.end),validateDefaultEvent(jqEvent,currentDirection),distance=calculateDistance(currentFinger.start,currentFinger.end),duration=calculateDuration(),setMaxDistance(direction,distance),ret=triggerHandler(event,phase),!options.triggerOnTouchEnd||options.triggerOnTouchLeave){var inBounds=!0;if(options.triggerOnTouchLeave){var bounds=getbounds(this);inBounds=isInBounds(currentFinger.end,bounds);}!options.triggerOnTouchEnd&&inBounds?phase=getNextPhase(PHASE_MOVE):options.triggerOnTouchLeave&&!inBounds&&(phase=getNextPhase(PHASE_END)),phase!=PHASE_CANCEL&&phase!=PHASE_END||triggerHandler(event,phase);}}else phase=PHASE_CANCEL,triggerHandler(event,phase);ret===!1&&(phase=PHASE_CANCEL,triggerHandler(event,phase));}}function touchEnd(jqEvent){var event=jqEvent.originalEvent?jqEvent.originalEvent:jqEvent,touches=event.touches;if(touches){if(touches.length&&!inMultiFingerRelease())return startMultiFingerRelease(event),!0;if(touches.length&&inMultiFingerRelease())return !0}return inMultiFingerRelease()&&(fingerCount=fingerCountAtRelease),endTime=getTimeStamp(),duration=calculateDuration(),didSwipeBackToCancel()||!validateSwipeDistance()?(phase=PHASE_CANCEL,triggerHandler(event,phase)):options.triggerOnTouchEnd||options.triggerOnTouchEnd===!1&&phase===PHASE_MOVE?(options.preventDefaultEvents!==!1&&jqEvent.cancelable!==!1&&jqEvent.preventDefault(),phase=PHASE_END,triggerHandler(event,phase)):!options.triggerOnTouchEnd&&hasTap()?(phase=PHASE_END,triggerHandlerForGesture(event,phase,TAP)):phase===PHASE_MOVE&&(phase=PHASE_CANCEL,triggerHandler(event,phase)),setTouchInProgress(!1),null}function touchCancel(){fingerCount=0,endTime=0,startTime=0,startTouchesDistance=0,endTouchesDistance=0,pinchZoom=1,cancelMultiFingerRelease(),setTouchInProgress(!1);}function touchLeave(jqEvent){var event=jqEvent.originalEvent?jqEvent.originalEvent:jqEvent;options.triggerOnTouchLeave&&(phase=getNextPhase(PHASE_END),triggerHandler(event,phase));}function removeListeners(){$element.off(START_EV,touchStart),$element.off(CANCEL_EV,touchCancel),$element.off(MOVE_EV,touchMove),$element.off(END_EV,touchEnd),LEAVE_EV&&$element.off(LEAVE_EV,touchLeave),setTouchInProgress(!1);}function getNextPhase(currentPhase){var nextPhase=currentPhase,validTime=validateSwipeTime(),validDistance=validateSwipeDistance(),didCancel=didSwipeBackToCancel();return !validTime||didCancel?nextPhase=PHASE_CANCEL:!validDistance||currentPhase!=PHASE_MOVE||options.triggerOnTouchEnd&&!options.triggerOnTouchLeave?!validDistance&&currentPhase==PHASE_END&&options.triggerOnTouchLeave&&(nextPhase=PHASE_CANCEL):nextPhase=PHASE_END,nextPhase}function triggerHandler(event,phase){var ret,touches=event.touches;return (didSwipe()||hasSwipes())&&(ret=triggerHandlerForGesture(event,phase,SWIPE)),(didPinch()||hasPinches())&&ret!==!1&&(ret=triggerHandlerForGesture(event,phase,PINCH)),didDoubleTap()&&ret!==!1?ret=triggerHandlerForGesture(event,phase,DOUBLE_TAP):didLongTap()&&ret!==!1?ret=triggerHandlerForGesture(event,phase,LONG_TAP):didTap()&&ret!==!1&&(ret=triggerHandlerForGesture(event,phase,TAP)),phase===PHASE_CANCEL&&touchCancel(event),phase===PHASE_END&&(touches?touches.length||touchCancel(event):touchCancel(event)),ret}function triggerHandlerForGesture(event,phase,gesture){var ret;if(gesture==SWIPE){if($element.trigger("swipeStatus",[phase,direction||null,distance||0,duration||0,fingerCount,fingerData,currentDirection]),options.swipeStatus&&(ret=options.swipeStatus.call($element,event,phase,direction||null,distance||0,duration||0,fingerCount,fingerData,currentDirection),ret===!1))return !1;if(phase==PHASE_END&&validateSwipe()){if(clearTimeout(singleTapTimeout),clearTimeout(holdTimeout),$element.trigger("swipe",[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipe&&(ret=options.swipe.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection),ret===!1))return !1;switch(direction){case LEFT:$element.trigger("swipeLeft",[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeLeft&&(ret=options.swipeLeft.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection));break;case RIGHT:$element.trigger("swipeRight",[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeRight&&(ret=options.swipeRight.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection));break;case UP:$element.trigger("swipeUp",[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeUp&&(ret=options.swipeUp.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection));break;case DOWN:$element.trigger("swipeDown",[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeDown&&(ret=options.swipeDown.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection));}}}if(gesture==PINCH){if($element.trigger("pinchStatus",[phase,pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData]),options.pinchStatus&&(ret=options.pinchStatus.call($element,event,phase,pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData),ret===!1))return !1;if(phase==PHASE_END&&validatePinch())switch(pinchDirection){case IN:$element.trigger("pinchIn",[pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData]),options.pinchIn&&(ret=options.pinchIn.call($element,event,pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData));break;case OUT:$element.trigger("pinchOut",[pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData]),options.pinchOut&&(ret=options.pinchOut.call($element,event,pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData));}}return gesture==TAP?phase!==PHASE_CANCEL&&phase!==PHASE_END||(clearTimeout(singleTapTimeout),clearTimeout(holdTimeout),hasDoubleTap()&&!inDoubleTap()?(doubleTapStartTime=getTimeStamp(),singleTapTimeout=setTimeout($.proxy(function(){doubleTapStartTime=null,$element.trigger("tap",[event.target]),options.tap&&(ret=options.tap.call($element,event,event.target));},this),options.doubleTapThreshold)):(doubleTapStartTime=null,$element.trigger("tap",[event.target]),options.tap&&(ret=options.tap.call($element,event,event.target)))):gesture==DOUBLE_TAP?phase!==PHASE_CANCEL&&phase!==PHASE_END||(clearTimeout(singleTapTimeout),clearTimeout(holdTimeout),doubleTapStartTime=null,$element.trigger("doubletap",[event.target]),options.doubleTap&&(ret=options.doubleTap.call($element,event,event.target))):gesture==LONG_TAP&&(phase!==PHASE_CANCEL&&phase!==PHASE_END||(clearTimeout(singleTapTimeout),doubleTapStartTime=null,$element.trigger("longtap",[event.target]),options.longTap&&(ret=options.longTap.call($element,event,event.target)))),ret}function validateSwipeDistance(){var valid=!0;return null!==options.threshold&&(valid=distance>=options.threshold),valid}function didSwipeBackToCancel(){var cancelled=!1;return null!==options.cancelThreshold&&null!==direction&&(cancelled=getMaxDistance(direction)-distance>=options.cancelThreshold),cancelled}function validatePinchDistance(){return null!==options.pinchThreshold?pinchDistance>=options.pinchThreshold:!0}function validateSwipeTime(){var result;return result=options.maxTimeThreshold?!(duration>=options.maxTimeThreshold):!0}function validateDefaultEvent(jqEvent,direction){if(options.preventDefaultEvents!==!1)if(options.allowPageScroll===NONE)jqEvent.preventDefault();else{var auto=options.allowPageScroll===AUTO;switch(direction){case LEFT:(options.swipeLeft&&auto||!auto&&options.allowPageScroll!=HORIZONTAL)&&jqEvent.preventDefault();break;case RIGHT:(options.swipeRight&&auto||!auto&&options.allowPageScroll!=HORIZONTAL)&&jqEvent.preventDefault();break;case UP:(options.swipeUp&&auto||!auto&&options.allowPageScroll!=VERTICAL)&&jqEvent.preventDefault();break;case DOWN:(options.swipeDown&&auto||!auto&&options.allowPageScroll!=VERTICAL)&&jqEvent.preventDefault();break;case NONE:}}}function validatePinch(){var hasCorrectFingerCount=validateFingers(),hasEndPoint=validateEndPoint(),hasCorrectDistance=validatePinchDistance();return hasCorrectFingerCount&&hasEndPoint&&hasCorrectDistance}function hasPinches(){return !!(options.pinchStatus||options.pinchIn||options.pinchOut)}function didPinch(){return !(!validatePinch()||!hasPinches())}function validateSwipe(){var hasValidTime=validateSwipeTime(),hasValidDistance=validateSwipeDistance(),hasCorrectFingerCount=validateFingers(),hasEndPoint=validateEndPoint(),didCancel=didSwipeBackToCancel(),valid=!didCancel&&hasEndPoint&&hasCorrectFingerCount&&hasValidDistance&&hasValidTime;return valid}function hasSwipes(){return !!(options.swipe||options.swipeStatus||options.swipeLeft||options.swipeRight||options.swipeUp||options.swipeDown)}function didSwipe(){return !(!validateSwipe()||!hasSwipes())}function validateFingers(){return fingerCount===options.fingers||options.fingers===ALL_FINGERS||!SUPPORTS_TOUCH}function validateEndPoint(){return 0!==fingerData[0].end.x}function hasTap(){return !!options.tap}function hasDoubleTap(){return !!options.doubleTap}function hasLongTap(){return !!options.longTap}function validateDoubleTap(){if(null==doubleTapStartTime)return !1;var now=getTimeStamp();return hasDoubleTap()&&now-doubleTapStartTime<=options.doubleTapThreshold}function inDoubleTap(){return validateDoubleTap()}function validateTap(){return (1===fingerCount||!SUPPORTS_TOUCH)&&(isNaN(distance)||distance<options.threshold)}function validateLongTap(){return duration>options.longTapThreshold&&DOUBLE_TAP_THRESHOLD>distance}function didTap(){return !(!validateTap()||!hasTap())}function didDoubleTap(){return !(!validateDoubleTap()||!hasDoubleTap())}function didLongTap(){return !(!validateLongTap()||!hasLongTap())}function startMultiFingerRelease(event){previousTouchEndTime=getTimeStamp(),fingerCountAtRelease=event.touches.length+1;}function cancelMultiFingerRelease(){previousTouchEndTime=0,fingerCountAtRelease=0;}function inMultiFingerRelease(){var withinThreshold=!1;if(previousTouchEndTime){var diff=getTimeStamp()-previousTouchEndTime;diff<=options.fingerReleaseThreshold&&(withinThreshold=!0);}return withinThreshold}function getTouchInProgress(){return !($element.data(PLUGIN_NS+"_intouch")!==!0)}function setTouchInProgress(val){$element&&(val===!0?($element.on(MOVE_EV,touchMove),$element.on(END_EV,touchEnd),LEAVE_EV&&$element.on(LEAVE_EV,touchLeave)):($element.off(MOVE_EV,touchMove,!1),$element.off(END_EV,touchEnd,!1),LEAVE_EV&&$element.off(LEAVE_EV,touchLeave,!1)),$element.data(PLUGIN_NS+"_intouch",val===!0));}function createFingerData(id,evt){var f={start:{x:0,y:0},last:{x:0,y:0},end:{x:0,y:0}};return f.start.x=f.last.x=f.end.x=evt.pageX||evt.clientX,f.start.y=f.last.y=f.end.y=evt.pageY||evt.clientY,fingerData[id]=f,f}function updateFingerData(evt){var id=void 0!==evt.identifier?evt.identifier:0,f=getFingerData(id);return null===f&&(f=createFingerData(id,evt)),f.last.x=f.end.x,f.last.y=f.end.y,f.end.x=evt.pageX||evt.clientX,f.end.y=evt.pageY||evt.clientY,f}function getFingerData(id){return fingerData[id]||null}function setMaxDistance(direction,distance){direction!=NONE&&(distance=Math.max(distance,getMaxDistance(direction)),maximumsMap[direction].distance=distance);}function getMaxDistance(direction){return maximumsMap[direction]?maximumsMap[direction].distance:void 0}function createMaximumsData(){var maxData={};return maxData[LEFT]=createMaximumVO(LEFT),maxData[RIGHT]=createMaximumVO(RIGHT),maxData[UP]=createMaximumVO(UP),maxData[DOWN]=createMaximumVO(DOWN),maxData}function createMaximumVO(dir){return {direction:dir,distance:0}}function calculateDuration(){return endTime-startTime}function calculateTouchesDistance(startPoint,endPoint){var diffX=Math.abs(startPoint.x-endPoint.x),diffY=Math.abs(startPoint.y-endPoint.y);return Math.round(Math.sqrt(diffX*diffX+diffY*diffY))}function calculatePinchZoom(startDistance,endDistance){var percent=endDistance/startDistance*1;return percent.toFixed(2)}function calculatePinchDirection(){return 1>pinchZoom?OUT:IN}function calculateDistance(startPoint,endPoint){return Math.round(Math.sqrt(Math.pow(endPoint.x-startPoint.x,2)+Math.pow(endPoint.y-startPoint.y,2)))}function calculateAngle(startPoint,endPoint){var x=startPoint.x-endPoint.x,y=endPoint.y-startPoint.y,r=Math.atan2(y,x),angle=Math.round(180*r/Math.PI);return 0>angle&&(angle=360-Math.abs(angle)),angle}function calculateDirection(startPoint,endPoint){if(comparePoints(startPoint,endPoint))return NONE;var angle=calculateAngle(startPoint,endPoint);return 45>=angle&&angle>=0?LEFT:360>=angle&&angle>=315?LEFT:angle>=135&&225>=angle?RIGHT:angle>45&&135>angle?DOWN:UP}function getTimeStamp(){var now=new Date;return now.getTime()}function getbounds(el){el=$(el);var offset=el.offset(),bounds={left:offset.left,right:offset.left+el.outerWidth(),top:offset.top,bottom:offset.top+el.outerHeight()};return bounds}function isInBounds(point,bounds){return point.x>bounds.left&&point.x<bounds.right&&point.y>bounds.top&&point.y<bounds.bottom}function comparePoints(pointA,pointB){return pointA.x==pointB.x&&pointA.y==pointB.y}var options=$.extend({},options),useTouchEvents=SUPPORTS_TOUCH||SUPPORTS_POINTER||!options.fallbackToMouseEvents,START_EV=useTouchEvents?SUPPORTS_POINTER?SUPPORTS_POINTER_IE10?"MSPointerDown":"pointerdown":"touchstart":"mousedown",MOVE_EV=useTouchEvents?SUPPORTS_POINTER?SUPPORTS_POINTER_IE10?"MSPointerMove":"pointermove":"touchmove":"mousemove",END_EV=useTouchEvents?SUPPORTS_POINTER?SUPPORTS_POINTER_IE10?"MSPointerUp":"pointerup":"touchend":"mouseup",LEAVE_EV=useTouchEvents?SUPPORTS_POINTER?"mouseleave":null:"mouseleave",CANCEL_EV=SUPPORTS_POINTER?SUPPORTS_POINTER_IE10?"MSPointerCancel":"pointercancel":"touchcancel",distance=0,direction=null,currentDirection=null,duration=0,startTouchesDistance=0,endTouchesDistance=0,pinchZoom=1,pinchDistance=0,pinchDirection=0,maximumsMap=null,$element=$(element),phase="start",fingerCount=0,fingerData={},startTime=0,endTime=0,previousTouchEndTime=0,fingerCountAtRelease=0,doubleTapStartTime=0,singleTapTimeout=null,holdTimeout=null;try{$element.on(START_EV,touchStart),$element.on(CANCEL_EV,touchCancel);}catch(e){$.error("events not supported "+START_EV+","+CANCEL_EV+" on jQuery.swipe");}this.enable=function(){return this.disable(),$element.on(START_EV,touchStart),$element.on(CANCEL_EV,touchCancel),$element},this.disable=function(){return removeListeners(),$element},this.destroy=function(){removeListeners(),$element.data(PLUGIN_NS,null),$element=null;},this.option=function(property,value){if("object"==typeof property)options=$.extend(options,property);else if(void 0!==options[property]){if(void 0===value)return options[property];options[property]=value;}else{if(!property)return options;$.error("Option "+property+" does not exist on jQuery.swipe.options");}return null};}var VERSION="1.6.18",LEFT="left",RIGHT="right",UP="up",DOWN="down",IN="in",OUT="out",NONE="none",AUTO="auto",SWIPE="swipe",PINCH="pinch",TAP="tap",DOUBLE_TAP="doubletap",LONG_TAP="longtap",HORIZONTAL="horizontal",VERTICAL="vertical",ALL_FINGERS="all",DOUBLE_TAP_THRESHOLD=10,PHASE_START="start",PHASE_MOVE="move",PHASE_END="end",PHASE_CANCEL="cancel",SUPPORTS_TOUCH="ontouchstart"in window,SUPPORTS_POINTER_IE10=window.navigator.msPointerEnabled&&!window.PointerEvent&&!SUPPORTS_TOUCH,SUPPORTS_POINTER=(window.PointerEvent||window.navigator.msPointerEnabled)&&!SUPPORTS_TOUCH,PLUGIN_NS="TouchSwipe",defaults={fingers:1,threshold:75,cancelThreshold:null,pinchThreshold:20,maxTimeThreshold:null,fingerReleaseThreshold:250,longTapThreshold:500,doubleTapThreshold:200,swipe:null,swipeLeft:null,swipeRight:null,swipeUp:null,swipeDown:null,swipeStatus:null,pinchIn:null,pinchOut:null,pinchStatus:null,click:null,tap:null,doubleTap:null,longTap:null,hold:null,triggerOnTouchEnd:!0,triggerOnTouchLeave:!1,allowPageScroll:"auto",fallbackToMouseEvents:!0,excludedElements:".noSwipe",preventDefaultEvents:!0};$.fn.swipe=function(method){var $this=$(this),plugin=$this.data(PLUGIN_NS);if(plugin&&"string"==typeof method){if(plugin[method])return plugin[method].apply(plugin,Array.prototype.slice.call(arguments,1));$.error("Method "+method+" does not exist on jQuery.swipe");}else if(plugin&&"object"==typeof method)plugin.option.apply(plugin,arguments);else if(!(plugin||"object"!=typeof method&&method))return init.apply(this,arguments);return $this},$.fn.swipe.version=VERSION,$.fn.swipe.defaults=defaults,$.fn.swipe.phases={PHASE_START:PHASE_START,PHASE_MOVE:PHASE_MOVE,PHASE_END:PHASE_END,PHASE_CANCEL:PHASE_CANCEL},$.fn.swipe.directions={LEFT:LEFT,RIGHT:RIGHT,UP:UP,DOWN:DOWN,IN:IN,OUT:OUT},$.fn.swipe.pageScroll={NONE:NONE,HORIZONTAL:HORIZONTAL,VERTICAL:VERTICAL,AUTO:AUTO},$.fn.swipe.fingers={ONE:1,TWO:2,THREE:3,FOUR:4,FIVE:5,ALL:ALL_FINGERS};});
	});

	/**
	 * Pages module.
	 */

	var pageModule = {
	    active: false,
	    $current: [],
	    $activePages: jquery(),
	    init() {
	        if ( !this.form ) {
	            throw new Error( 'Repeats module not correctly instantiated with form property.' );
	        }
	        if ( this.form.view.$.hasClass( 'pages' ) ) {
	            const $allPages = this.form.view.$.find( ' .question:not([role="comment"]), .or-appearance-field-list' )
	                .add( '.or-repeat.or-appearance-field-list + .or-repeat-info' )
	                .filter( function() {
	                    // something tells me there is a more efficient way to doing this
	                    // e.g. by selecting the descendants of the .or-appearance-field-list and removing those
	                    return jquery( this ).parent().closest( '.or-appearance-field-list' ).length === 0;
	                } )
	                .attr( 'role', 'page' );

	            if ( $allPages.length > 0 || $allPages.eq( 0 ).hasClass( 'or-repeat' ) ) {
	                const formWrapper = this.form.view.html.parentNode;
	                this.$formFooter = jquery( formWrapper.querySelector( '.form-footer' ) );
	                this.$btnFirst = this.$formFooter.find( '.first-page' );
	                this.$btnPrev = this.$formFooter.find( '.previous-page' );
	                this.$btnNext = this.$formFooter.find( '.next-page' );
	                this.$btnLast = this.$formFooter.find( '.last-page' );
	                this.$toc = jquery( formWrapper.querySelector( '.pages-toc__list' ) );
	                this._updateAllActive( $allPages );
	                this._updateToc();
	                this._toggleButtons( 0 );
	                this._setButtonHandlers();
	                this._setRepeatHandlers();
	                this._setBranchHandlers();
	                this._setSwipeHandlers();
	                this._setTocHandlers();
	                this._setLangChangeHandlers();
	                this.active = true;
	                this._flipToFirst();
	            }
	            /*else {
	                form.view.$.removeClass( 'pages' );
	            }*/
	        }
	    },
	    // flips to the page provided as jQueried parameter or the page containing
	    // the jQueried element provided as parameter
	    // alternatively, (e.g. if a top level repeat without field-list appearance is provided as parameter)
	    // it flips to the page contained with the jQueried parameter;
	    flipToPageContaining( $e ) {
	        let $closest;

	        $closest = $e.closest( '[role="page"]' );
	        $closest = ( $closest.length === 0 ) ? $e.find( '[role="page"]' ) : $closest;

	        // If $e is a comment question, and it is not inside a group, there may be no $closest.
	        if ( $closest.length ) {
	            this._flipTo( $closest[ 0 ] );
	        }
	        this.$toc.parent().find( '.pages-toc__overlay' ).click();
	    },
	    _setButtonHandlers() {
	        const that = this;
	        // Make sure eventhandlers are not duplicated after resetting form.
	        this.$btnFirst.off( '.pagemode' ).on( 'click.pagemode', () => {
	            if ( !that.form.pageNavigationBlocked ) {
	                that._flipToFirst();
	            }
	            return false;
	        } );
	        this.$btnPrev.off( '.pagemode' ).on( 'click.pagemode', () => {
	            if ( !that.form.pageNavigationBlocked ) {
	                that._prev();
	            }
	            return false;
	        } );
	        this.$btnNext.off( '.pagemode' ).on( 'click.pagemode', () => {
	            if ( !that.form.pageNavigationBlocked ) {
	                that._next();
	            }
	            return false;
	        } );
	        this.$btnLast.off( '.pagemode' ).on( 'click.pagemode', () => {
	            if ( !that.form.pageNavigationBlocked ) {
	                that._flipToLast();
	            }
	            return false;
	        } );
	    },
	    _setSwipeHandlers() {
	        const that = this;
	        const $main = this.form.view.$.closest( '.main' );

	        $main.swipe( 'destroy' );
	        $main.swipe( {
	            allowPageScroll: 'vertical',
	            threshold: 250,
	            preventDefaultEvents: false,
	            swipeLeft() {
	                that.$btnNext.click();
	            },
	            swipeRight() {
	                that.$btnPrev.click();
	            },
	            swipeStatus( evt, phase ) {
	                if ( phase === 'start' ) {
	                    /*
	                     * Triggering blur will fire a change event on the currently focused form control
	                     * This will trigger validation and is required to block page navigation on swipe 
	                     * with form.pageNavigationBlocked
	                     * The only potential problem with this approach is that the threshold (250ms)
	                     * may theoretically not be sufficient to ensure validation is completed to 
	                     * set form.pageNavigationBlocked to true. The edge case will be very slow devices
	                     * and/or amazingly complex constraint expressions.
	                     */
	                    that._getCurrent().find( ':focus' ).blur();
	                }
	            }
	        } );
	    },
	    _setTocHandlers() {
	        const that = this;
	        this.$toc
	            .on( 'click', 'a', function() {
	                if ( !that.form.pageNavigationBlocked ) {
	                    const index = jquery( this.parentNode ).prevAll().length;
	                    that.flipToPageContaining( jquery( that.tocItems[ index ].pageEl ) );
	                }
	                return false;
	            } )
	            .parent().find( '.pages-toc__overlay' ).on( 'click', () => {
	                that.$toc.parent().find( '#toc-toggle' ).prop( 'checked', false );
	            } );
	    },
	    _setRepeatHandlers() {
	        // TODO: can be optimized by smartly updating the active pages
	        this.form.view.html.addEventListener( event.AddRepeat().type, event => {
	            const byCountUpdate = event.detail ? event.detail[ 1 ] : undefined;
	            this._updateAllActive();
	            // Don't flip if the user didn't create the repeat with the + button.
	            // or if is the default first instance created during loading.
	            // except if the new repeat is actually first page in the form.
	            if ( !byCountUpdate || this.$activePages[ 0 ] === event.target ) {
	                this.flipToPageContaining( jquery( event.target ) );
	            }
	        } );
	        this.form.view.html.addEventListener( event.RemoveRepeat().type, event => {
	            // if the current page is removed
	            // note that that.$current will have length 1 even if it was removed from DOM!
	            if ( this.$current.closest( 'html' ).length === 0 ) {
	                this._updateAllActive();
	                let $target = jquery( event.target ).prev();
	                if ( $target.length === 0 ) {
	                    $target = jquery( event.target );
	                }
	                // is it best to go to previous page always?
	                this.flipToPageContaining( $target );
	            }
	        } );
	    },
	    _setBranchHandlers() {
	        const that = this;
	        // TODO: can be optimized by smartly updating the active pages
	        this.form.view.$
	            //.off( 'changebranch.pagemode' )
	            .on( 'changebranch.pagemode', () => {
	                that._updateAllActive();
	                // If the current page has become inactive (e.g. a form whose first page during load becomes irrelevant)
	                if ( that.$activePages.get().indexOf( that.$current[ 0 ] ) === -1 ) {
	                    that._next();
	                }
	                that._toggleButtons();
	            } );
	    },
	    _setLangChangeHandlers() {
	        this.form.view.html
	            .addEventListener( event.ChangeLanguage().type, () => {
	                this._updateToc();
	            } );
	    },
	    _getCurrent() {
	        return this.$current;
	    },
	    _updateAllActive( $all ) {
	        $all = $all || this.form.view.$.find( '[role="page"]' );
	        this.$activePages = $all.filter( function() {
	            const $this = jquery( this );
	            return $this.closest( '.disabled' ).length === 0 &&
	                ( $this.is( '.question' ) || $this.find( '.question:not(.disabled)' ).length > 0 ||
	                    // or-repeat-info is only considered a page by itself if it has no sibling repeats
	                    // When there are siblings repeats, we use CSS trickery to show the + button underneath the last 
	                    // repeat.
	                    ( $this.is( '.or-repeat-info' ) && $this.siblings( '.or-repeat' ).length === 0 ) );
	        } );
	        this._updateToc();
	    },
	    _getPrev( currentIndex ) {
	        return this.$activePages[ currentIndex - 1 ];
	    },
	    _getNext( currentIndex ) {
	        return this.$activePages[ currentIndex + 1 ];
	    },
	    _getCurrentIndex() {
	        return this.$activePages.index( this.$current );
	    },
	    /**
	     * Changes the `pages.next()` function to return a `Promise`, wrapping one of the following values:
	     *
	     * @return {Promise} wrapping {boolean} or {number}.  If a {number}, this is the index into
	     *         `$activePages` of the new current page; if a {boolean}, {false} means that validation
	     *         failed, and {true} that validation passed, but the page did not change.
	     */
	    _next() {
	        const that = this;
	        let currentIndex;
	        let validate;

	        currentIndex = this._getCurrentIndex();
	        validate = this.form.validateContent( this.$current );

	        return validate
	            .then( valid => {
	                let next, newIndex;

	                if ( !valid ) {
	                    return false;
	                }

	                next = that._getNext( currentIndex );

	                if ( next ) {
	                    newIndex = currentIndex + 1;
	                    that._flipTo( next, newIndex );
	                    //return newIndex;
	                }

	                return true;
	            } );
	    },
	    _prev() {
	        const currentIndex = this._getCurrentIndex();
	        const prev = this._getPrev( currentIndex );

	        if ( prev ) {
	            this._flipTo( prev, currentIndex - 1 );
	        }
	    },
	    _setToCurrent( pageEl ) {
	        const $n = jquery( pageEl );
	        $n.addClass( 'current hidden' );
	        this.$current = $n.removeClass( 'hidden' )
	            .parentsUntil( '.or', '.or-group, .or-group-data, .or-repeat' ).addClass( 'contains-current' ).end();
	    },
	    _flipTo( pageEl, newIndex ) {
	        // if there is a current page
	        if ( this.$current.length > 0 && this.$current.closest( 'html' ).length === 1 ) {
	            // if current page is not same as pageEl
	            if ( this.$current[ 0 ] !== pageEl ) {
	                this.$current.removeClass( 'current fade-out' ).parentsUntil( '.or', '.or-group, .or-group-data, .or-repeat' ).removeClass( 'contains-current' );
	                this._setToCurrent( pageEl );
	                this._focusOnFirstQuestion( pageEl );
	                this._toggleButtons( newIndex );
	                pageEl.dispatchEvent( event.PageFlip() );
	            }
	        } else {
	            this._setToCurrent( pageEl );
	            this._focusOnFirstQuestion( pageEl );
	            this._toggleButtons( newIndex );
	            pageEl.dispatchEvent( event.PageFlip() );
	        }
	    },
	    _flipToFirst() {
	        this._flipTo( this.$activePages[ 0 ] );
	    },
	    _flipToLast() {
	        this._flipTo( this.$activePages.last()[ 0 ] );
	    },

	    _focusOnFirstQuestion( pageEl ) {
	        //triggering fake focus in case element cannot be focused (if hidden by widget)
	        jquery( pageEl )
	            .find( '.question:not(.disabled)' )
	            .addBack( '.question:not(.disabled)' )
	            .filter( function() {
	                return jquery( this ).parentsUntil( '.or', '.disabled' ).length === 0;
	            } )
	            .eq( 0 )
	            .find( 'input, select, textarea' )
	            .eq( 0 )
	            .trigger( 'fakefocus' );

	        pageEl.scrollIntoView();
	    },
	    _toggleButtons( index ) {
	        const i = index || this._getCurrentIndex(),
	            next = this._getNext( i ),
	            prev = this._getPrev( i );
	        this.$btnNext.add( this.$btnLast ).toggleClass( 'disabled', !next );
	        this.$btnPrev.add( this.$btnFirst ).toggleClass( 'disabled', !prev );
	        this.$formFooter.toggleClass( 'end', !next );
	    },
	    _updateToc() {
	        if ( this.$toc.length ) {
	            // regenerate complete ToC from first enabled question/group label of each page
	            this.tocItems = this.$activePages.get()
	                .filter( pageEl => !pageEl.classList.contains( 'or-repeat-info' ) )
	                .map( ( pageEl, index ) => {
	                    let tocItemText = `[${index + 1}]`;
	                    const labelEl = pageEl.querySelector( '.question-label.active' );
	                    if ( labelEl ) {
	                        tocItemText = labelEl.textContent;
	                    } else {
	                        const hintEl = pageEl.querySelector( '.or-hint.active' );
	                        if ( hintEl ) {
	                            tocItemText = hintEl.textContent;
	                        }
	                    }
	                    tocItemText = tocItemText.length > 20 ? `${tocItemText.substring(0,20)}...` : tocItemText;
	                    return { pageEl, tocItemText };
	                } );
	            this.$toc.empty()[ 0 ].append( this._getTocHtmlFragment( this.tocItems ) );
	            this.$toc.closest( '.pages-toc' ).removeClass( 'hide' );
	        }
	    },
	    _getTocHtmlFragment( tocItems ) {
	        const items = document.createDocumentFragment();
	        tocItems.forEach( item => {
	            const li = document.createElement( 'li' );
	            const a = document.createElement( 'a' );
	            a.setAttribute( 'href', `#${item.pageEl.querySelector( '[name]' ).getAttribute( 'name' )}` );
	            a.textContent = item.tocItemText;
	            li.append( a );
	            items.appendChild( li );
	        } );
	        return items;
	    }
	};

	/**
	 * Updates branches
	 *
	 * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
	 */

	var relevantModule = {
	    update( updated, forceClearIrrelevant ) {
	        let $nodes;

	        if ( !this.form ) {
	            throw new Error( 'Branch module not correctly instantiated with form property.' );
	        }

	        $nodes = this.form.getRelatedNodes( 'data-relevant', '', updated );

	        this.updateNodes( $nodes, forceClearIrrelevant );
	    },
	    updateNodes( $nodes, forceClearIrrelevant ) {
	        let p;
	        let $branchNode;
	        let result;
	        let insideRepeat;
	        let insideRepeatClone;
	        let cacheIndex;
	        const relevantCache = {};
	        const alreadyCovered = [];
	        let branchChange = false;
	        const that = this;
	        const clonedRepeatsPresent = this.form.repeatsPresent && this.form.view.html.querySelector( '.or-repeat.clone' );

	        $nodes.each( function() {
	            const $node = jquery( this );
	            let context;
	            let $parentGroups;
	            let pathParts;
	            let parentPath;

	            //note that $(this).attr('name') is not the same as p.path for repeated radiobuttons!
	            if ( alreadyCovered.indexOf( $node.attr( 'name' ) ) !== -1 ) {
	                return;
	            }

	            // since this result is almost certainly not empty, closest() is the most efficient
	            $branchNode = $node.closest( '.or-branch' );

	            p = {};
	            cacheIndex = null;

	            p.relevant = that.form.input.getRelevant( $node );
	            p.path = that.form.input.getName( $node );

	            if ( $branchNode.length !== 1 ) {
	                if ( $node.parentsUntil( '.or', '#or-calculated-items' ).length === 0 ) {
	                    console.error( 'could not find branch node for ', this );
	                }
	                return;
	            }

	            /*
	             * Check if the (calculate without form control) node is part of a repeat that has no instances
	             */
	            pathParts = p.path.split( '/' );
	            if ( pathParts.length > 3 ) {
	                parentPath = pathParts.splice( 0, pathParts.length - 1 ).join( '/' );
	                $parentGroups = that.form.view.$.find( `.or-group[name="${parentPath}"],.or-group-data[name="${parentPath}"]` )
	                    // now remove the groups that have a repeat-info child without repeat instance siblings
	                    .filter( function() {
	                        const $g = jquery( this );
	                        return $g.children( '.or-repeat' ).length > 0 || $g.children( '.or-repeat-info' ).length === 0;
	                    } ); //.eq( index )
	                // If the parent doesn't exist in the DOM it means there is a repeat ancestor and there are no instances of that repeat.
	                // Hence that relevant does not need to be evaluated (and would fail otherwise because the context doesn't exist).
	                if ( $parentGroups.length === 0 ) {
	                    return;
	                }
	            }

	            /*
	             * Determining ancestry is expensive. Using the knowledge most forms don't use repeats and
	             * if they do, they usually don't have cloned repeats during initialization we perform first a check for .repeat.clone.
	             * The first condition is usually false (and is a very quick one-time check) so this presents a big performance boost
	             * (6-7 seconds of loading time on the bench6 form)
	             */
	            // TODO: these checks fail miserably for calculated items that do not have a form control
	            insideRepeat = clonedRepeatsPresent && $branchNode.parentsUntil( '.or', '.or-repeat' ).length > 0;
	            insideRepeatClone = clonedRepeatsPresent && $branchNode.parentsUntil( '.or', '.or-repeat.clone' ).length > 0;

	            /* 
	             * If the relevant is placed on a group and that group contains repeats with the same name,
	             * but currently has 0 repeats, the context will not be available. This same logic is applied in output.js.
	             */
	            if ( $node.children( `.or-repeat-info[data-name="${p.path}"]` ).length && !$node.children( `.or-repeat[name="${p.path}"]` ).length ) {
	                context = null;
	            } else {
	                context = p.path;
	            }
	            /*
	             * Determining the index is expensive, so we only do this when the branch is inside a cloned repeat.
	             * It can be safely set to 0 for other branches.
	             */
	            p.ind = ( context && insideRepeatClone ) ? that.form.input.getIndex( $node ) : 0;
	            /*
	             * Caching is only possible for expressions that do not contain relative paths to nodes.
	             * So, first do a *very* aggresive check to see if the expression contains a relative path.
	             * This check assumes that child nodes (e.g. "mychild = 'bob'") are NEVER used in a relevant
	             * expression, which may prove to be incorrect.
	             */
	            if ( p.relevant.indexOf( '..' ) === -1 ) {
	                if ( !insideRepeat ) {
	                    cacheIndex = p.relevant;
	                } else {
	                    // The path is stripped of the last nodeName to record the context.
	                    // This might be dangerous, but until we find a bug, it helps in those forms where one group contains
	                    // many sibling questions that each have the same relevant.
	                    cacheIndex = `${p.relevant}__${p.path.substring( 0, p.path.lastIndexOf( '/' ) )}__${p.ind}`;
	                }
	            }
	            if ( cacheIndex && typeof relevantCache[ cacheIndex ] !== 'undefined' ) {
	                result = relevantCache[ cacheIndex ];
	            } else {
	                result = that.evaluate( p.relevant, context, p.ind );
	                relevantCache[ cacheIndex ] = result;
	            }

	            if ( !insideRepeat ) {
	                alreadyCovered.push( this.getAttribute( 'name' ) );
	            }

	            if ( that.process( $branchNode, p.path, result, forceClearIrrelevant ) === true ) {
	                branchChange = true;
	            }
	        } );

	        if ( branchChange ) {
	            this.form.view.$.trigger( 'changebranch' );
	        }
	    },
	    /**
	     * Evaluates a relevant expression (for future fancy stuff this is placed in a separate function)
	     *
	     * @param  {string} expr        [description]
	     * @param  {string} contextPath [description]
	     * @param  {number} index       [description]
	     * @return {boolean}             [description]
	     */
	    evaluate( expr, contextPath, index ) {
	        const result = this.form.model.evaluate( expr, 'boolean', contextPath, index );
	        return result;
	    },
	    /**
	     * Processes the evaluation result for a branch
	     *
	     * @param { jQuery } $branchNode [description]
	     * @param { string } path Path of branch node
	     * @param { boolean } result      result of relevant evaluation
	     * @param { =boolean } forceClearIrrelevant Whether to force clearing of irrelevant nodes and descendants
	     */
	    process( $branchNode, path, result, forceClearIrrelevant ) {
	        if ( result === true ) {
	            return this.enable( $branchNode, path );
	        } else {
	            return this.disable( $branchNode, path, forceClearIrrelevant );
	        }
	    },

	    /**
	     * Checks whether branch currently has 'relevant' state
	     *
	     * @param  {jQuery} $branchNode [description]
	     * @return {boolean}             [description]
	     */
	    selfRelevant( $branchNode ) {
	        return !$branchNode.hasClass( 'disabled' ) && !$branchNode.hasClass( 'pre-init' );
	    },

	    /**
	     * Enables and reveals a branch node/group
	     *
	     * @param  {jQuery} $branchNode The jQuery object to reveal and enable
	     */
	    enable( $branchNode, path ) {
	        let change = false;

	        if ( !this.selfRelevant( $branchNode ) ) {
	            change = true;
	            $branchNode.removeClass( 'disabled pre-init' );
	            // Update calculated items, both individual question or descendants of group
	            this.form.calc.update( {
	                relevantPath: path
	            } );
	            this.form.itemset.update( {
	                relevantPath: path
	            } );
	            // Update outputs that are children of branch
	            // TODO this re-evaluates all outputs in the form which is not efficient!
	            this.form.output.update();
	            this.form.widgets.enable( $branchNode[ 0 ] );
	            this.activate( $branchNode );
	        }
	        return change;
	    },

	    /**
	     * Disables and hides a branch node/group
	     *
	     * @param  {jQuery} $branchNode The jQuery object to hide and disable
	     */
	    disable( $branchNode, path, forceClearIrrelevant ) {
	        const virgin = $branchNode.hasClass( 'pre-init' );
	        let change = false;

	        if ( virgin || this.selfRelevant( $branchNode ) || forceClearIrrelevant ) {
	            change = true;
	            // if the branch was previously enabled, keep any default values
	            if ( !virgin ) {
	                if ( this.form.options.clearIrrelevantImmediately || forceClearIrrelevant ) {
	                    this.clear( $branchNode, path );
	                }
	            } else {
	                $branchNode.removeClass( 'pre-init' );
	            }

	            this.deactivate( $branchNode );
	        }
	        return change;
	    },
	    /**
	     * Clears values from branchnode. 
	     * This function is separated so it can be overridden in custom apps.
	     * 
	     * @param  {[type]} $branchNode [description]
	     * @return {boolean}             [description]
	     */
	    clear( $branchNode, path ) {
	        // A change event ensures the model is updated
	        // An inputupdate event is required to update widgets
	        $branchNode.clearInputs( 'change', event.InputUpdate().type );
	        // Update calculated items if branch is a group
	        // We exclude question branches here because those will have been cleared already in the previous line.
	        if ( $branchNode.is( '.or-group, .or-group-data' ) ) {
	            this.form.calc.update( {
	                relevantPath: path
	            } );
	        }
	    },
	    setDisabledProperty( $branchNode, bool ) {
	        const type = $branchNode.prop( 'nodeName' ).toLowerCase();

	        if ( type === 'label' ) {
	            $branchNode.children( 'input, select, textarea' ).prop( 'disabled', bool );
	        } else if ( type === 'fieldset' || type === 'section' ) {
	            // TODO: a <section> cannot be disabled like this
	            $branchNode.prop( 'disabled', bool );
	        } else {
	            $branchNode.find( 'fieldset, input, select, textarea' ).prop( 'disabled', bool );
	        }
	    },
	    /**
	     * Activates form controls.
	     * This function is separated so it can be overridden in custom apps.
	     * 
	     * @param  {[type]} $branchNode [description]
	     * @return {[type]}            [description]
	     */
	    activate( $branchNode ) {
	        this.setDisabledProperty( $branchNode, false );
	    },
	    /**
	     * Deactivates form controls.
	     * This function is separated so it can be overridden in custom apps.
	     * 
	     * @param  {[type]} $branchNode [description]
	     * @return {[type]}             [description]
	     */
	    deactivate( $branchNode ) {
	        $branchNode.addClass( 'disabled' );
	        this.form.widgets.disable( $branchNode[ 0 ] );
	        this.setDisabledProperty( $branchNode, true );
	    }
	};

	/**
	 * Updates itemsets
	 *
	 * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
	 */

	var itemsetModule = {
	    update( updated = {} ) {
	        const that = this;
	        const itemsCache = {};
	        let $nodes;

	        if ( !this.form ) {
	            throw new Error( 'Output module not correctly instantiated with form property.' );
	        }

	        if ( updated.relevantPath ) {
	            // Questions that are descendants of a group:
	            $nodes = this.form.getRelatedNodes( 'data-items-path', `[name^="${updated.relevantPath}/"]` )
	                .add( this.form.getRelatedNodes( 'data-items-path', `[name^="${updated.relevantPath}/"] ~ datalist > .itemset-template` ) )
	                // Individual questions (autocomplete)
	                .add( this.form.getRelatedNodes( 'data-items-path', `[name="${updated.relevantPath}"]` ) )
	                .add( this.form.getRelatedNodes( 'data-items-path', `[name="${updated.relevantPath}"] ~ datalist > .itemset-template` ) )
	                // Individual radiobutton questions with an itemset...:
	                .add( this.form.getRelatedNodes( 'data-items-path', `[data-name="${updated.relevantPath}"]` ) )
	                .add( this.form.getRelatedNodes( 'data-items-path', `[data-name="${updated.relevantPath}"] ~ datalist > .itemset-template` ) );
	        } else {
	            $nodes = this.form.getRelatedNodes( 'data-items-path', '.itemset-template', updated );
	        }

	        const clonedRepeatsPresent = this.form.repeatsPresent && this.form.view.html.querySelector( '.or-repeat.clone' );

	        $nodes.each( function() {
	            let $input;
	            let $instanceItems;
	            const template = this;
	            const $template = jquery( this );
	            const inputAttributes = {};

	            // Nodes are in document order, so we discard any nodes in questions/groups that have a disabled parent
	            if ( $template.parentsUntil( '.or', '.or-branch' ).parentsUntil( '.or', '.disabled' ).length ) {
	                return;
	            }

	            const newItems = {};
	            const prevItems = $template.data();
	            const templateNodeName = $template.prop( 'nodeName' ).toLowerCase();
	            const $list = $template.parent( 'select, datalist' );

	            if ( templateNodeName === 'label' ) {
	                const $optionInput = $template.children( 'input' ).eq( 0 );
	                [].slice.call( $optionInput[ 0 ].attributes ).forEach( attr => {
	                    inputAttributes[ attr.name ] = attr.value;
	                } );
	                // If this is a ranking widget:
	                $input = $optionInput.hasClass( 'ignore' ) ? $optionInput.closest( '.option-wrapper' ).siblings( 'input.rank' ).eq( 0 ) : $optionInput;
	            } else if ( $list.prop( 'nodeName' ).toLowerCase() === 'select' ) {
	                $input = $list;
	            } else if ( $list.prop( 'nodeName' ).toLowerCase() === 'datalist' ) {
	                $input = $list.siblings( 'input:not(.widget)' );
	            }
	            const $labels = $template.closest( 'label, select, datalist' ).siblings( '.itemset-labels' );
	            const itemsXpath = $template.attr( 'data-items-path' );
	            let labelType = $labels.attr( 'data-label-type' );
	            let labelRef = $labels.attr( 'data-label-ref' );
	            // TODO: if translate() becomes official, move determination of labelType to enketo-xslt
	            // and set labelRef correct in enketo-xslt
	            const matches = parseFunctionFromExpression( labelRef, 'translate' );
	            if ( matches.length ) {
	                labelRef = matches[ 0 ][ 1 ][ 0 ];
	                labelType = 'langs';
	            }

	            const valueRef = $labels.attr( 'data-value-ref' );

	            /**
	             * CommCare/ODK change the context to the *itemset* value (in the secondary instance), hence they need to use the current()
	             * function to make sure that relative paths in the nodeset predicate refer to the correct primary instance node
	             * Enketo does *not* change the context. It uses the context of the question, not the itemset. Hence it has no need for current().
	             * I am not sure what is correct, but for now for XLSForm-style secondary instances with only one level underneath the <item>s that
	             * the nodeset retrieves, Enketo's aproach works well.
	             */
	            const context = that.form.input.getName( $input );

	            /*
	             * Determining the index is expensive, so we only do this when the itemset is inside a cloned repeat.
	             * It can be safely set to 0 for other branches.
	             */
	            const insideRepeat = ( clonedRepeatsPresent && $input.parentsUntil( '.or', '.or-repeat' ).length > 0 ) ? true : false;
	            const insideRepeatClone = ( clonedRepeatsPresent && $input.parentsUntil( '.or', '.or-repeat.clone' ).length > 0 ) ? true : false;
	            const index = ( insideRepeatClone ) ? that.form.input.getIndex( $input ) : 0;

	            if ( typeof itemsCache[ itemsXpath ] !== 'undefined' ) {
	                $instanceItems = itemsCache[ itemsXpath ];
	            } else {
	                const safeToTryNative = true;
	                $instanceItems = jquery( that.form.model.evaluate( itemsXpath, 'nodes', context, index, safeToTryNative ) );
	                if ( !insideRepeat ) {
	                    itemsCache[ itemsXpath ] = $instanceItems;
	                }
	            }

	            // This property allows for more efficient 'itemschanged' detection
	            newItems.length = $instanceItems.length;
	            // TODO: This may cause problems for large itemsets. Use md5 instead?
	            newItems.text = $instanceItems.text();

	            if ( newItems.length === prevItems.length && newItems.text === prevItems.text ) {
	                return;
	            }

	            $template.data( newItems );

	            /**
	             * Remove current items before rebuilding a new itemset from scratch.
	             */
	            // the current <option> and <input> elements
	            const $question = $template.closest( '.question' );
	            $question.find( templateNodeName ).not( $template ).remove();
	            // labels for current <option> elements
	            const optionsTranslations = $question.find( '.or-option-translations' ).empty()[ 0 ];
	            const optionsFragment = document.createDocumentFragment();
	            const optionsTranslationsFragment = document.createDocumentFragment();
	            let translations = [];

	            $instanceItems.each( function() {
	                const item = this;
	                /*
	                 * Note: $labelRefs could either be
	                 * - a single itext reference
	                 * - a collection of labels with different lang attributes
	                 * - a single label
	                 */
	                const labels = that.getNodesFromItem( labelRef, item );
	                if ( !labels || !labels.length ) {
	                    translations = [ { language: '', label: 'error', active: true } ];
	                } else {
	                    switch ( labelType ) {
	                        case 'itext':
	                            // Search in the special .itemset-labels created in enketo-transformer for labels with itext ref.
	                            translations = $labels.find( `[data-itext-id="${labels[ 0 ].textContent}"]` ).get().map( label => {
	                                const language = label.getAttribute( 'lang' );
	                                const type = label.nodeName;
	                                const src = label.src;
	                                const text = label.textContent;
	                                const active = label.classList.contains( 'active' );
	                                const alt = label.alt;
	                                return { language, type, text, active, src, alt };
	                            } );
	                            break;
	                        case 'langs':
	                            translations = labels.map( label => {
	                                const lang = label.getAttribute( 'lang' );
	                                // Two falsy values should set active to true.
	                                const active = ( !lang && !that.form.langs.currentLang ) || ( lang === that.form.langs.currentLang );
	                                return { language: lang, type: 'span', text: label.textContent, active };
	                            } );
	                            break;
	                        default:
	                            translations = [ { language: '', type: 'span', text: labels && labels.length ? labels[ 0 ].textContent : 'error', active: true } ];
	                    }
	                }
	                // Obtain the value of the secondary instance item found.
	                const value = that.getNodeFromItem( valueRef, item ).textContent;

	                if ( templateNodeName === 'label' ) {
	                    optionsFragment.appendChild( that.createInput( inputAttributes, translations, value ) );
	                } else if ( templateNodeName === 'option' ) {
	                    let activeLabel = '';
	                    if ( translations.length > 1 ) {
	                        translations.forEach( translation => {
	                            if ( translation.active ) {
	                                activeLabel = translation.text;
	                            }
	                            optionsTranslationsFragment.appendChild( that.createOptionTranslation( translation, value ) );
	                        } );
	                    } else {
	                        activeLabel = translations[ 0 ].text;
	                    }
	                    optionsFragment.appendChild( that.createOption( activeLabel, value ) );
	                }
	            } );

	            template.parentNode.appendChild( optionsFragment );
	            if ( optionsTranslations ) {
	                optionsTranslations.appendChild( optionsTranslationsFragment );
	            }

	            /**
	             * Attempt to populate inputs with current value in model (except for ranking input)
	             * Note that if the current value is not empty and the new itemset does not 
	             * include (an) item(s) with this/se value(s), this will clear/update the model and
	             * this will trigger a dataupdate event. This may call this update function again.
	             */
	            let currentValue = that.form.model.node( context, index ).getVal();
	            if ( currentValue !== '' ) {
	                if ( $input.hasClass( 'rank' ) ) {
	                    currentValue = '';
	                }
	                that.form.input.setVal( $input, currentValue );
	                $input.trigger( 'change' );
	            }

	            if ( $list.length > 0 || $input.hasClass( 'rank' ) ) {
	                $input.trigger( 'changeoption' );
	            }

	        } );
	    },

	    /**
	     * Minimal XPath evaluation helper that queries from a single item context.
	     */
	    getNodesFromItem( expr, context, single ) {
	        if ( !expr || !context ) {
	            throw new Error( 'Error: could not query instance item, no expression and/or context provided' );
	        }
	        const type = single ? 9 : 7;
	        const evaluateFnName = typeof this.form.model.xml.evaluate !== 'undefined' ? 'evaluate' : 'jsEvaluate';
	        const result = this.form.model.xml[ evaluateFnName ]( expr, context, this.form.model.getNsResolver(), type, null );
	        const response = [];
	        if ( !single ) {
	            for ( let j = 0; j < result.snapshotLength; j++ ) {
	                response.push( result.snapshotItem( j ) );
	            }
	        } else {
	            response.push( result.singleNodeValue );
	        }
	        return response;
	    },

	    getNodeFromItem( expr, content ) {
	        const nodes = this.getNodesFromItem( expr, content, true );
	        return nodes.length ? nodes[ 0 ] : null;
	    },

	    createOption( label, value ) {
	        const option = document.createElement( 'option' );
	        option.textContent = label;
	        option.value = value;
	        return option;
	    },

	    createOptionTranslation( translation, value ) {
	        const el = document.createElement( translation.type || 'span' );
	        if ( translation.text ) {
	            el.textContent = translation.text;
	            el.classList.add( 'option-label' );
	        }
	        el.classList.toggle( 'active', translation.active );
	        if ( translation.language ) {
	            el.lang = translation.language;
	        }
	        el.dataset.optionValue = value;
	        if ( translation.src ) {
	            el.src = translation.src;
	            el.alt = translation.alt;
	        }
	        return el;
	    },

	    createInput( attributes, translations, value ) {
	        const that = this;
	        const label = document.createElement( 'label' );
	        const input = document.createElement( 'input' );
	        Object.getOwnPropertyNames( attributes ).forEach( attr => {
	            input.setAttribute( attr, attributes[ attr ] );
	        } );
	        input.value = value;
	        label.appendChild( input );
	        translations.forEach( translation => {
	            label.appendChild( that.createOptionTranslation( translation, value ) );
	        } );
	        return label;
	    }
	};

	/**
	 * Progress module.
	 */

	/**
	 * Maintains progress state of user traversing through form, using
	 * currently focused input || last changed input as current location.
	 */
	var progressModule = {
	    status: 0,
	    lastChanged: null,
	    all: null,
	    updateTotal() {
	        this.all = [ ...this.form.view.html.querySelectorAll( '.question:not(.disabled):not(.or-appearance-comment):not(.or-appearance-dn):not(.readonly)' ) ]
	            .filter( question => !question.closest( '.disabled' ) );
	    },
	    // updates rounded % value of progress and triggers event if changed
	    update( el ) {
	        let status;

	        if ( !this.all || !el ) {
	            this.updateTotal();
	        }

	        this.lastChanged = el || this.lastChanged;
	        if ( this.lastChanged ) {
	            status = Math.round( ( ( this.all.indexOf( this.lastChanged.closest( '.question' ) ) + 1 ) * 100 ) / this.all.length );
	        }

	        // if the current el was removed (inside removed repeat), the status will be 0 - leave unchanged
	        if ( status > 0 && status !== this.status ) {
	            this.status = status;
	            this.form.view.html.dispatchEvent( event.ProgressUpdate( status ) );
	        }
	    },
	    get() {
	        return this.status;
	    }
	};

	// Since this class has no static selector getter, there will be no attempt to instantiate it.
	class NoteWidget {}

	const range = document.createRange();

	/**
	 * A Widget class that can be extended to provide some of the basic widget functionality out of the box.
	 */
	class Widget {
	    /*
	     * @constructor
	     * @param {Element} element The DOM element the widget is applied on
	     * @param {string} name Name of the widget
	     * @param {(boolean|{touch: boolean})} options Options passed to the widget during instantiation
	     */
	    constructor( element, options ) {
	        this.element = element;
	        this.options = options || {};
	        this.question = element.closest( '.question' );
	        this._props = this._getProps();
	        // Some widgets (e.g. ImageMap) initialize asynchronously and init returns a promise.
	        return this._init() || this;
	    }

	    // Meant to be overridden, but automatically called.
	    _init() {
	        // load default value into the widget
	        this.value = this.originalInputValue;
	        // if widget initializes asynchronously return a promise here. Otherwise, return nothing/undefined/null.
	    }

	    // Not meant to be overridden, but could be. Recommend to extend `get props()` instead.
	    _getProps() {
	        const that = this;
	        return {
	            get readonly() { return that.element.nodeName.toLowerCase() === 'select' ? !!that.element.getAttribute( 'readonly' ) : !!that.element.readOnly; },
	            appearances: [ ...this.element.closest( '.question, form.or' ).classList ]
	                .filter( cls => cls.indexOf( 'or-appearance-' ) === 0 )
	                .map( cls => cls.substring( 14 ) ),
	            multiple: !!this.element.multiple,
	            disabled: !!this.element.disabled,
	            type: this.element.getAttribute( 'data-type-xml' ),
	        };
	    }

	    /**
	     * Disallow user input into widget by making it readonly.
	     */
	    disable() {
	        // leave empty in Widget.js
	    }

	    /**
	     * Performs opposite action of disable() function.
	     */
	    enable() {
	        // leave empty in Widget.js
	    }

	    /**
	     * Updates languages, <option>s (cascading selects, and (calculated) values.
	     * Most of the times, this function needs to be overridden in the widget.
	     */
	    update() {}

	    /**
	     * Returns widget properties. May need to be extended.
	     *
	     * @readonly
	     * @memberof Widget
	     */
	    get props() {
	        return this._props;
	    }

	    /**
	     * Returns a HTML document fragment for a reset button.
	     *
	     * @readonly
	     * @memberof Widget
	     */
	    get resetButtonHtml() {
	        return range.createContextualFragment(
	            `<button 
                type="button" 
                class="btn-icon-only btn-reset" 
                aria-label="reset">
                <i class="icon icon-refresh"> </i>
            </button>`
	        );
	    }

	    /**
	     * Returns a HTML document fragment for a download button.
	     *
	     * @readonly
	     * @memberof Widget
	     */
	    get downloadButtonHtml() {
	        return range.createContextualFragment(
	            `<a 
                class="btn-icon-only btn-download" 
                aria-label="download" 
                download 
                href=""><i class="icon icon-download"> </i></a>`
	        );
	    }

	    /**
	     * Obtains the value from the current widget state. Should be overridden.
	     *
	     * @readonly
	     * @memberof Widget
	     */
	    get value() {
	        return undefined;
	    }

	    /**
	     * Sets a value in the widget. Should be overridden.
	     *
	     * @memberof Widget
	     */
	    set value( value ) {}

	    /**
	     * Obtains the value from the original form control the widget is instantiated on.
	     * This form control is often hidden by the widget.
	     *
	     * @readonly
	     * @memberof Widget
	     */
	    get originalInputValue() {
	        return input.getVal( jquery( this.element ) );
	    }

	    /**
	     * Updates the value in the original form control the widget is instantiated on.
	     * This form control is often hidden by the widget.
	     *
	     * @memberof Widget
	     */
	    set originalInputValue( value ) {
	        input.setVal( jquery( this.element ), value, null );
	        this.element.dispatchEvent( event.Change() );
	    }

	    /** 
	     * Returns its own name.
	     * 
	     * @readonly
	     * @static
	     * @memberof Widget
	     */
	    static get name() {
	        return this.constructor.name;
	    }

	    /**
	     * Returns true if the widget is using a list of options.
	     *
	     * @readonly
	     * @static
	     * @memberof Widget
	     */
	    static get list() {
	        return false;
	    }

	    /**
	     * Tests whether widget needs to be instantiated (e.g. if not to be used for touchscreens).
	     * Note that the Element (used in the constructor) will be provided as parameter.
	     */
	    static condition() {
	        return true;
	    }
	}

	const ua = navigator.userAgent;

	// We usually don't need to know which OS is running, but want to know
	// whether a specific OS is runnning.

	const os = {
	    get ios() {
	        return /iPad|iPhone|iPod/i.test( ua );
	    },
	    get android() {
	        return /android/i.test( ua );
	    }
	};

	/**
	 * Detects features.
	 */

	const inputTypes = {};
	let mobile = false;

	// test input types
	[ 'date', 'datetime', 'time', 'month' ].forEach( inputType => {
	    const input = document.createElement( 'input' );
	    input.setAttribute( 'type', inputType );
	    inputTypes[ inputType ] = input.type !== 'text';
	} );

	// The word 'touch' has become misleading. It should be considered 'small mobile' including tablets.
	if ( os.ios || os.android ) {
	    mobile = true;
	    document.documentElement.classList.add( 'touch' );
	}

	var support = {
	    get inputTypes() {
	        return inputTypes;
	    },
	    get touch() {
	        return mobile;
	    },
	    set touch( val ) {
	        mobile = val;
	    }
	};

	// Copied from Bootstrap

	const backdrop = '.dropdown-backdrop';
	const toggle = '[data-toggle=dropdown]';
	const Dropdown = function( element ) {
	    jquery( element ).on( 'click.bs.dropdown', this.toggle );
	};

	Dropdown.prototype.toggle = function( e ) {
	    const $this = jquery( this );

	    if ( $this.is( '.disabled, :disabled' ) ) {
	        return;
	    }

	    const $parent = getParent( $this );
	    const isActive = $parent.hasClass( 'open' );

	    clearMenus();

	    if ( !isActive ) {
	        if ( 'ontouchstart' in document.documentElement && !$parent.closest( '.navbar-nav' ).length ) {
	            // if mobile we use a backdrop because click events don't delegate
	            jquery( '<div class="dropdown-backdrop"/>' ).insertAfter( jquery( this ) ).on( 'click', clearMenus );
	        }

	        const relatedTarget = {
	            relatedTarget: this
	        };
	        $parent.trigger( e = jquery.Event( 'show.bs.dropdown', relatedTarget ) );

	        if ( e.isDefaultPrevented() ) {
	            return;
	        }

	        $parent
	            .toggleClass( 'open' )
	            .trigger( 'shown.bs.dropdown', relatedTarget );

	        $this.focus();
	    }

	    return false;
	};

	Dropdown.prototype.keydown = function( e ) {
	    if ( !/^(38|40|27)$/.test( e.keyCode ) ) {
	        return;
	    }

	    const $this = jquery( this );

	    e.preventDefault();
	    e.stopPropagation();

	    if ( $this.is( '.disabled, :disabled' ) ) {
	        return;
	    }

	    const $parent = getParent( $this );
	    const isActive = $parent.hasClass( 'open' );

	    if ( !isActive || ( isActive && e.keyCode === 27 ) ) {
	        if ( e.which === 27 ) {
	            $parent.find( toggle ).focus();
	        }
	        return $this.click();
	    }

	    const desc = ' li:not(.divider):visible a';
	    const $items = $parent.find( `[role=menu]${desc}, [role=listbox]${desc}` );

	    if ( !$items.length ) {
	        return;
	    }

	    let index = $items.index( $items.filter( ':focus' ) );

	    if ( e.keyCode === 38 && index > 0 ) {
	        index--; // up
	    }
	    if ( e.keyCode === 40 && index < $items.length - 1 ) {
	        index++; // down
	    }
	    if ( !~index ) {
	        index = 0;
	    }

	    $items.eq( index ).focus();
	};

	function clearMenus( e ) {
	    jquery( backdrop ).remove();
	    jquery( toggle ).each( function() {
	        const $parent = getParent( jquery( this ) );
	        const relatedTarget = {
	            relatedTarget: this
	        };
	        if ( !$parent.hasClass( 'open' ) ) {
	            return;
	        }
	        $parent.trigger( e = jquery.Event( 'hide.bs.dropdown', relatedTarget ) );
	        if ( e.isDefaultPrevented() ) {
	            return;
	        }
	        $parent.removeClass( 'open' ).trigger( 'hidden.bs.dropdown', relatedTarget );
	    } );
	}

	function getParent( $this ) {
	    let selector = $this.attr( 'data-target' );

	    if ( !selector ) {
	        selector = $this.attr( 'href' );
	        selector = selector && /#[A-Za-z]/.test( selector ) && selector.replace( /.*(?=#[^\s]*$)/, '' ); //strip for ie7
	    }

	    const $parent = selector && jquery( selector );

	    return $parent && $parent.length ? $parent : $this.parent();
	}


	// DROPDOWN PLUGIN DEFINITION
	// ==========================

	const old = jquery.fn.dropdown;

	jquery.fn.dropdown = function( option ) {
	    return this.each( function() {
	        const $this = jquery( this );
	        const data = $this.data( 'bs.dropdown' );

	        if ( !data ) {
	            $this.data( 'bs.dropdown', new Dropdown( this ) );
	        }
	        if ( typeof option === 'string' ) {
	            data[ option ].call( $this );
	        }
	    } );
	};

	jquery.fn.dropdown.Constructor = Dropdown;


	// DROPDOWN NO CONFLICT
	// ====================

	jquery.fn.dropdown.noConflict = function() {
	    jquery.fn.dropdown = old;
	    return this;
	};


	// APPLY TO STANDARD DROPDOWN ELEMENTS
	// ===================================

	jquery( document )
	    .on( 'click.bs.dropdown.data-api', clearMenus )
	    .on( 'click.bs.dropdown.data-api', '.dropdown form', e => {
	        e.stopPropagation();
	    } )
	    .on( 'click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle )
	    .on( 'keydown.bs.dropdown.data-api', `${toggle}, [role=menu], [role=listbox]`, Dropdown.prototype.keydown );

	/**
	 * This widget is one gigantic mess. It should be replaced entirely.
	 * The replacement should have and use getters and setters for `value` and `originalInputValue`
	 */

	/**
	 * Bootstrap Select picker that supports single and multiple selects
	 * A port of https://github.com/silviomoreto/bootstrap-select
	 *
	 */
	class DesktopSelectpicker extends Widget {

	    static get selector() {
	        return '.question select';
	    }

	    static get list() {
	        return true;
	    }

	    static condition() {
	        return !support.touch;
	    }

	    _init() {
	        const $select = jquery( this.element );
	        $select.css( 'display', 'none' );
	        const $template = this._createLi( this._getTemplate() );
	        this.$picker = $template.insertAfter( $select );
	        if ( this.props.readonly ) {
	            this.disable();
	        }
	        this._clickListener();
	        this._focusListener();
	    }
	    _getTemplate() {
	        return `
        <div class="btn-group bootstrap-select widget clearfix">
            <button type="button" class="btn btn-default dropdown-toggle clearfix" data-toggle="dropdown">
                <span class="selected">__SELECTED_OPTIONS</span><span class="caret"></span>
            </button>
            <ul class="dropdown-menu" role="menu">__ADD_LI</ul>
        </div>`;
	    }

	    _createLi( template ) {
	        const li = [];
	        let liHtml = '';
	        const inputAttr = this.props.multiple ? 'type="checkbox"' : `type="radio" name="${Math.random() * 100000}"`;

	        jquery( this.element ).find( 'option' ).each( function() {
	            li.push( {
	                label: jquery( this ).text(),
	                selected: jquery( this ).is( ':selected' ),
	                value: jquery( this ).attr( 'value' )
	            } );
	        } );

	        if ( li.length > 0 ) {
	            template = template.replace( '__SELECTED_OPTIONS', this._createSelectedStr() );
	            for ( let i = 0; i < li.length; i++ ) {
	                if ( li[ i ].value ) {
	                    const checkedInputAttr = li[ i ].selected ? ' checked="checked"' : '';
	                    const checkedLiAttr = li[ i ].selected ? 'class="active"' : '';
	                    /**
	                     * e.g.:
	                     * <li checked="checked">
	                     *   <a class="option-wrapper" tabindex="-1" href="#">
	                     *         <label>
	                     *           <input class="ignore" type="checkbox" checked="checked" value="a"/>
	                     *         </label>
	                     *       </a>
	                     *    </li>
	                     */
	                    liHtml += `
                    <li ${checkedLiAttr}>
                        <a class="option-wrapper" tabindex="-1" href="#">
                            <label>
                                <input class="ignore" ${inputAttr}${checkedInputAttr} value="${li[ i ].value}" />
                                <span class="option-label">${li[ i ].label}</span>
                            </label>
                        </a>
                    </li>`;
	                }
	            }
	        }

	        template = template.replace( '__ADD_LI', liHtml );

	        return jquery( template );
	    }


	    /**
	     * create text to show in closed picker
	     * @param  {jQuery=} $select  jQuery-wrapped select element
	     * @return {string}
	     */
	    _createSelectedStr() {
	        const selectedLabels = [];
	        const $select = jquery( this.element );
	        $select.find( 'option:selected' ).each( function() {
	            if ( jquery( this ).attr( 'value' ).length > 0 ) {
	                selectedLabels.push( jquery( this ).text() );
	            }
	        } );

	        if ( selectedLabels.length === 0 ) {
	            return t( 'selectpicker.noneselected' );
	        } else if ( selectedLabels.length === 1 ) {
	            return selectedLabels[ 0 ];
	        } else {
	            return t( 'selectpicker.numberselected', {
	                number: selectedLabels.length
	            } );
	        }
	    }

	    _clickListener() {
	        const _this = this;

	        this.$picker
	            .on( 'click', 'li:not(.disabled)', function( e ) {
	                const li = this;
	                const input = li.querySelector( 'input' );
	                const select = _this.element;
	                const option = select.querySelector( `option[value="${input.value}"]` );
	                const selectedBefore = option.matches( ':checked' );

	                // We need to prevent default unless click was on an input
	                // Without this 'fix', clicks on radiobuttons/checkboxes themselves will update the value
	                // but will not show checked status.
	                if ( e.target.nodeName.toLowerCase() !== 'input' ) {
	                    e.preventDefault();
	                }

	                if ( !_this.props.multiple ) {
	                    _this.$picker.find( 'li' ).removeClass( 'active' );
	                    getSiblingElementsAndSelf( option, 'option' ).forEach( el => { el.selected = false; } );
	                    _this.$picker.find( 'input' ).prop( 'checked', false );
	                } else {
	                    //don't close dropdown for multiple select
	                    e.stopPropagation();
	                }

	                // For issue https://github.com/kobotoolbox/enketo-express/issues/1122 in FF,
	                // we had to use event.preventDefault() on <a> tag click events.
	                // This broke view updates when clicking on the radiobuttons and checkboxes directly
	                // although the underlying values did change correctly.
	                // 
	                // It has to do with event propagation. I could not figure out how to fix it.
	                // Therefore I used a workaround by slightly delaying the status changes.
	                setTimeout( () => {
	                    if ( selectedBefore ) {
	                        li.classList.remove( 'active' );
	                        input.checked = false;
	                        option.selected = false;
	                    } else {
	                        li.classList.add( 'active' );
	                        option.selected = true;
	                        input.checked = true;
	                    }

	                    _this.$picker.find( '.selected' ).html( _this._createSelectedStr() );
	                    select.dispatchEvent( new event.Change() );
	                }, 10 );

	            } )
	            .on( 'keydown', 'li:not(.disabled)', e => {
	                const keyCode = e.keyCode.toString( 10 );
	                // Enter/Space keys
	                if ( /(13|32)/.test( keyCode ) ) {
	                    if ( !/(32)/.test( keyCode ) ) {
	                        e.preventDefault();
	                    }
	                    const elem = jquery( ':focus' );
	                    elem.click();
	                    // Bring back focus for multiselects
	                    elem.focus();
	                    // Prevent screen from scrolling if the user hit the spacebar
	                    e.preventDefault();
	                }
	            } )
	            .on( 'click', 'li.disabled', e => {
	                e.stopPropagation();
	                return false;
	            } )
	            .on( 'click', 'a', e => {
	                // Prevent FF from adding empty anchor to URL if checkbox or radiobutton is clicked.
	                // https://github.com/kobotoolbox/enketo-express/issues/1122
	                e.preventDefault();
	            } );
	    }

	    _focusListener() {
	        const _this = this;

	        // Focus on original element (form.goTo functionality)
	        this.element.addEventListener( event.ApplyFocus().type, () => {
	            _this.$picker.find( '.dropdown-toggle' ).focus();
	        } );

	    }

	    disable() {
	        this.$picker[ 0 ].querySelectorAll( 'li' ).forEach( el => {
	            el.classList.add( 'disabled' );
	            const input = el.querySelector( 'input' );
	            // are both below necessary?
	            input.disabled = true;
	            input.readOnly = true;
	        } );
	    }

	    enable() {
	        this.$picker[ 0 ].querySelectorAll( 'li' ).forEach( el => {
	            el.classList.remove( 'disabled' );
	            const input = el.querySelector( 'input' );
	            input.disabled = false;
	            input.readOnly = false;
	        } );

	    }

	    update() {
	        this.$picker.remove();
	        this._init();
	    }
	}

	/**
	 * An enhancement for the native multi-selectpicker found on most mobile devices,
	 * that shows the selected values next to the select box
	 */
	class MobileSelectPicker extends Widget {

	    static get selector() {
	        return '.question select[multiple]';
	    }

	    static condition() {
	        return support.touch;
	    }

	    _init() {
	        const fragment = document.createRange().createContextualFragment( '<span class="widget mobileselect"></span>' );
	        this.element.after( fragment );
	        this.widget = this.element.parentElement.querySelector( '.widget' );

	        // Show values on change
	        this.element.addEventListener( 'change', () => {
	            this._showSelectedValues();
	        } );

	        // Show defaults
	        this._showSelectedValues();
	    }

	    /**
	     * Display the selected values
	     */
	    _showSelectedValues() {
	        this.widget.textContent = this.originalInputValue.join( ', ' );
	    }

	    update() {
	        this._showSelectedValues();
	    }
	}

	// from: https://github.com/CSS-Tricks/Relevant-Dropdowns/blob/master/js/jquery.relevant-dropdown.js

	const pluginName = 'relevantDropdown';

	// Make jQuery's :contains case insensitive (like HTML5 datalist)
	// Changed the name to prevent overriding original functionality
	jquery.expr[ ':' ].RD_contains = jquery.expr.createPseudo( arg => elem => jquery( elem ).text().toUpperCase().indexOf( arg.toUpperCase() ) >= 0 );

	function RelevantDropdown( element, options, e ) {
	    this.namespace = pluginName;
	    //widget.call( this, element, options );
	    this.element = element;
	    this.options = jquery.extend( {
	        fadeOutSpeed: 'normal', // speed to fade out the dataList Popup
	        change: null
	    }, options );
	    if ( e ) {
	        e.stopPropagation();
	        e.preventDefault();
	    }
	    this._init();
	}

	RelevantDropdown.prototype._init = function() {
	    const $input = jquery( this.element );
	    this.listId = $input.attr( 'list' );

	    // Insert home for new fake datalist
	    this.$fakeDatalist = jquery( '<ul />', {
	        'class': 'datalist widget',
	        'id': this.listId
	    } ).appendTo( $input.parent() );

	    this._updateFakeDatalist();
	    this._setEventListeners();
	};

	RelevantDropdown.prototype._updateFakeDatalist = function() {
	    //console.log( 'changing options' );
	    const $datalist = jquery( `#${this.listId}` );
	    // Used to prevent reflow
	    const tempItems = document.createDocumentFragment();

	    this.$fakeDatalist.empty();

	    // Fill empty fake datalist
	    $datalist.find( 'option' ).each( function() {
	        const tempItem = jquery( '<li />', {
	            // .val is required here, not .text or .html
	            // HTML *needs* to be <option value='xxx'> not <option>xxx</option>  (IE)
	            'text': jquery( this ).val()
	        } )[ 0 ];
	        tempItems.appendChild( tempItem );
	    } );
	    this.$fakeDatalist.append( tempItems );

	    // Update pointer
	    this.$fakeDatalistItems = this.$fakeDatalist.find( 'li' );

	    // console.debug( 'new items', this.$fakeDatalistItems.get() );
	};

	RelevantDropdown.prototype._setEventListeners = function() {
	    const that = this;
	    const $input = jquery( this.element );

	    let searchPosition;
	    let scrollValue = 0;
	    // Typey type type
	    $input
	        .on( 'focus', () => {
	            //console.debug( 'focus', this );
	            // Reset scroll
	            that.$fakeDatalist.scrollTop( 0 );
	            scrollValue = 0;
	        } )
	        .on( 'blur', () => {
	            //console.debug( 'blur', this );
	            // If this fires immediately, it prevents click-to-select from working
	            setTimeout( () => {
	                that.$fakeDatalist.fadeOut( that.options.fadeOutSpeed );
	                that.$fakeDatalistItems.removeClass( 'active' );
	            }, 500 );
	        } )
	        .on( 'keyup', function( e ) {
	            searchPosition = $input.position();
	            //console.log( 'keyup or focus', searchPosition );
	            // Build datalist
	            that.$fakeDatalist
	                .show()
	                .css( {
	                    top: searchPosition.top + jquery( this ).outerHeight(),
	                    left: searchPosition.left,
	                    width: $input.outerWidth()
	                } );

	            that.$fakeDatalistItems.hide();
	            // console.log( 'finding items containing', $input.val() ) );
	            that.$fakeDatalist.find( `li:RD_contains("${$input.val()}")` ).show();
	        } );

	    // Don't want to use :hover in CSS so doing this instead
	    // really helps with arrow key navigation
	    this.$fakeDatalist
	        .on( 'mouseenter', 'li', function() {
	            // console.debug( 'mouseenter', this );
	            jquery( this ).addClass( 'active' ).siblings().removeClass( 'active' );
	        } )
	        .on( 'mouseleave', 'li', function() {
	            // console.debug( 'mouseleave', this );
	            jquery( this ).removeClass( 'active' );
	        } );

	    // Window resize
	    jquery( window ).resize( function() {
	        // console.debug( 'resize' );
	        searchPosition = $input.position();
	        that.$fakeDatalist
	            .css( {
	                top: searchPosition.top + jquery( this ).outerHeight(),
	                left: searchPosition.left,
	                width: $input.outerWidth()
	            } );
	    } );

	    // Watch arrow keys for up and down
	    $input.on( 'keydown', e => {
	        // console.debug( 'keydown' );
	        const active = that.$fakeDatalist.find( 'li.active' );
	        const datalistHeight = that.$fakeDatalist.outerHeight();
	        const datalistItemsHeight = that.$fakeDatalistItems.outerHeight();

	        // up arrow
	        if ( e.keyCode == 38 ) {
	            if ( active.length ) {
	                prevAll = active.prevAll( 'li:visible' );
	                if ( prevAll.length > 0 ) {
	                    active.removeClass( 'active' );
	                    prevAll.eq( 0 ).addClass( 'active' );
	                }

	                if ( prevAll.length && prevAll.position().top < 0 && scrollValue > 0 ) {
	                    that.$fakeDatalist.scrollTop( scrollValue -= datalistItemsHeight );
	                }
	            }
	        }

	        // down arrow
	        if ( e.keyCode == 40 ) {
	            if ( active.length ) {
	                const nextAll = active.nextAll( 'li:visible' );
	                if ( nextAll.length > 0 ) {
	                    active.removeClass( 'active' );
	                    nextAll.eq( 0 ).addClass( 'active' );
	                }

	                if ( nextAll.length && ( nextAll.position().top + datalistItemsHeight ) >= datalistHeight ) {
	                    that.$fakeDatalist.stop().animate( {
	                        scrollTop: scrollValue += datalistItemsHeight
	                    }, 200 );
	                }
	            } else {
	                that.$fakeDatalistItems.removeClass( 'active' );
	                that.$fakeDatalist.find( 'li:visible:first' ).addClass( 'active' );
	            }
	        }

	        // return or tab key
	        if ( e.keyCode == 13 || e.keyCode == 9 ) {
	            if ( active.length ) {
	                $input.val( active.text() ).trigger( 'input' );
	            }
	            that.$fakeDatalist.fadeOut( that.options.fadeOutSpeed );
	            that.$fakeDatalistItems.removeClass( 'active' );
	        }

	        // keys
	        if ( e.keyCode != 13 && e.keyCode != 38 && e.keyCode != 40 ) {
	            // Reset active class
	            that.$fakeDatalistItems.removeClass( 'active' );
	            that.$fakeDatalist.find( 'li:visible:first' ).addClass( 'active' );

	            // Reset scroll
	            that.$fakeDatalist.scrollTop( 0 );
	            scrollValue = 0;
	        }

	    } );

	    // When choosing from dropdown
	    this.$fakeDatalist.on( 'click', 'li', function() {
	        // console.debug( 'click', this );
	        const active = jquery( 'li.active' );
	        if ( active.length ) {
	            $input.val( jquery( this ).text() ).trigger( 'input' );
	        }
	        that.$fakeDatalist.fadeOut( that.options.fadeOutSpeed );
	        that.$fakeDatalistItems.removeClass( 'active' );
	    } );

	};

	RelevantDropdown.prototype.update = function() {
	    this._updateFakeDatalist();
	};

	jquery.fn[ pluginName ] = function( options, event ) {

	    options = options || {};

	    return this.each( function() {
	        const $this = jquery( this );
	        let data = $this.data( pluginName );

	        //only instantiate if options is an object
	        if ( !data && typeof options === 'object' ) {
	            $this.data( pluginName, ( data = new RelevantDropdown( this, options, event ) ) );
	        } else if ( data && typeof options === 'string' ) {
	            data[ options ]( this );
	        }
	    } );
	};

	const sadExcuseForABrowser = !( 'list' in document.createElement( 'input' ) &&
	    'options' in document.createElement( 'datalist' ) &&
	    typeof window.HTMLDataListElement !== 'undefined' );

	/**
	 * Autocomplete select1 picker for modern browsers.
	 */
	class AutocompleteSelectpicker extends Widget {

	    static get selector() {
	        return '.question input[list]';
	    }

	    static get list() {
	        return true;
	    }

	    _init() {
	        const listId = this.element.getAttribute( 'list' );

	        this.options = [ ...this.question.querySelectorAll( `datalist#${listId} > option` ) ];

	        // This value -> data-value change is not slow, so no need to move to enketo-xslt as that would 
	        // increase itemset complexity even further.
	        this.options.forEach( item => {
	            const value = item.getAttribute( 'value' );
	            /**
	             * We're changing the original datalist here, so have to make sure we don't do anything
	             * if dataset.value is already populated.
	             * 
	             * However, for some reason !item.dataset.value is failing in Safari, which as a result sets all dataset.value attributes to "null" 
	             * To workaround this, we check for the value attribute instead.
	             */
	            if ( !item.classList.contains( 'itemset-template' ) && item.textContent && value !== undefined && value !== null ) {
	                item.dataset.value = value;
	                item.setAttribute( 'value', item.textContent );
	                item.textContent = '';
	            }
	        } );

	        const fragment = document
	            .createRange()
	            .createContextualFragment( `<input type="text" class="ignore widget autocomplete" list="${listId}" />` );
	        this.element.classList.add( 'hide' );
	        this.element.after( fragment );

	        this.fakeInput = this.element.parentElement.querySelector( 'input.autocomplete' );

	        if ( this.props.readonly ) {
	            this.fakeInput.setAttribute( 'readonly', 'readonly' );
	        }
	        if ( this.props.disabled ) {
	            this.fakeInput.setAttribute( 'disabled', 'disabled' );
	        }

	        if ( sadExcuseForABrowser ) {
	            console.debug( 'Polyfill required' );
	            // don't bother de-jqueryfying this I think, since it's only for IE11 now I think (and we'll remove IE11 support).
	            jquery( this.fakeInput ).relevantDropdown();
	        }

	        this._setFakeInputListener();
	        this._setFocusListener();
	        this._showCurrentLabel(); // after setting fakeInputListener!
	    }

	    _showCurrentLabel() {
	        const inputValue = this.originalInputValue;
	        const label = this._findLabel( inputValue );

	        this.fakeInput.value = label;

	        // If a corresponding label cannot be found the value is invalid,
	        // and should be cleared. For this we trigger an 'input' event.
	        if ( inputValue && !label ) {
	            this.fakeInput.dispatchEvent( event.Input() );
	        }
	    }

	    _setFakeInputListener() {
	        this.fakeInput.addEventListener( 'input', e => {
	            const input = e.target;
	            const label = input.value;
	            const value = this._findValue( label ) || '';
	            if ( this.originalInputValue !== value ) {
	                this.originalInputValue = value;
	            }
	            input.classList.toggle( 'notfound', label && !value );
	        } );
	    }

	    _findValue( label ) {
	        let value = '';

	        if ( !label ) {
	            return '';
	        }

	        this.options.forEach( option => {
	            if ( option.value === label ) {
	                value = option.getAttribute( 'data-value' );
	                return false;
	            }
	        } );

	        return value;
	    }

	    _findLabel( value ) {
	        let label = '';

	        if ( !value ) {
	            return '';
	        }

	        this.options.forEach( option => {
	            if ( option.dataset.value === value ) {
	                label = option.value;
	                return false;
	            }
	        } );
	        return label;
	    }

	    _setFocusListener() {
	        // Handle original input focus
	        this.element.addEventListener( event.ApplyFocus().type, () => {
	            this.fakeInput.focus();
	        } );
	    }

	    disable() {
	        this.fakeInput.classList.add( 'disabled' );
	    }

	    enable() {
	        this.fakeInput.classList.remove( 'disabled' );

	    }

	    update() {
	        /*
	         * There are 3 scenarios for which method is called:
	         * 1. The options change (dynamic itemset)
	         * 2. The language changed. (just this._showCurrentLabel() would be more efficient)
	         * 3. The value of the underlying original input changed due a calculation. (same as #2?)
	         * 
	         * For now we just dumbly reinstantiate it (including the polyfill).
	         */
	        this.element.parentElement.querySelector( '.widget' ).remove();
	        this._init();
	    }
	}

	var leafletSrc = createCommonjsModule(function (module, exports) {
	/* @preserve
	 * Leaflet 1.4.0, a JS library for interactive maps. http://leafletjs.com
	 * (c) 2010-2018 Vladimir Agafonkin, (c) 2010-2011 CloudMade
	 */

	(function (global, factory) {
		factory(exports);
	}(commonjsGlobal, (function (exports) {
	var version = "1.4.0";

	/*
	 * @namespace Util
	 *
	 * Various utility functions, used by Leaflet internally.
	 */

	var freeze = Object.freeze;
	Object.freeze = function (obj) { return obj; };

	// @function extend(dest: Object, src?: Object): Object
	// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
	function extend(dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	}

	// @function create(proto: Object, properties?: Object): Object
	// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
	var create = Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})();

	// @function bind(fn: Function, …): Function
	// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	// Has a `L.bind()` shortcut.
	function bind(fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	}

	// @property lastId: Number
	// Last unique ID used by [`stamp()`](#util-stamp)
	var lastId = 0;

	// @function stamp(obj: Object): Number
	// Returns the unique ID of an object, assigning it one if it doesn't have it.
	function stamp(obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++lastId;
		return obj._leaflet_id;
		/* eslint-enable */
	}

	// @function throttle(fn: Function, time: Number, context: Object): Function
	// Returns a function which executes function `fn` with the given scope `context`
	// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
	// `fn` will be called no more than one time per given amount of `time`. The arguments
	// received by the bound function will be any arguments passed when binding the
	// function, followed by any arguments passed when invoking the bound function.
	// Has an `L.throttle` shortcut.
	function throttle(fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	}

	// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
	// Returns the number `num` modulo `range` in such a way so it lies within
	// `range[0]` and `range[1]`. The returned value will be always smaller than
	// `range[1]` unless `includeMax` is set to `true`.
	function wrapNum(x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	}

	// @function falseFn(): Function
	// Returns a function which always returns `false`.
	function falseFn() { return false; }

	// @function formatNum(num: Number, digits?: Number): Number
	// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
	function formatNum(num, digits) {
		var pow = Math.pow(10, (digits === undefined ? 6 : digits));
		return Math.round(num * pow) / pow;
	}

	// @function trim(str: String): String
	// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
	function trim(str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	}

	// @function splitWords(str: String): String[]
	// Trims and splits the string on whitespace and returns the array of parts.
	function splitWords(str) {
		return trim(str).split(/\s+/);
	}

	// @function setOptions(obj: Object, options: Object): Object
	// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
	function setOptions(obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	}

	// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
	// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
	// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
	// be appended at the end. If `uppercase` is `true`, the parameter names will
	// be uppercased (e.g. `'?A=foo&B=bar'`)
	function getParamString(obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	}

	var templateRe = /\{ *([\w_-]+) *\}/g;

	// @function template(str: String, data: Object): String
	// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
	// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
	// `('Hello foo, bar')`. You can also specify functions instead of strings for
	// data values — they will be evaluated passing `data` as an argument.
	function template(str, data) {
		return str.replace(templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	}

	// @function isArray(obj): Boolean
	// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
	var isArray = Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	};

	// @function indexOf(array: Array, el: Object): Number
	// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
	function indexOf(array, el) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === el) { return i; }
		}
		return -1;
	}

	// @property emptyImageUrl: String
	// Data URI string containing a base64-encoded empty GIF image.
	// Used as a hack to free memory from unused images on WebKit-powered
	// mobile devices (by setting image `src` to this string).
	var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
	var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
			getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

	// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
	// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
	// `context` if given. When `immediate` is set, `fn` is called immediately if
	// the browser doesn't have native support for
	// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
	// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
	function requestAnimFrame(fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, bind(fn, context));
		}
	}

	// @function cancelAnimFrame(id: Number): undefined
	// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
	function cancelAnimFrame(id) {
		if (id) {
			cancelFn.call(window, id);
		}
	}


	var Util = (Object.freeze || Object)({
		freeze: freeze,
		extend: extend,
		create: create,
		bind: bind,
		lastId: lastId,
		stamp: stamp,
		throttle: throttle,
		wrapNum: wrapNum,
		falseFn: falseFn,
		formatNum: formatNum,
		trim: trim,
		splitWords: splitWords,
		setOptions: setOptions,
		getParamString: getParamString,
		template: template,
		isArray: isArray,
		indexOf: indexOf,
		emptyImageUrl: emptyImageUrl,
		requestFn: requestFn,
		cancelFn: cancelFn,
		requestAnimFrame: requestAnimFrame,
		cancelAnimFrame: cancelAnimFrame
	});

	// @class Class
	// @aka L.Class

	// @section
	// @uninheritable

	// Thanks to John Resig and Dean Edwards for inspiration!

	function Class() {}

	Class.extend = function (props) {

		// @function extend(props: Object): Function
		// [Extends the current class](#class-inheritance) given the properties to be included.
		// Returns a Javascript function that is a class constructor (to be called with `new`).
		var NewClass = function () {

			// call the constructor
			if (this.initialize) {
				this.initialize.apply(this, arguments);
			}

			// call all constructor hooks
			this.callInitHooks();
		};

		var parentProto = NewClass.__super__ = this.prototype;

		var proto = create(parentProto);
		proto.constructor = NewClass;

		NewClass.prototype = proto;

		// inherit parent's statics
		for (var i in this) {
			if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
				NewClass[i] = this[i];
			}
		}

		// mix static properties into the class
		if (props.statics) {
			extend(NewClass, props.statics);
			delete props.statics;
		}

		// mix includes into the prototype
		if (props.includes) {
			checkDeprecatedMixinEvents(props.includes);
			extend.apply(null, [proto].concat(props.includes));
			delete props.includes;
		}

		// merge options
		if (proto.options) {
			props.options = extend(create(proto.options), props.options);
		}

		// mix given properties into the prototype
		extend(proto, props);

		proto._initHooks = [];

		// add method for calling all hooks
		proto.callInitHooks = function () {

			if (this._initHooksCalled) { return; }

			if (parentProto.callInitHooks) {
				parentProto.callInitHooks.call(this);
			}

			this._initHooksCalled = true;

			for (var i = 0, len = proto._initHooks.length; i < len; i++) {
				proto._initHooks[i].call(this);
			}
		};

		return NewClass;
	};


	// @function include(properties: Object): this
	// [Includes a mixin](#class-includes) into the current class.
	Class.include = function (props) {
		extend(this.prototype, props);
		return this;
	};

	// @function mergeOptions(options: Object): this
	// [Merges `options`](#class-options) into the defaults of the class.
	Class.mergeOptions = function (options) {
		extend(this.prototype.options, options);
		return this;
	};

	// @function addInitHook(fn: Function): this
	// Adds a [constructor hook](#class-constructor-hooks) to the class.
	Class.addInitHook = function (fn) { // (Function) || (String, args...)
		var args = Array.prototype.slice.call(arguments, 1);

		var init = typeof fn === 'function' ? fn : function () {
			this[fn].apply(this, args);
		};

		this.prototype._initHooks = this.prototype._initHooks || [];
		this.prototype._initHooks.push(init);
		return this;
	};

	function checkDeprecatedMixinEvents(includes) {
		if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

		includes = isArray(includes) ? includes : [includes];

		for (var i = 0; i < includes.length; i++) {
			if (includes[i] === L.Mixin.Events) {
				console.warn('Deprecated include of L.Mixin.Events: ' +
					'this property will be removed in future releases, ' +
					'please inherit from L.Evented instead.', new Error().stack);
			}
		}
	}

	/*
	 * @class Evented
	 * @aka L.Evented
	 * @inherits Class
	 *
	 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
	 *
	 * @example
	 *
	 * ```js
	 * map.on('click', function(e) {
	 * 	alert(e.latlng);
	 * } );
	 * ```
	 *
	 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
	 *
	 * ```js
	 * function onClick(e) { ... }
	 *
	 * map.on('click', onClick);
	 * map.off('click', onClick);
	 * ```
	 */

	var Events = {
		/* @method on(type: String, fn: Function, context?: Object): this
		 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
		 *
		 * @alternative
		 * @method on(eventMap: Object): this
		 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
		 */
		on: function (types, fn, context) {

			// types can be a map of types/handlers
			if (typeof types === 'object') {
				for (var type in types) {
					// we don't process space-separated events here for performance;
					// it's a hot path since Layer uses the on(obj) syntax
					this._on(type, types[type], fn);
				}

			} else {
				// types can be a string of space-separated words
				types = splitWords(types);

				for (var i = 0, len = types.length; i < len; i++) {
					this._on(types[i], fn, context);
				}
			}

			return this;
		},

		/* @method off(type: String, fn?: Function, context?: Object): this
		 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
		 *
		 * @alternative
		 * @method off(eventMap: Object): this
		 * Removes a set of type/listener pairs.
		 *
		 * @alternative
		 * @method off: this
		 * Removes all listeners to all events on the object.
		 */
		off: function (types, fn, context) {

			if (!types) {
				// clear all listeners if called without arguments
				delete this._events;

			} else if (typeof types === 'object') {
				for (var type in types) {
					this._off(type, types[type], fn);
				}

			} else {
				types = splitWords(types);

				for (var i = 0, len = types.length; i < len; i++) {
					this._off(types[i], fn, context);
				}
			}

			return this;
		},

		// attach listener (without syntactic sugar now)
		_on: function (type, fn, context) {
			this._events = this._events || {};

			/* get/init listeners for type */
			var typeListeners = this._events[type];
			if (!typeListeners) {
				typeListeners = [];
				this._events[type] = typeListeners;
			}

			if (context === this) {
				// Less memory footprint.
				context = undefined;
			}
			var newListener = {fn: fn, ctx: context},
			    listeners = typeListeners;

			// check if fn already there
			for (var i = 0, len = listeners.length; i < len; i++) {
				if (listeners[i].fn === fn && listeners[i].ctx === context) {
					return;
				}
			}

			listeners.push(newListener);
		},

		_off: function (type, fn, context) {
			var listeners,
			    i,
			    len;

			if (!this._events) { return; }

			listeners = this._events[type];

			if (!listeners) {
				return;
			}

			if (!fn) {
				// Set all removed listeners to noop so they are not called if remove happens in fire
				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].fn = falseFn;
				}
				// clear all listeners for a type if function isn't specified
				delete this._events[type];
				return;
			}

			if (context === this) {
				context = undefined;
			}

			if (listeners) {

				// find fn and remove it
				for (i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					if (l.ctx !== context) { continue; }
					if (l.fn === fn) {

						// set the removed listener to noop so that's not called if remove happens in fire
						l.fn = falseFn;

						if (this._firingCount) {
							/* copy array in case events are being fired */
							this._events[type] = listeners = listeners.slice();
						}
						listeners.splice(i, 1);

						return;
					}
				}
			}
		},

		// @method fire(type: String, data?: Object, propagate?: Boolean): this
		// Fires an event of the specified type. You can optionally provide an data
		// object — the first argument of the listener function will contain its
		// properties. The event can optionally be propagated to event parents.
		fire: function (type, data, propagate) {
			if (!this.listens(type, propagate)) { return this; }

			var event = extend({}, data, {
				type: type,
				target: this,
				sourceTarget: data && data.sourceTarget || this
			});

			if (this._events) {
				var listeners = this._events[type];

				if (listeners) {
					this._firingCount = (this._firingCount + 1) || 1;
					for (var i = 0, len = listeners.length; i < len; i++) {
						var l = listeners[i];
						l.fn.call(l.ctx || this, event);
					}

					this._firingCount--;
				}
			}

			if (propagate) {
				// propagate the event to parents (set with addEventParent)
				this._propagateEvent(event);
			}

			return this;
		},

		// @method listens(type: String): Boolean
		// Returns `true` if a particular event type has any listeners attached to it.
		listens: function (type, propagate) {
			var listeners = this._events && this._events[type];
			if (listeners && listeners.length) { return true; }

			if (propagate) {
				// also check parents for listeners if event propagates
				for (var id in this._eventParents) {
					if (this._eventParents[id].listens(type, propagate)) { return true; }
				}
			}
			return false;
		},

		// @method once(…): this
		// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
		once: function (types, fn, context) {

			if (typeof types === 'object') {
				for (var type in types) {
					this.once(type, types[type], fn);
				}
				return this;
			}

			var handler = bind(function () {
				this
				    .off(types, fn, context)
				    .off(types, handler, context);
			}, this);

			// add a listener that's executed once and removed after that
			return this
			    .on(types, fn, context)
			    .on(types, handler, context);
		},

		// @method addEventParent(obj: Evented): this
		// Adds an event parent - an `Evented` that will receive propagated events
		addEventParent: function (obj) {
			this._eventParents = this._eventParents || {};
			this._eventParents[stamp(obj)] = obj;
			return this;
		},

		// @method removeEventParent(obj: Evented): this
		// Removes an event parent, so it will stop receiving propagated events
		removeEventParent: function (obj) {
			if (this._eventParents) {
				delete this._eventParents[stamp(obj)];
			}
			return this;
		},

		_propagateEvent: function (e) {
			for (var id in this._eventParents) {
				this._eventParents[id].fire(e.type, extend({
					layer: e.target,
					propagatedFrom: e.target
				}, e), true);
			}
		}
	};

	// aliases; we should ditch those eventually

	// @method addEventListener(…): this
	// Alias to [`on(…)`](#evented-on)
	Events.addEventListener = Events.on;

	// @method removeEventListener(…): this
	// Alias to [`off(…)`](#evented-off)

	// @method clearAllEventListeners(…): this
	// Alias to [`off()`](#evented-off)
	Events.removeEventListener = Events.clearAllEventListeners = Events.off;

	// @method addOneTimeEventListener(…): this
	// Alias to [`once(…)`](#evented-once)
	Events.addOneTimeEventListener = Events.once;

	// @method fireEvent(…): this
	// Alias to [`fire(…)`](#evented-fire)
	Events.fireEvent = Events.fire;

	// @method hasEventListeners(…): Boolean
	// Alias to [`listens(…)`](#evented-listens)
	Events.hasEventListeners = Events.listens;

	var Evented = Class.extend(Events);

	/*
	 * @class Point
	 * @aka L.Point
	 *
	 * Represents a point with `x` and `y` coordinates in pixels.
	 *
	 * @example
	 *
	 * ```js
	 * var point = L.point(200, 300);
	 * ```
	 *
	 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
	 *
	 * ```js
	 * map.panBy([200, 300]);
	 * map.panBy(L.point(200, 300));
	 * ```
	 *
	 * Note that `Point` does not inherit from Leafet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function Point(x, y, round) {
		// @property x: Number; The `x` coordinate of the point
		this.x = (round ? Math.round(x) : x);
		// @property y: Number; The `y` coordinate of the point
		this.y = (round ? Math.round(y) : y);
	}

	var trunc = Math.trunc || function (v) {
		return v > 0 ? Math.floor(v) : Math.ceil(v);
	};

	Point.prototype = {

		// @method clone(): Point
		// Returns a copy of the current point.
		clone: function () {
			return new Point(this.x, this.y);
		},

		// @method add(otherPoint: Point): Point
		// Returns the result of addition of the current and the given points.
		add: function (point) {
			// non-destructive, returns a new point
			return this.clone()._add(toPoint(point));
		},

		_add: function (point) {
			// destructive, used directly for performance in situations where it's safe to modify existing point
			this.x += point.x;
			this.y += point.y;
			return this;
		},

		// @method subtract(otherPoint: Point): Point
		// Returns the result of subtraction of the given point from the current.
		subtract: function (point) {
			return this.clone()._subtract(toPoint(point));
		},

		_subtract: function (point) {
			this.x -= point.x;
			this.y -= point.y;
			return this;
		},

		// @method divideBy(num: Number): Point
		// Returns the result of division of the current point by the given number.
		divideBy: function (num) {
			return this.clone()._divideBy(num);
		},

		_divideBy: function (num) {
			this.x /= num;
			this.y /= num;
			return this;
		},

		// @method multiplyBy(num: Number): Point
		// Returns the result of multiplication of the current point by the given number.
		multiplyBy: function (num) {
			return this.clone()._multiplyBy(num);
		},

		_multiplyBy: function (num) {
			this.x *= num;
			this.y *= num;
			return this;
		},

		// @method scaleBy(scale: Point): Point
		// Multiply each coordinate of the current point by each coordinate of
		// `scale`. In linear algebra terms, multiply the point by the
		// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
		// defined by `scale`.
		scaleBy: function (point) {
			return new Point(this.x * point.x, this.y * point.y);
		},

		// @method unscaleBy(scale: Point): Point
		// Inverse of `scaleBy`. Divide each coordinate of the current point by
		// each coordinate of `scale`.
		unscaleBy: function (point) {
			return new Point(this.x / point.x, this.y / point.y);
		},

		// @method round(): Point
		// Returns a copy of the current point with rounded coordinates.
		round: function () {
			return this.clone()._round();
		},

		_round: function () {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		},

		// @method floor(): Point
		// Returns a copy of the current point with floored coordinates (rounded down).
		floor: function () {
			return this.clone()._floor();
		},

		_floor: function () {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		},

		// @method ceil(): Point
		// Returns a copy of the current point with ceiled coordinates (rounded up).
		ceil: function () {
			return this.clone()._ceil();
		},

		_ceil: function () {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		},

		// @method trunc(): Point
		// Returns a copy of the current point with truncated coordinates (rounded towards zero).
		trunc: function () {
			return this.clone()._trunc();
		},

		_trunc: function () {
			this.x = trunc(this.x);
			this.y = trunc(this.y);
			return this;
		},

		// @method distanceTo(otherPoint: Point): Number
		// Returns the cartesian distance between the current and the given points.
		distanceTo: function (point) {
			point = toPoint(point);

			var x = point.x - this.x,
			    y = point.y - this.y;

			return Math.sqrt(x * x + y * y);
		},

		// @method equals(otherPoint: Point): Boolean
		// Returns `true` if the given point has the same coordinates.
		equals: function (point) {
			point = toPoint(point);

			return point.x === this.x &&
			       point.y === this.y;
		},

		// @method contains(otherPoint: Point): Boolean
		// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
		contains: function (point) {
			point = toPoint(point);

			return Math.abs(point.x) <= Math.abs(this.x) &&
			       Math.abs(point.y) <= Math.abs(this.y);
		},

		// @method toString(): String
		// Returns a string representation of the point for debugging purposes.
		toString: function () {
			return 'Point(' +
			        formatNum(this.x) + ', ' +
			        formatNum(this.y) + ')';
		}
	};

	// @factory L.point(x: Number, y: Number, round?: Boolean)
	// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

	// @alternative
	// @factory L.point(coords: Number[])
	// Expects an array of the form `[x, y]` instead.

	// @alternative
	// @factory L.point(coords: Object)
	// Expects a plain object of the form `{x: Number, y: Number}` instead.
	function toPoint(x, y, round) {
		if (x instanceof Point) {
			return x;
		}
		if (isArray(x)) {
			return new Point(x[0], x[1]);
		}
		if (x === undefined || x === null) {
			return x;
		}
		if (typeof x === 'object' && 'x' in x && 'y' in x) {
			return new Point(x.x, x.y);
		}
		return new Point(x, y, round);
	}

	/*
	 * @class Bounds
	 * @aka L.Bounds
	 *
	 * Represents a rectangular area in pixel coordinates.
	 *
	 * @example
	 *
	 * ```js
	 * var p1 = L.point(10, 10),
	 * p2 = L.point(40, 60),
	 * bounds = L.bounds(p1, p2);
	 * ```
	 *
	 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
	 *
	 * ```js
	 * otherBounds.intersects([[10, 10], [40, 60]]);
	 * ```
	 *
	 * Note that `Bounds` does not inherit from Leafet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function Bounds(a, b) {
		if (!a) { return; }

		var points = b ? [a, b] : a;

		for (var i = 0, len = points.length; i < len; i++) {
			this.extend(points[i]);
		}
	}

	Bounds.prototype = {
		// @method extend(point: Point): this
		// Extends the bounds to contain the given point.
		extend: function (point) { // (Point)
			point = toPoint(point);

			// @property min: Point
			// The top left corner of the rectangle.
			// @property max: Point
			// The bottom right corner of the rectangle.
			if (!this.min && !this.max) {
				this.min = point.clone();
				this.max = point.clone();
			} else {
				this.min.x = Math.min(point.x, this.min.x);
				this.max.x = Math.max(point.x, this.max.x);
				this.min.y = Math.min(point.y, this.min.y);
				this.max.y = Math.max(point.y, this.max.y);
			}
			return this;
		},

		// @method getCenter(round?: Boolean): Point
		// Returns the center point of the bounds.
		getCenter: function (round) {
			return new Point(
			        (this.min.x + this.max.x) / 2,
			        (this.min.y + this.max.y) / 2, round);
		},

		// @method getBottomLeft(): Point
		// Returns the bottom-left point of the bounds.
		getBottomLeft: function () {
			return new Point(this.min.x, this.max.y);
		},

		// @method getTopRight(): Point
		// Returns the top-right point of the bounds.
		getTopRight: function () { // -> Point
			return new Point(this.max.x, this.min.y);
		},

		// @method getTopLeft(): Point
		// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
		getTopLeft: function () {
			return this.min; // left, top
		},

		// @method getBottomRight(): Point
		// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
		getBottomRight: function () {
			return this.max; // right, bottom
		},

		// @method getSize(): Point
		// Returns the size of the given bounds
		getSize: function () {
			return this.max.subtract(this.min);
		},

		// @method contains(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle contains the given one.
		// @alternative
		// @method contains(point: Point): Boolean
		// Returns `true` if the rectangle contains the given point.
		contains: function (obj) {
			var min, max;

			if (typeof obj[0] === 'number' || obj instanceof Point) {
				obj = toPoint(obj);
			} else {
				obj = toBounds(obj);
			}

			if (obj instanceof Bounds) {
				min = obj.min;
				max = obj.max;
			} else {
				min = max = obj;
			}

			return (min.x >= this.min.x) &&
			       (max.x <= this.max.x) &&
			       (min.y >= this.min.y) &&
			       (max.y <= this.max.y);
		},

		// @method intersects(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle intersects the given bounds. Two bounds
		// intersect if they have at least one point in common.
		intersects: function (bounds) { // (Bounds) -> Boolean
			bounds = toBounds(bounds);

			var min = this.min,
			    max = this.max,
			    min2 = bounds.min,
			    max2 = bounds.max,
			    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
			    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

			return xIntersects && yIntersects;
		},

		// @method overlaps(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle overlaps the given bounds. Two bounds
		// overlap if their intersection is an area.
		overlaps: function (bounds) { // (Bounds) -> Boolean
			bounds = toBounds(bounds);

			var min = this.min,
			    max = this.max,
			    min2 = bounds.min,
			    max2 = bounds.max,
			    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
			    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

			return xOverlaps && yOverlaps;
		},

		isValid: function () {
			return !!(this.min && this.max);
		}
	};


	// @factory L.bounds(corner1: Point, corner2: Point)
	// Creates a Bounds object from two corners coordinate pairs.
	// @alternative
	// @factory L.bounds(points: Point[])
	// Creates a Bounds object from the given array of points.
	function toBounds(a, b) {
		if (!a || a instanceof Bounds) {
			return a;
		}
		return new Bounds(a, b);
	}

	/*
	 * @class LatLngBounds
	 * @aka L.LatLngBounds
	 *
	 * Represents a rectangular geographical area on a map.
	 *
	 * @example
	 *
	 * ```js
	 * var corner1 = L.latLng(40.712, -74.227),
	 * corner2 = L.latLng(40.774, -74.125),
	 * bounds = L.latLngBounds(corner1, corner2);
	 * ```
	 *
	 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
	 *
	 * ```js
	 * map.fitBounds([
	 * 	[40.712, -74.227],
	 * 	[40.774, -74.125]
	 * ]);
	 * ```
	 *
	 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
	 *
	 * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
		if (!corner1) { return; }

		var latlngs = corner2 ? [corner1, corner2] : corner1;

		for (var i = 0, len = latlngs.length; i < len; i++) {
			this.extend(latlngs[i]);
		}
	}

	LatLngBounds.prototype = {

		// @method extend(latlng: LatLng): this
		// Extend the bounds to contain the given point

		// @alternative
		// @method extend(otherBounds: LatLngBounds): this
		// Extend the bounds to contain the given bounds
		extend: function (obj) {
			var sw = this._southWest,
			    ne = this._northEast,
			    sw2, ne2;

			if (obj instanceof LatLng) {
				sw2 = obj;
				ne2 = obj;

			} else if (obj instanceof LatLngBounds) {
				sw2 = obj._southWest;
				ne2 = obj._northEast;

				if (!sw2 || !ne2) { return this; }

			} else {
				return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
			}

			if (!sw && !ne) {
				this._southWest = new LatLng(sw2.lat, sw2.lng);
				this._northEast = new LatLng(ne2.lat, ne2.lng);
			} else {
				sw.lat = Math.min(sw2.lat, sw.lat);
				sw.lng = Math.min(sw2.lng, sw.lng);
				ne.lat = Math.max(ne2.lat, ne.lat);
				ne.lng = Math.max(ne2.lng, ne.lng);
			}

			return this;
		},

		// @method pad(bufferRatio: Number): LatLngBounds
		// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
		// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
		// Negative values will retract the bounds.
		pad: function (bufferRatio) {
			var sw = this._southWest,
			    ne = this._northEast,
			    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
			    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

			return new LatLngBounds(
			        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
			        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
		},

		// @method getCenter(): LatLng
		// Returns the center point of the bounds.
		getCenter: function () {
			return new LatLng(
			        (this._southWest.lat + this._northEast.lat) / 2,
			        (this._southWest.lng + this._northEast.lng) / 2);
		},

		// @method getSouthWest(): LatLng
		// Returns the south-west point of the bounds.
		getSouthWest: function () {
			return this._southWest;
		},

		// @method getNorthEast(): LatLng
		// Returns the north-east point of the bounds.
		getNorthEast: function () {
			return this._northEast;
		},

		// @method getNorthWest(): LatLng
		// Returns the north-west point of the bounds.
		getNorthWest: function () {
			return new LatLng(this.getNorth(), this.getWest());
		},

		// @method getSouthEast(): LatLng
		// Returns the south-east point of the bounds.
		getSouthEast: function () {
			return new LatLng(this.getSouth(), this.getEast());
		},

		// @method getWest(): Number
		// Returns the west longitude of the bounds
		getWest: function () {
			return this._southWest.lng;
		},

		// @method getSouth(): Number
		// Returns the south latitude of the bounds
		getSouth: function () {
			return this._southWest.lat;
		},

		// @method getEast(): Number
		// Returns the east longitude of the bounds
		getEast: function () {
			return this._northEast.lng;
		},

		// @method getNorth(): Number
		// Returns the north latitude of the bounds
		getNorth: function () {
			return this._northEast.lat;
		},

		// @method contains(otherBounds: LatLngBounds): Boolean
		// Returns `true` if the rectangle contains the given one.

		// @alternative
		// @method contains (latlng: LatLng): Boolean
		// Returns `true` if the rectangle contains the given point.
		contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
			if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
				obj = toLatLng(obj);
			} else {
				obj = toLatLngBounds(obj);
			}

			var sw = this._southWest,
			    ne = this._northEast,
			    sw2, ne2;

			if (obj instanceof LatLngBounds) {
				sw2 = obj.getSouthWest();
				ne2 = obj.getNorthEast();
			} else {
				sw2 = ne2 = obj;
			}

			return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
			       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
		},

		// @method intersects(otherBounds: LatLngBounds): Boolean
		// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
		intersects: function (bounds) {
			bounds = toLatLngBounds(bounds);

			var sw = this._southWest,
			    ne = this._northEast,
			    sw2 = bounds.getSouthWest(),
			    ne2 = bounds.getNorthEast(),

			    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
			    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

			return latIntersects && lngIntersects;
		},

		// @method overlaps(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
		overlaps: function (bounds) {
			bounds = toLatLngBounds(bounds);

			var sw = this._southWest,
			    ne = this._northEast,
			    sw2 = bounds.getSouthWest(),
			    ne2 = bounds.getNorthEast(),

			    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
			    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

			return latOverlaps && lngOverlaps;
		},

		// @method toBBoxString(): String
		// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
		toBBoxString: function () {
			return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
		},

		// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
		// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
		equals: function (bounds, maxMargin) {
			if (!bounds) { return false; }

			bounds = toLatLngBounds(bounds);

			return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
			       this._northEast.equals(bounds.getNorthEast(), maxMargin);
		},

		// @method isValid(): Boolean
		// Returns `true` if the bounds are properly initialized.
		isValid: function () {
			return !!(this._southWest && this._northEast);
		}
	};

	// TODO International date line?

	// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
	// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

	// @alternative
	// @factory L.latLngBounds(latlngs: LatLng[])
	// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
	function toLatLngBounds(a, b) {
		if (a instanceof LatLngBounds) {
			return a;
		}
		return new LatLngBounds(a, b);
	}

	/* @class LatLng
	 * @aka L.LatLng
	 *
	 * Represents a geographical point with a certain latitude and longitude.
	 *
	 * @example
	 *
	 * ```
	 * var latlng = L.latLng(50.5, 30.5);
	 * ```
	 *
	 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
	 *
	 * ```
	 * map.panTo([50, 30]);
	 * map.panTo({lon: 30, lat: 50});
	 * map.panTo({lat: 50, lng: 30});
	 * map.panTo(L.latLng(50, 30));
	 * ```
	 *
	 * Note that `LatLng` does not inherit from Leaflet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function LatLng(lat, lng, alt) {
		if (isNaN(lat) || isNaN(lng)) {
			throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
		}

		// @property lat: Number
		// Latitude in degrees
		this.lat = +lat;

		// @property lng: Number
		// Longitude in degrees
		this.lng = +lng;

		// @property alt: Number
		// Altitude in meters (optional)
		if (alt !== undefined) {
			this.alt = +alt;
		}
	}

	LatLng.prototype = {
		// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
		// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
		equals: function (obj, maxMargin) {
			if (!obj) { return false; }

			obj = toLatLng(obj);

			var margin = Math.max(
			        Math.abs(this.lat - obj.lat),
			        Math.abs(this.lng - obj.lng));

			return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
		},

		// @method toString(): String
		// Returns a string representation of the point (for debugging purposes).
		toString: function (precision) {
			return 'LatLng(' +
			        formatNum(this.lat, precision) + ', ' +
			        formatNum(this.lng, precision) + ')';
		},

		// @method distanceTo(otherLatLng: LatLng): Number
		// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
		distanceTo: function (other) {
			return Earth.distance(this, toLatLng(other));
		},

		// @method wrap(): LatLng
		// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
		wrap: function () {
			return Earth.wrapLatLng(this);
		},

		// @method toBounds(sizeInMeters: Number): LatLngBounds
		// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
		toBounds: function (sizeInMeters) {
			var latAccuracy = 180 * sizeInMeters / 40075017,
			    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

			return toLatLngBounds(
			        [this.lat - latAccuracy, this.lng - lngAccuracy],
			        [this.lat + latAccuracy, this.lng + lngAccuracy]);
		},

		clone: function () {
			return new LatLng(this.lat, this.lng, this.alt);
		}
	};



	// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
	// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

	// @alternative
	// @factory L.latLng(coords: Array): LatLng
	// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

	// @alternative
	// @factory L.latLng(coords: Object): LatLng
	// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

	function toLatLng(a, b, c) {
		if (a instanceof LatLng) {
			return a;
		}
		if (isArray(a) && typeof a[0] !== 'object') {
			if (a.length === 3) {
				return new LatLng(a[0], a[1], a[2]);
			}
			if (a.length === 2) {
				return new LatLng(a[0], a[1]);
			}
			return null;
		}
		if (a === undefined || a === null) {
			return a;
		}
		if (typeof a === 'object' && 'lat' in a) {
			return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
		}
		if (b === undefined) {
			return null;
		}
		return new LatLng(a, b, c);
	}

	/*
	 * @namespace CRS
	 * @crs L.CRS.Base
	 * Object that defines coordinate reference systems for projecting
	 * geographical points into pixel (screen) coordinates and back (and to
	 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
	 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
	 *
	 * Leaflet defines the most usual CRSs by default. If you want to use a
	 * CRS not defined by default, take a look at the
	 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
	 *
	 * Note that the CRS instances do not inherit from Leafet's `Class` object,
	 * and can't be instantiated. Also, new classes can't inherit from them,
	 * and methods can't be added to them with the `include` function.
	 */

	var CRS = {
		// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
		// Projects geographical coordinates into pixel coordinates for a given zoom.
		latLngToPoint: function (latlng, zoom) {
			var projectedPoint = this.projection.project(latlng),
			    scale = this.scale(zoom);

			return this.transformation._transform(projectedPoint, scale);
		},

		// @method pointToLatLng(point: Point, zoom: Number): LatLng
		// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
		// zoom into geographical coordinates.
		pointToLatLng: function (point, zoom) {
			var scale = this.scale(zoom),
			    untransformedPoint = this.transformation.untransform(point, scale);

			return this.projection.unproject(untransformedPoint);
		},

		// @method project(latlng: LatLng): Point
		// Projects geographical coordinates into coordinates in units accepted for
		// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
		project: function (latlng) {
			return this.projection.project(latlng);
		},

		// @method unproject(point: Point): LatLng
		// Given a projected coordinate returns the corresponding LatLng.
		// The inverse of `project`.
		unproject: function (point) {
			return this.projection.unproject(point);
		},

		// @method scale(zoom: Number): Number
		// Returns the scale used when transforming projected coordinates into
		// pixel coordinates for a particular zoom. For example, it returns
		// `256 * 2^zoom` for Mercator-based CRS.
		scale: function (zoom) {
			return 256 * Math.pow(2, zoom);
		},

		// @method zoom(scale: Number): Number
		// Inverse of `scale()`, returns the zoom level corresponding to a scale
		// factor of `scale`.
		zoom: function (scale) {
			return Math.log(scale / 256) / Math.LN2;
		},

		// @method getProjectedBounds(zoom: Number): Bounds
		// Returns the projection's bounds scaled and transformed for the provided `zoom`.
		getProjectedBounds: function (zoom) {
			if (this.infinite) { return null; }

			var b = this.projection.bounds,
			    s = this.scale(zoom),
			    min = this.transformation.transform(b.min, s),
			    max = this.transformation.transform(b.max, s);

			return new Bounds(min, max);
		},

		// @method distance(latlng1: LatLng, latlng2: LatLng): Number
		// Returns the distance between two geographical coordinates.

		// @property code: String
		// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
		//
		// @property wrapLng: Number[]
		// An array of two numbers defining whether the longitude (horizontal) coordinate
		// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
		// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
		//
		// @property wrapLat: Number[]
		// Like `wrapLng`, but for the latitude (vertical) axis.

		// wrapLng: [min, max],
		// wrapLat: [min, max],

		// @property infinite: Boolean
		// If true, the coordinate space will be unbounded (infinite in both axes)
		infinite: false,

		// @method wrapLatLng(latlng: LatLng): LatLng
		// Returns a `LatLng` where lat and lng has been wrapped according to the
		// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
		wrapLatLng: function (latlng) {
			var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
			    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
			    alt = latlng.alt;

			return new LatLng(lat, lng, alt);
		},

		// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
		// Returns a `LatLngBounds` with the same size as the given one, ensuring
		// that its center is within the CRS's bounds.
		// Only accepts actual `L.LatLngBounds` instances, not arrays.
		wrapLatLngBounds: function (bounds) {
			var center = bounds.getCenter(),
			    newCenter = this.wrapLatLng(center),
			    latShift = center.lat - newCenter.lat,
			    lngShift = center.lng - newCenter.lng;

			if (latShift === 0 && lngShift === 0) {
				return bounds;
			}

			var sw = bounds.getSouthWest(),
			    ne = bounds.getNorthEast(),
			    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
			    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

			return new LatLngBounds(newSw, newNe);
		}
	};

	/*
	 * @namespace CRS
	 * @crs L.CRS.Earth
	 *
	 * Serves as the base for CRS that are global such that they cover the earth.
	 * Can only be used as the base for other CRS and cannot be used directly,
	 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
	 * meters.
	 */

	var Earth = extend({}, CRS, {
		wrapLng: [-180, 180],

		// Mean Earth Radius, as recommended for use by
		// the International Union of Geodesy and Geophysics,
		// see http://rosettacode.org/wiki/Haversine_formula
		R: 6371000,

		// distance between two geographical points using spherical law of cosines approximation
		distance: function (latlng1, latlng2) {
			var rad = Math.PI / 180,
			    lat1 = latlng1.lat * rad,
			    lat2 = latlng2.lat * rad,
			    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
			    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
			    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
			    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
			return this.R * c;
		}
	});

	/*
	 * @namespace Projection
	 * @projection L.Projection.SphericalMercator
	 *
	 * Spherical Mercator projection — the most common projection for online maps,
	 * used by almost all free and commercial tile providers. Assumes that Earth is
	 * a sphere. Used by the `EPSG:3857` CRS.
	 */

	var SphericalMercator = {

		R: 6378137,
		MAX_LATITUDE: 85.0511287798,

		project: function (latlng) {
			var d = Math.PI / 180,
			    max = this.MAX_LATITUDE,
			    lat = Math.max(Math.min(max, latlng.lat), -max),
			    sin = Math.sin(lat * d);

			return new Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
		},

		unproject: function (point) {
			var d = 180 / Math.PI;

			return new LatLng(
				(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
				point.x * d / this.R);
		},

		bounds: (function () {
			var d = 6378137 * Math.PI;
			return new Bounds([-d, -d], [d, d]);
		})()
	};

	/*
	 * @class Transformation
	 * @aka L.Transformation
	 *
	 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
	 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
	 * the reverse. Used by Leaflet in its projections code.
	 *
	 * @example
	 *
	 * ```js
	 * var transformation = L.transformation(2, 5, -1, 10),
	 * 	p = L.point(1, 2),
	 * 	p2 = transformation.transform(p), //  L.point(7, 8)
	 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
	 * ```
	 */


	// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
	// Creates a `Transformation` object with the given coefficients.
	function Transformation(a, b, c, d) {
		if (isArray(a)) {
			// use array properties
			this._a = a[0];
			this._b = a[1];
			this._c = a[2];
			this._d = a[3];
			return;
		}
		this._a = a;
		this._b = b;
		this._c = c;
		this._d = d;
	}

	Transformation.prototype = {
		// @method transform(point: Point, scale?: Number): Point
		// Returns a transformed point, optionally multiplied by the given scale.
		// Only accepts actual `L.Point` instances, not arrays.
		transform: function (point, scale) { // (Point, Number) -> Point
			return this._transform(point.clone(), scale);
		},

		// destructive transform (faster)
		_transform: function (point, scale) {
			scale = scale || 1;
			point.x = scale * (this._a * point.x + this._b);
			point.y = scale * (this._c * point.y + this._d);
			return point;
		},

		// @method untransform(point: Point, scale?: Number): Point
		// Returns the reverse transformation of the given point, optionally divided
		// by the given scale. Only accepts actual `L.Point` instances, not arrays.
		untransform: function (point, scale) {
			scale = scale || 1;
			return new Point(
			        (point.x / scale - this._b) / this._a,
			        (point.y / scale - this._d) / this._c);
		}
	};

	// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

	// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
	// Instantiates a Transformation object with the given coefficients.

	// @alternative
	// @factory L.transformation(coefficients: Array): Transformation
	// Expects an coefficients array of the form
	// `[a: Number, b: Number, c: Number, d: Number]`.

	function toTransformation(a, b, c, d) {
		return new Transformation(a, b, c, d);
	}

	/*
	 * @namespace CRS
	 * @crs L.CRS.EPSG3857
	 *
	 * The most common CRS for online maps, used by almost all free and commercial
	 * tile providers. Uses Spherical Mercator projection. Set in by default in
	 * Map's `crs` option.
	 */

	var EPSG3857 = extend({}, Earth, {
		code: 'EPSG:3857',
		projection: SphericalMercator,

		transformation: (function () {
			var scale = 0.5 / (Math.PI * SphericalMercator.R);
			return toTransformation(scale, 0.5, -scale, 0.5);
		}())
	});

	var EPSG900913 = extend({}, EPSG3857, {
		code: 'EPSG:900913'
	});

	// @namespace SVG; @section
	// There are several static functions which can be called without instantiating L.SVG:

	// @function create(name: String): SVGElement
	// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
	// corresponding to the class name passed. For example, using 'line' will return
	// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
	function svgCreate(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	// @function pointsToPath(rings: Point[], closed: Boolean): String
	// Generates a SVG path string for multiple rings, with each ring turning
	// into "M..L..L.." instructions
	function pointsToPath(rings, closed) {
		var str = '',
		i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}

	/*
	 * @namespace Browser
	 * @aka L.Browser
	 *
	 * A namespace with static properties for browser/feature detection used by Leaflet internally.
	 *
	 * @example
	 *
	 * ```js
	 * if (L.Browser.ielt9) {
	 *   alert('Upgrade your browser, dude!');
	 * }
	 * ```
	 */

	var style$1 = document.documentElement.style;

	// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
	var ie = 'ActiveXObject' in window;

	// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
	var ielt9 = ie && !document.addEventListener;

	// @property edge: Boolean; `true` for the Edge web browser.
	var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

	// @property webkit: Boolean;
	// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
	var webkit = userAgentContains('webkit');

	// @property android: Boolean
	// `true` for any browser running on an Android platform.
	var android = userAgentContains('android');

	// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
	var android23 = userAgentContains('android 2') || userAgentContains('android 3');

	/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
	var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
	// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
	var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

	// @property opera: Boolean; `true` for the Opera browser
	var opera = !!window.opera;

	// @property chrome: Boolean; `true` for the Chrome browser.
	var chrome = userAgentContains('chrome');

	// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
	var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

	// @property safari: Boolean; `true` for the Safari browser.
	var safari = !chrome && userAgentContains('safari');

	var phantom = userAgentContains('phantom');

	// @property opera12: Boolean
	// `true` for the Opera browser supporting CSS transforms (version 12 or later).
	var opera12 = 'OTransition' in style$1;

	// @property win: Boolean; `true` when the browser is running in a Windows platform
	var win = navigator.platform.indexOf('Win') === 0;

	// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
	var ie3d = ie && ('transition' in style$1);

	// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
	var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

	// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
	var gecko3d = 'MozPerspective' in style$1;

	// @property any3d: Boolean
	// `true` for all browsers supporting CSS transforms.
	var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

	// @property mobile: Boolean; `true` for all browsers running in a mobile device.
	var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

	// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
	var mobileWebkit = mobile && webkit;

	// @property mobileWebkit3d: Boolean
	// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
	var mobileWebkit3d = mobile && webkit3d;

	// @property msPointer: Boolean
	// `true` for browsers implementing the Microsoft touch events model (notably IE10).
	var msPointer = !window.PointerEvent && window.MSPointerEvent;

	// @property pointer: Boolean
	// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
	var pointer = !!(window.PointerEvent || msPointer);

	// @property touch: Boolean
	// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
	// This does not necessarily mean that the browser is running in a computer with
	// a touchscreen, it only means that the browser is capable of understanding
	// touch events.
	var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
	var mobileOpera = mobile && opera;

	// @property mobileGecko: Boolean
	// `true` for gecko-based browsers running in a mobile device.
	var mobileGecko = mobile && gecko;

	// @property retina: Boolean
	// `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
	var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;


	// @property canvas: Boolean
	// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
	var canvas = (function () {
		return !!document.createElement('canvas').getContext;
	}());

	// @property svg: Boolean
	// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
	var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect);

	// @property vml: Boolean
	// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
	var vml = !svg && (function () {
		try {
			var div = document.createElement('div');
			div.innerHTML = '<v:shape adj="1"/>';

			var shape = div.firstChild;
			shape.style.behavior = 'url(#default#VML)';

			return shape && (typeof shape.adj === 'object');

		} catch (e) {
			return false;
		}
	}());


	function userAgentContains(str) {
		return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
	}


	var Browser = (Object.freeze || Object)({
		ie: ie,
		ielt9: ielt9,
		edge: edge,
		webkit: webkit,
		android: android,
		android23: android23,
		androidStock: androidStock,
		opera: opera,
		chrome: chrome,
		gecko: gecko,
		safari: safari,
		phantom: phantom,
		opera12: opera12,
		win: win,
		ie3d: ie3d,
		webkit3d: webkit3d,
		gecko3d: gecko3d,
		any3d: any3d,
		mobile: mobile,
		mobileWebkit: mobileWebkit,
		mobileWebkit3d: mobileWebkit3d,
		msPointer: msPointer,
		pointer: pointer,
		touch: touch,
		mobileOpera: mobileOpera,
		mobileGecko: mobileGecko,
		retina: retina,
		canvas: canvas,
		svg: svg,
		vml: vml
	});

	/*
	 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
	 */


	var POINTER_DOWN =   msPointer ? 'MSPointerDown'   : 'pointerdown';
	var POINTER_MOVE =   msPointer ? 'MSPointerMove'   : 'pointermove';
	var POINTER_UP =     msPointer ? 'MSPointerUp'     : 'pointerup';
	var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
	var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];

	var _pointers = {};
	var _pointerDocListener = false;

	// DomEvent.DoubleTap needs to know about this
	var _pointersCount = 0;

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	function addPointerListener(obj, type, handler, id) {
		if (type === 'touchstart') {
			_addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			_addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			_addPointerEnd(obj, handler, id);
		}

		return this;
	}

	function removePointerListener(obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(POINTER_UP, handler, false);
			obj.removeEventListener(POINTER_CANCEL, handler, false);
		}

		return this;
	}

	function _addPointerStart(obj, handler, id) {
		var onDown = bind(function (e) {
			if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				// In IE11, some touch events needs to fire for form controls, or
				// the controls will stop working. We keep a whitelist of tag names that
				// need these events. For other target tags, we prevent default on the event.
				if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
					preventDefault(e);
				} else {
					return;
				}
			}

			_handlePointer(e, handler);
		});

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!_pointerDocListener) {
			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
			document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
			document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
			document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

			_pointerDocListener = true;
		}
	}

	function _globalPointerDown(e) {
		_pointers[e.pointerId] = e;
		_pointersCount++;
	}

	function _globalPointerMove(e) {
		if (_pointers[e.pointerId]) {
			_pointers[e.pointerId] = e;
		}
	}

	function _globalPointerUp(e) {
		delete _pointers[e.pointerId];
		_pointersCount--;
	}

	function _handlePointer(e, handler) {
		e.touches = [];
		for (var i in _pointers) {
			e.touches.push(_pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	}

	function _addPointerMove(obj, handler, id) {
		var onMove = function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			_handlePointer(e, handler);
		};

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(POINTER_MOVE, onMove, false);
	}

	function _addPointerEnd(obj, handler, id) {
		var onUp = function (e) {
			_handlePointer(e, handler);
		};

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(POINTER_UP, onUp, false);
		obj.addEventListener(POINTER_CANCEL, onUp, false);
	}

	/*
	 * Extends the event handling code with double tap support for mobile browsers.
	 */

	var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';
	var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';
	var _pre = '_leaflet_';

	// inspired by Zepto touch code by Thomas Fuchs
	function addDoubleTapListener(obj, handler, id) {
		var last, touch$$1,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (pointer) {
				if ((!edge) || e.pointerType === 'mouse') { return; }
				count = _pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch$$1 = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (doubleTap && !touch$$1.cancelBubble) {
				if (pointer) {
					if ((!edge) || e.pointerType === 'mouse') { return; }
					// work around .type being readonly with MSPointer* events
					var newTouch = {},
					    prop, i;

					for (i in touch$$1) {
						prop = touch$$1[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
					}
					touch$$1 = newTouch;
				}
				touch$$1.type = 'dblclick';
				handler(touch$$1);
				last = null;
			}
		}

		obj[_pre + _touchstart + id] = onTouchStart;
		obj[_pre + _touchend + id] = onTouchEnd;
		obj[_pre + 'dblclick' + id] = handler;

		obj.addEventListener(_touchstart, onTouchStart, false);
		obj.addEventListener(_touchend, onTouchEnd, false);

		// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
		// the browser doesn't fire touchend/pointerup events but does fire
		// native dblclicks. See #4127.
		// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
		obj.addEventListener('dblclick', handler, false);

		return this;
	}

	function removeDoubleTapListener(obj, id) {
		var touchstart = obj[_pre + _touchstart + id],
		    touchend = obj[_pre + _touchend + id],
		    dblclick = obj[_pre + 'dblclick' + id];

		obj.removeEventListener(_touchstart, touchstart, false);
		obj.removeEventListener(_touchend, touchend, false);
		if (!edge) {
			obj.removeEventListener('dblclick', dblclick, false);
		}

		return this;
	}

	/*
	 * @namespace DomUtil
	 *
	 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
	 * tree, used by Leaflet internally.
	 *
	 * Most functions expecting or returning a `HTMLElement` also work for
	 * SVG elements. The only difference is that classes refer to CSS classes
	 * in HTML and SVG classes in SVG.
	 */


	// @property TRANSFORM: String
	// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
	var TRANSFORM = testProp(
		['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	// @property TRANSITION: String
	// Vendor-prefixed transition style name.
	var TRANSITION = testProp(
		['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	// @property TRANSITION_END: String
	// Vendor-prefixed transitionend event name.
	var TRANSITION_END =
		TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


	// @function get(id: String|HTMLElement): HTMLElement
	// Returns an element given its DOM id, or returns the element itself
	// if it was passed directly.
	function get(id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	}

	// @function getStyle(el: HTMLElement, styleAttrib: String): String
	// Returns the value for a certain style attribute on an element,
	// including computed values or values set through CSS.
	function getStyle(el, style) {
		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}
		return value === 'auto' ? null : value;
	}

	// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
	// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
	function create$1(tagName, className, container) {
		var el = document.createElement(tagName);
		el.className = className || '';

		if (container) {
			container.appendChild(el);
		}
		return el;
	}

	// @function remove(el: HTMLElement)
	// Removes `el` from its parent element
	function remove(el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	}

	// @function empty(el: HTMLElement)
	// Removes all of `el`'s children elements from `el`
	function empty(el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	}

	// @function toFront(el: HTMLElement)
	// Makes `el` the last child of its parent, so it renders in front of the other children.
	function toFront(el) {
		var parent = el.parentNode;
		if (parent && parent.lastChild !== el) {
			parent.appendChild(el);
		}
	}

	// @function toBack(el: HTMLElement)
	// Makes `el` the first child of its parent, so it renders behind the other children.
	function toBack(el) {
		var parent = el.parentNode;
		if (parent && parent.firstChild !== el) {
			parent.insertBefore(el, parent.firstChild);
		}
	}

	// @function hasClass(el: HTMLElement, name: String): Boolean
	// Returns `true` if the element's class attribute contains `name`.
	function hasClass(el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	}

	// @function addClass(el: HTMLElement, name: String)
	// Adds `name` to the element's class attribute.
	function addClass(el, name) {
		if (el.classList !== undefined) {
			var classes = splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!hasClass(el, name)) {
			var className = getClass(el);
			setClass(el, (className ? className + ' ' : '') + name);
		}
	}

	// @function removeClass(el: HTMLElement, name: String)
	// Removes `name` from the element's class attribute.
	function removeClass(el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	}

	// @function setClass(el: HTMLElement, name: String)
	// Sets the element's class.
	function setClass(el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	}

	// @function getClass(el: HTMLElement): String
	// Returns the element's class.
	function getClass(el) {
		// Check if the element is an SVGElementInstance and use the correspondingElement instead
		// (Required for linked SVG elements in IE11.)
		if (el.correspondingElement) {
			el = el.correspondingElement;
		}
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	}

	// @function setOpacity(el: HTMLElement, opacity: Number)
	// Set the opacity of an element (including old IE support).
	// `opacity` must be a number from `0` to `1`.
	function setOpacity(el, value) {
		if ('opacity' in el.style) {
			el.style.opacity = value;
		} else if ('filter' in el.style) {
			_setOpacityIE(el, value);
		}
	}

	function _setOpacityIE(el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	}

	// @function testProp(props: String[]): String|false
	// Goes through the array of style names and returns the first name
	// that is a valid style name for an element. If no such name is found,
	// it returns false. Useful for vendor-prefixed styles like `transform`.
	function testProp(props) {
		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	}

	// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
	// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
	// and optionally scaled by `scale`. Does not have an effect if the
	// browser doesn't support 3D CSS transforms.
	function setTransform(el, offset, scale) {
		var pos = offset || new Point(0, 0);

		el.style[TRANSFORM] =
			(ie3d ?
				'translate(' + pos.x + 'px,' + pos.y + 'px)' :
				'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
			(scale ? ' scale(' + scale + ')' : '');
	}

	// @function setPosition(el: HTMLElement, position: Point)
	// Sets the position of `el` to coordinates specified by `position`,
	// using CSS translate or top/left positioning depending on the browser
	// (used by Leaflet internally to position its layers).
	function setPosition(el, point) {

		/*eslint-disable */
		el._leaflet_pos = point;
		/* eslint-enable */

		if (any3d) {
			setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	}

	// @function getPosition(el: HTMLElement): Point
	// Returns the coordinates of an element previously positioned with setPosition.
	function getPosition(el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos || new Point(0, 0);
	}

	// @function disableTextSelection()
	// Prevents the user from generating `selectstart` DOM events, usually generated
	// when the user drags the mouse through a page with text. Used internally
	// by Leaflet to override the behaviour of any click-and-drag interaction on
	// the map. Affects drag interactions on the whole document.

	// @function enableTextSelection()
	// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
	var disableTextSelection;
	var enableTextSelection;
	var _userSelect;
	if ('onselectstart' in document) {
		disableTextSelection = function () {
			on(window, 'selectstart', preventDefault);
		};
		enableTextSelection = function () {
			off(window, 'selectstart', preventDefault);
		};
	} else {
		var userSelectProperty = testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				_userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = _userSelect;
				_userSelect = undefined;
			}
		};
	}

	// @function disableImageDrag()
	// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
	// for `dragstart` DOM events, usually generated when the user drags an image.
	function disableImageDrag() {
		on(window, 'dragstart', preventDefault);
	}

	// @function enableImageDrag()
	// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
	function enableImageDrag() {
		off(window, 'dragstart', preventDefault);
	}

	var _outlineElement;
	var _outlineStyle;
	// @function preventOutline(el: HTMLElement)
	// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
	// of the element `el` invisible. Used internally by Leaflet to prevent
	// focusable elements from displaying an outline when the user performs a
	// drag interaction on them.
	function preventOutline(element) {
		while (element.tabIndex === -1) {
			element = element.parentNode;
		}
		if (!element.style) { return; }
		restoreOutline();
		_outlineElement = element;
		_outlineStyle = element.style.outline;
		element.style.outline = 'none';
		on(window, 'keydown', restoreOutline);
	}

	// @function restoreOutline()
	// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
	function restoreOutline() {
		if (!_outlineElement) { return; }
		_outlineElement.style.outline = _outlineStyle;
		_outlineElement = undefined;
		_outlineStyle = undefined;
		off(window, 'keydown', restoreOutline);
	}

	// @function getSizedParentNode(el: HTMLElement): HTMLElement
	// Finds the closest parent node which size (width and height) is not null.
	function getSizedParentNode(element) {
		do {
			element = element.parentNode;
		} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
		return element;
	}

	// @function getScale(el: HTMLElement): Object
	// Computes the CSS scale currently applied on the element.
	// Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
	// and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
	function getScale(element) {
		var rect = element.getBoundingClientRect(); // Read-only in old browsers.

		return {
			x: rect.width / element.offsetWidth || 1,
			y: rect.height / element.offsetHeight || 1,
			boundingClientRect: rect
		};
	}


	var DomUtil = (Object.freeze || Object)({
		TRANSFORM: TRANSFORM,
		TRANSITION: TRANSITION,
		TRANSITION_END: TRANSITION_END,
		get: get,
		getStyle: getStyle,
		create: create$1,
		remove: remove,
		empty: empty,
		toFront: toFront,
		toBack: toBack,
		hasClass: hasClass,
		addClass: addClass,
		removeClass: removeClass,
		setClass: setClass,
		getClass: getClass,
		setOpacity: setOpacity,
		testProp: testProp,
		setTransform: setTransform,
		setPosition: setPosition,
		getPosition: getPosition,
		disableTextSelection: disableTextSelection,
		enableTextSelection: enableTextSelection,
		disableImageDrag: disableImageDrag,
		enableImageDrag: enableImageDrag,
		preventOutline: preventOutline,
		restoreOutline: restoreOutline,
		getSizedParentNode: getSizedParentNode,
		getScale: getScale
	});

	/*
	 * @namespace DomEvent
	 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
	 */

	// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

	// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Adds a listener function (`fn`) to a particular DOM event type of the
	// element `el`. You can optionally specify the context of the listener
	// (object the `this` keyword will point to). You can also pass several
	// space-separated types (e.g. `'click dblclick'`).

	// @alternative
	// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
	// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	function on(obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				addOne(obj, type, types[type], fn);
			}
		} else {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				addOne(obj, types[i], fn, context);
			}
		}

		return this;
	}

	var eventsKey = '_leaflet_events';

	// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Removes a previously added listener function.
	// Note that if you passed a custom context to on, you must pass the same
	// context to `off` in order to remove the listener.

	// @alternative
	// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
	// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	function off(obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				removeOne(obj, type, types[type], fn);
			}
		} else if (types) {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				removeOne(obj, types[i], fn, context);
			}
		} else {
			for (var j in obj[eventsKey]) {
				removeOne(obj, j, obj[eventsKey][j]);
			}
			delete obj[eventsKey];
		}

		return this;
	}

	function addOne(obj, type, fn, context) {
		var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (pointer && type.indexOf('touch') === 0) {
			// Needs DomEvent.Pointer.js
			addPointerListener(obj, type, handler, id);

		} else if (touch && (type === 'dblclick') && addDoubleTapListener &&
		           !(pointer && chrome)) {
			// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
			// See #5180
			addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (isExternalTarget(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && android) {
					handler = function (e) {
						filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;
	}

	function removeOne(obj, type, fn, context) {

		var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (pointer && type.indexOf('touch') === 0) {
			removePointerListener(obj, type, id);

		} else if (touch && (type === 'dblclick') && removeDoubleTapListener &&
		           !(pointer && chrome)) {
			removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;
	}

	// @function stopPropagation(ev: DOMEvent): this
	// Stop the given event from propagation to parent elements. Used inside the listener functions:
	// ```js
	// L.DomEvent.on(div, 'click', function (ev) {
	// 	L.DomEvent.stopPropagation(ev);
	// });
	// ```
	function stopPropagation(e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else if (e.originalEvent) {  // In case of Leaflet event.
			e.originalEvent._stopped = true;
		} else {
			e.cancelBubble = true;
		}
		skipped(e);

		return this;
	}

	// @function disableScrollPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
	function disableScrollPropagation(el) {
		addOne(el, 'mousewheel', stopPropagation);
		return this;
	}

	// @function disableClickPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
	// `'mousedown'` and `'touchstart'` events (plus browser variants).
	function disableClickPropagation(el) {
		on(el, 'mousedown touchstart dblclick', stopPropagation);
		addOne(el, 'click', fakeStop);
		return this;
	}

	// @function preventDefault(ev: DOMEvent): this
	// Prevents the default action of the DOM Event `ev` from happening (such as
	// following a link in the href of the a element, or doing a POST request
	// with page reload when a `<form>` is submitted).
	// Use it inside listener functions.
	function preventDefault(e) {
		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	}

	// @function stop(ev: DOMEvent): this
	// Does `stopPropagation` and `preventDefault` at the same time.
	function stop(e) {
		preventDefault(e);
		stopPropagation(e);
		return this;
	}

	// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
	// Gets normalized mouse position from a DOM event relative to the
	// `container` (border excluded) or to the whole page if not specified.
	function getMousePosition(e, container) {
		if (!container) {
			return new Point(e.clientX, e.clientY);
		}

		var scale = getScale(container),
		    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

		return new Point(
			// offset.left/top values are in page scale (like clientX/Y),
			// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
			(e.clientX - offset.left) / scale.x - container.clientLeft,
			(e.clientY - offset.top) / scale.y - container.clientTop
		);
	}

	// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
	// and Firefox scrolls device pixels, not CSS pixels
	var wheelPxFactor =
		(win && chrome) ? 2 * window.devicePixelRatio :
		gecko ? window.devicePixelRatio : 1;

	// @function getWheelDelta(ev: DOMEvent): Number
	// Gets normalized wheel delta from a mousewheel DOM event, in vertical
	// pixels scrolled (negative if scrolling down).
	// Events from pointing devices without precise scrolling are mapped to
	// a best guess of 60 pixels.
	function getWheelDelta(e) {
		return (edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
		       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		       0;
	}

	var skipEvents = {};

	function fakeStop(e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
		skipEvents[e.type] = true;
	}

	function skipped(e) {
		var events = skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		skipEvents[e.type] = false;
		return events;
	}

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	function isExternalTarget(el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	}

	var lastClick;

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	function filterClick(e, handler) {
		var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		    elapsed = lastClick && (timeStamp - lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			stop(e);
			return;
		}
		lastClick = timeStamp;

		handler(e);
	}




	var DomEvent = (Object.freeze || Object)({
		on: on,
		off: off,
		stopPropagation: stopPropagation,
		disableScrollPropagation: disableScrollPropagation,
		disableClickPropagation: disableClickPropagation,
		preventDefault: preventDefault,
		stop: stop,
		getMousePosition: getMousePosition,
		getWheelDelta: getWheelDelta,
		fakeStop: fakeStop,
		skipped: skipped,
		isExternalTarget: isExternalTarget,
		addListener: on,
		removeListener: off
	});

	/*
	 * @class PosAnimation
	 * @aka L.PosAnimation
	 * @inherits Evented
	 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
	 *
	 * @example
	 * ```js
	 * var fx = new L.PosAnimation();
	 * fx.run(el, [300, 500], 0.5);
	 * ```
	 *
	 * @constructor L.PosAnimation()
	 * Creates a `PosAnimation` object.
	 *
	 */

	var PosAnimation = Evented.extend({

		// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
		// Run an animation of a given element to a new position, optionally setting
		// duration in seconds (`0.25` by default) and easing linearity factor (3rd
		// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
		// `0.5` by default).
		run: function (el, newPos, duration, easeLinearity) {
			this.stop();

			this._el = el;
			this._inProgress = true;
			this._duration = duration || 0.25;
			this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

			this._startPos = getPosition(el);
			this._offset = newPos.subtract(this._startPos);
			this._startTime = +new Date();

			// @event start: Event
			// Fired when the animation starts
			this.fire('start');

			this._animate();
		},

		// @method stop()
		// Stops the animation (if currently running).
		stop: function () {
			if (!this._inProgress) { return; }

			this._step(true);
			this._complete();
		},

		_animate: function () {
			// animation loop
			this._animId = requestAnimFrame(this._animate, this);
			this._step();
		},

		_step: function (round) {
			var elapsed = (+new Date()) - this._startTime,
			    duration = this._duration * 1000;

			if (elapsed < duration) {
				this._runFrame(this._easeOut(elapsed / duration), round);
			} else {
				this._runFrame(1);
				this._complete();
			}
		},

		_runFrame: function (progress, round) {
			var pos = this._startPos.add(this._offset.multiplyBy(progress));
			if (round) {
				pos._round();
			}
			setPosition(this._el, pos);

			// @event step: Event
			// Fired continuously during the animation.
			this.fire('step');
		},

		_complete: function () {
			cancelAnimFrame(this._animId);

			this._inProgress = false;
			// @event end: Event
			// Fired when the animation ends.
			this.fire('end');
		},

		_easeOut: function (t) {
			return 1 - Math.pow(1 - t, this._easeOutPower);
		}
	});

	/*
	 * @class Map
	 * @aka L.Map
	 * @inherits Evented
	 *
	 * The central class of the API — it is used to create a map on a page and manipulate it.
	 *
	 * @example
	 *
	 * ```js
	 * // initialize the map on the "map" div with a given center and zoom
	 * var map = L.map('map', {
	 * 	center: [51.505, -0.09],
	 * 	zoom: 13
	 * });
	 * ```
	 *
	 */

	var Map = Evented.extend({

		options: {
			// @section Map State Options
			// @option crs: CRS = L.CRS.EPSG3857
			// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
			// sure what it means.
			crs: EPSG3857,

			// @option center: LatLng = undefined
			// Initial geographic center of the map
			center: undefined,

			// @option zoom: Number = undefined
			// Initial map zoom level
			zoom: undefined,

			// @option minZoom: Number = *
			// Minimum zoom level of the map.
			// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
			// the lowest of their `minZoom` options will be used instead.
			minZoom: undefined,

			// @option maxZoom: Number = *
			// Maximum zoom level of the map.
			// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
			// the highest of their `maxZoom` options will be used instead.
			maxZoom: undefined,

			// @option layers: Layer[] = []
			// Array of layers that will be added to the map initially
			layers: [],

			// @option maxBounds: LatLngBounds = null
			// When this option is set, the map restricts the view to the given
			// geographical bounds, bouncing the user back if the user tries to pan
			// outside the view. To set the restriction dynamically, use
			// [`setMaxBounds`](#map-setmaxbounds) method.
			maxBounds: undefined,

			// @option renderer: Renderer = *
			// The default method for drawing vector layers on the map. `L.SVG`
			// or `L.Canvas` by default depending on browser support.
			renderer: undefined,


			// @section Animation Options
			// @option zoomAnimation: Boolean = true
			// Whether the map zoom animation is enabled. By default it's enabled
			// in all browsers that support CSS3 Transitions except Android.
			zoomAnimation: true,

			// @option zoomAnimationThreshold: Number = 4
			// Won't animate zoom if the zoom difference exceeds this value.
			zoomAnimationThreshold: 4,

			// @option fadeAnimation: Boolean = true
			// Whether the tile fade animation is enabled. By default it's enabled
			// in all browsers that support CSS3 Transitions except Android.
			fadeAnimation: true,

			// @option markerZoomAnimation: Boolean = true
			// Whether markers animate their zoom with the zoom animation, if disabled
			// they will disappear for the length of the animation. By default it's
			// enabled in all browsers that support CSS3 Transitions except Android.
			markerZoomAnimation: true,

			// @option transform3DLimit: Number = 2^23
			// Defines the maximum size of a CSS translation transform. The default
			// value should not be changed unless a web browser positions layers in
			// the wrong place after doing a large `panBy`.
			transform3DLimit: 8388608, // Precision limit of a 32-bit float

			// @section Interaction Options
			// @option zoomSnap: Number = 1
			// Forces the map's zoom level to always be a multiple of this, particularly
			// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
			// By default, the zoom level snaps to the nearest integer; lower values
			// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
			// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
			zoomSnap: 1,

			// @option zoomDelta: Number = 1
			// Controls how much the map's zoom level will change after a
			// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
			// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
			// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
			zoomDelta: 1,

			// @option trackResize: Boolean = true
			// Whether the map automatically handles browser window resize to update itself.
			trackResize: true
		},

		initialize: function (id, options) { // (HTMLElement or String, Object)
			options = setOptions(this, options);

			// Make sure to assign internal flags at the beginning,
			// to avoid inconsistent state in some edge cases.
			this._handlers = [];
			this._layers = {};
			this._zoomBoundLayers = {};
			this._sizeChanged = true;

			this._initContainer(id);
			this._initLayout();

			// hack for https://github.com/Leaflet/Leaflet/issues/1980
			this._onResize = bind(this._onResize, this);

			this._initEvents();

			if (options.maxBounds) {
				this.setMaxBounds(options.maxBounds);
			}

			if (options.zoom !== undefined) {
				this._zoom = this._limitZoom(options.zoom);
			}

			if (options.center && options.zoom !== undefined) {
				this.setView(toLatLng(options.center), options.zoom, {reset: true});
			}

			this.callInitHooks();

			// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
			this._zoomAnimated = TRANSITION && any3d && !mobileOpera &&
					this.options.zoomAnimation;

			// zoom transitions run with the same duration for all layers, so if one of transitionend events
			// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
			if (this._zoomAnimated) {
				this._createAnimProxy();
				on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
			}

			this._addLayers(this.options.layers);
		},


		// @section Methods for modifying map state

		// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
		// Sets the view of the map (geographical center and zoom) with the given
		// animation options.
		setView: function (center, zoom, options) {

			zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
			center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
			options = options || {};

			this._stop();

			if (this._loaded && !options.reset && options !== true) {

				if (options.animate !== undefined) {
					options.zoom = extend({animate: options.animate}, options.zoom);
					options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
				}

				// try animating pan or zoom
				var moved = (this._zoom !== zoom) ?
					this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
					this._tryAnimatedPan(center, options.pan);

				if (moved) {
					// prevent resize handler call, the view will refresh after animation anyway
					clearTimeout(this._sizeTimer);
					return this;
				}
			}

			// animation didn't start, just reset the map view
			this._resetView(center, zoom);

			return this;
		},

		// @method setZoom(zoom: Number, options?: Zoom/pan options): this
		// Sets the zoom of the map.
		setZoom: function (zoom, options) {
			if (!this._loaded) {
				this._zoom = zoom;
				return this;
			}
			return this.setView(this.getCenter(), zoom, {zoom: options});
		},

		// @method zoomIn(delta?: Number, options?: Zoom options): this
		// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
		zoomIn: function (delta, options) {
			delta = delta || (any3d ? this.options.zoomDelta : 1);
			return this.setZoom(this._zoom + delta, options);
		},

		// @method zoomOut(delta?: Number, options?: Zoom options): this
		// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
		zoomOut: function (delta, options) {
			delta = delta || (any3d ? this.options.zoomDelta : 1);
			return this.setZoom(this._zoom - delta, options);
		},

		// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
		// Zooms the map while keeping a specified geographical point on the map
		// stationary (e.g. used internally for scroll zoom and double-click zoom).
		// @alternative
		// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
		// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
		setZoomAround: function (latlng, zoom, options) {
			var scale = this.getZoomScale(zoom),
			    viewHalf = this.getSize().divideBy(2),
			    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

			    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
			    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

			return this.setView(newCenter, zoom, {zoom: options});
		},

		_getBoundsCenterZoom: function (bounds, options) {

			options = options || {};
			bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

			var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
			    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

			    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

			zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

			if (zoom === Infinity) {
				return {
					center: bounds.getCenter(),
					zoom: zoom
				};
			}

			var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

			    swPoint = this.project(bounds.getSouthWest(), zoom),
			    nePoint = this.project(bounds.getNorthEast(), zoom),
			    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

			return {
				center: center,
				zoom: zoom
			};
		},

		// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
		// Sets a map view that contains the given geographical bounds with the
		// maximum zoom level possible.
		fitBounds: function (bounds, options) {

			bounds = toLatLngBounds(bounds);

			if (!bounds.isValid()) {
				throw new Error('Bounds are not valid.');
			}

			var target = this._getBoundsCenterZoom(bounds, options);
			return this.setView(target.center, target.zoom, options);
		},

		// @method fitWorld(options?: fitBounds options): this
		// Sets a map view that mostly contains the whole world with the maximum
		// zoom level possible.
		fitWorld: function (options) {
			return this.fitBounds([[-90, -180], [90, 180]], options);
		},

		// @method panTo(latlng: LatLng, options?: Pan options): this
		// Pans the map to a given center.
		panTo: function (center, options) { // (LatLng)
			return this.setView(center, this._zoom, {pan: options});
		},

		// @method panBy(offset: Point, options?: Pan options): this
		// Pans the map by a given number of pixels (animated).
		panBy: function (offset, options) {
			offset = toPoint(offset).round();
			options = options || {};

			if (!offset.x && !offset.y) {
				return this.fire('moveend');
			}
			// If we pan too far, Chrome gets issues with tiles
			// and makes them disappear or appear in the wrong place (slightly offset) #2602
			if (options.animate !== true && !this.getSize().contains(offset)) {
				this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
				return this;
			}

			if (!this._panAnim) {
				this._panAnim = new PosAnimation();

				this._panAnim.on({
					'step': this._onPanTransitionStep,
					'end': this._onPanTransitionEnd
				}, this);
			}

			// don't fire movestart if animating inertia
			if (!options.noMoveStart) {
				this.fire('movestart');
			}

			// animate pan unless animate: false specified
			if (options.animate !== false) {
				addClass(this._mapPane, 'leaflet-pan-anim');

				var newPos = this._getMapPanePos().subtract(offset).round();
				this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
			} else {
				this._rawPanBy(offset);
				this.fire('move').fire('moveend');
			}

			return this;
		},

		// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
		// Sets the view of the map (geographical center and zoom) performing a smooth
		// pan-zoom animation.
		flyTo: function (targetCenter, targetZoom, options) {

			options = options || {};
			if (options.animate === false || !any3d) {
				return this.setView(targetCenter, targetZoom, options);
			}

			this._stop();

			var from = this.project(this.getCenter()),
			    to = this.project(targetCenter),
			    size = this.getSize(),
			    startZoom = this._zoom;

			targetCenter = toLatLng(targetCenter);
			targetZoom = targetZoom === undefined ? startZoom : targetZoom;

			var w0 = Math.max(size.x, size.y),
			    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
			    u1 = (to.distanceTo(from)) || 1,
			    rho = 1.42,
			    rho2 = rho * rho;

			function r(i) {
				var s1 = i ? -1 : 1,
				    s2 = i ? w1 : w0,
				    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
				    b1 = 2 * s2 * rho2 * u1,
				    b = t1 / b1,
				    sq = Math.sqrt(b * b + 1) - b;

				    // workaround for floating point precision bug when sq = 0, log = -Infinite,
				    // thus triggering an infinite loop in flyTo
				    var log = sq < 0.000000001 ? -18 : Math.log(sq);

				return log;
			}

			function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
			function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
			function tanh(n) { return sinh(n) / cosh(n); }

			var r0 = r(0);

			function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
			function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

			function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

			var start = Date.now(),
			    S = (r(1) - r0) / rho,
			    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

			function frame() {
				var t = (Date.now() - start) / duration,
				    s = easeOut(t) * S;

				if (t <= 1) {
					this._flyToFrame = requestAnimFrame(frame, this);

					this._move(
						this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
						this.getScaleZoom(w0 / w(s), startZoom),
						{flyTo: true});

				} else {
					this
						._move(targetCenter, targetZoom)
						._moveEnd(true);
				}
			}

			this._moveStart(true, options.noMoveStart);

			frame.call(this);
			return this;
		},

		// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
		// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
		// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
		flyToBounds: function (bounds, options) {
			var target = this._getBoundsCenterZoom(bounds, options);
			return this.flyTo(target.center, target.zoom, options);
		},

		// @method setMaxBounds(bounds: Bounds): this
		// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
		setMaxBounds: function (bounds) {
			bounds = toLatLngBounds(bounds);

			if (!bounds.isValid()) {
				this.options.maxBounds = null;
				return this.off('moveend', this._panInsideMaxBounds);
			} else if (this.options.maxBounds) {
				this.off('moveend', this._panInsideMaxBounds);
			}

			this.options.maxBounds = bounds;

			if (this._loaded) {
				this._panInsideMaxBounds();
			}

			return this.on('moveend', this._panInsideMaxBounds);
		},

		// @method setMinZoom(zoom: Number): this
		// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
		setMinZoom: function (zoom) {
			var oldZoom = this.options.minZoom;
			this.options.minZoom = zoom;

			if (this._loaded && oldZoom !== zoom) {
				this.fire('zoomlevelschange');

				if (this.getZoom() < this.options.minZoom) {
					return this.setZoom(zoom);
				}
			}

			return this;
		},

		// @method setMaxZoom(zoom: Number): this
		// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
		setMaxZoom: function (zoom) {
			var oldZoom = this.options.maxZoom;
			this.options.maxZoom = zoom;

			if (this._loaded && oldZoom !== zoom) {
				this.fire('zoomlevelschange');

				if (this.getZoom() > this.options.maxZoom) {
					return this.setZoom(zoom);
				}
			}

			return this;
		},

		// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
		// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
		panInsideBounds: function (bounds, options) {
			this._enforcingBounds = true;
			var center = this.getCenter(),
			    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

			if (!center.equals(newCenter)) {
				this.panTo(newCenter, options);
			}

			this._enforcingBounds = false;
			return this;
		},

		// @method panInside(latlng: LatLng, options?: options): this
		// Pans the map the minimum amount to make the `latlng` visible. Use
		// `padding`, `paddingTopLeft` and `paddingTopRight` options to fit
		// the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).
		// If `latlng` is already within the (optionally padded) display bounds,
		// the map will not be panned.
		panInside: function (latlng, options) {
			options = options || {};

			var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
			    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
			    center = this.getCenter(),
			    pixelCenter = this.project(center),
			    pixelPoint = this.project(latlng),
			    pixelBounds = this.getPixelBounds(),
			    halfPixelBounds = pixelBounds.getSize().divideBy(2),
			    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);

			if (!paddedBounds.contains(pixelPoint)) {
				this._enforcingBounds = true;
				var diff = pixelCenter.subtract(pixelPoint),
				    newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);

				if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
					newCenter.x = pixelCenter.x - diff.x;
					if (diff.x > 0) {
						newCenter.x += halfPixelBounds.x - paddingTL.x;
					} else {
						newCenter.x -= halfPixelBounds.x - paddingBR.x;
					}
				}
				if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
					newCenter.y = pixelCenter.y - diff.y;
					if (diff.y > 0) {
						newCenter.y += halfPixelBounds.y - paddingTL.y;
					} else {
						newCenter.y -= halfPixelBounds.y - paddingBR.y;
					}
				}
				this.panTo(this.unproject(newCenter), options);
				this._enforcingBounds = false;
			}
			return this;
		},

		// @method invalidateSize(options: Zoom/pan options): this
		// Checks if the map container size changed and updates the map if so —
		// call it after you've changed the map size dynamically, also animating
		// pan by default. If `options.pan` is `false`, panning will not occur.
		// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
		// that it doesn't happen often even if the method is called many
		// times in a row.

		// @alternative
		// @method invalidateSize(animate: Boolean): this
		// Checks if the map container size changed and updates the map if so —
		// call it after you've changed the map size dynamically, also animating
		// pan by default.
		invalidateSize: function (options) {
			if (!this._loaded) { return this; }

			options = extend({
				animate: false,
				pan: true
			}, options === true ? {animate: true} : options);

			var oldSize = this.getSize();
			this._sizeChanged = true;
			this._lastCenter = null;

			var newSize = this.getSize(),
			    oldCenter = oldSize.divideBy(2).round(),
			    newCenter = newSize.divideBy(2).round(),
			    offset = oldCenter.subtract(newCenter);

			if (!offset.x && !offset.y) { return this; }

			if (options.animate && options.pan) {
				this.panBy(offset);

			} else {
				if (options.pan) {
					this._rawPanBy(offset);
				}

				this.fire('move');

				if (options.debounceMoveend) {
					clearTimeout(this._sizeTimer);
					this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
				} else {
					this.fire('moveend');
				}
			}

			// @section Map state change events
			// @event resize: ResizeEvent
			// Fired when the map is resized.
			return this.fire('resize', {
				oldSize: oldSize,
				newSize: newSize
			});
		},

		// @section Methods for modifying map state
		// @method stop(): this
		// Stops the currently running `panTo` or `flyTo` animation, if any.
		stop: function () {
			this.setZoom(this._limitZoom(this._zoom));
			if (!this.options.zoomSnap) {
				this.fire('viewreset');
			}
			return this._stop();
		},

		// @section Geolocation methods
		// @method locate(options?: Locate options): this
		// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
		// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
		// and optionally sets the map view to the user's location with respect to
		// detection accuracy (or to the world view if geolocation failed).
		// Note that, if your page doesn't use HTTPS, this method will fail in
		// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
		// See `Locate options` for more details.
		locate: function (options) {

			options = this._locateOptions = extend({
				timeout: 10000,
				watch: false
				// setView: false
				// maxZoom: <Number>
				// maximumAge: 0
				// enableHighAccuracy: false
			}, options);

			if (!('geolocation' in navigator)) {
				this._handleGeolocationError({
					code: 0,
					message: 'Geolocation not supported.'
				});
				return this;
			}

			var onResponse = bind(this._handleGeolocationResponse, this),
			    onError = bind(this._handleGeolocationError, this);

			if (options.watch) {
				this._locationWatchId =
				        navigator.geolocation.watchPosition(onResponse, onError, options);
			} else {
				navigator.geolocation.getCurrentPosition(onResponse, onError, options);
			}
			return this;
		},

		// @method stopLocate(): this
		// Stops watching location previously initiated by `map.locate({watch: true})`
		// and aborts resetting the map view if map.locate was called with
		// `{setView: true}`.
		stopLocate: function () {
			if (navigator.geolocation && navigator.geolocation.clearWatch) {
				navigator.geolocation.clearWatch(this._locationWatchId);
			}
			if (this._locateOptions) {
				this._locateOptions.setView = false;
			}
			return this;
		},

		_handleGeolocationError: function (error) {
			var c = error.code,
			    message = error.message ||
			            (c === 1 ? 'permission denied' :
			            (c === 2 ? 'position unavailable' : 'timeout'));

			if (this._locateOptions.setView && !this._loaded) {
				this.fitWorld();
			}

			// @section Location events
			// @event locationerror: ErrorEvent
			// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
			this.fire('locationerror', {
				code: c,
				message: 'Geolocation error: ' + message + '.'
			});
		},

		_handleGeolocationResponse: function (pos) {
			var lat = pos.coords.latitude,
			    lng = pos.coords.longitude,
			    latlng = new LatLng(lat, lng),
			    bounds = latlng.toBounds(pos.coords.accuracy * 2),
			    options = this._locateOptions;

			if (options.setView) {
				var zoom = this.getBoundsZoom(bounds);
				this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
			}

			var data = {
				latlng: latlng,
				bounds: bounds,
				timestamp: pos.timestamp
			};

			for (var i in pos.coords) {
				if (typeof pos.coords[i] === 'number') {
					data[i] = pos.coords[i];
				}
			}

			// @event locationfound: LocationEvent
			// Fired when geolocation (using the [`locate`](#map-locate) method)
			// went successfully.
			this.fire('locationfound', data);
		},

		// TODO Appropriate docs section?
		// @section Other Methods
		// @method addHandler(name: String, HandlerClass: Function): this
		// Adds a new `Handler` to the map, given its name and constructor function.
		addHandler: function (name, HandlerClass) {
			if (!HandlerClass) { return this; }

			var handler = this[name] = new HandlerClass(this);

			this._handlers.push(handler);

			if (this.options[name]) {
				handler.enable();
			}

			return this;
		},

		// @method remove(): this
		// Destroys the map and clears all related event listeners.
		remove: function () {

			this._initEvents(true);

			if (this._containerId !== this._container._leaflet_id) {
				throw new Error('Map container is being reused by another instance');
			}

			try {
				// throws error in IE6-8
				delete this._container._leaflet_id;
				delete this._containerId;
			} catch (e) {
				/*eslint-disable */
				this._container._leaflet_id = undefined;
				/* eslint-enable */
				this._containerId = undefined;
			}

			if (this._locationWatchId !== undefined) {
				this.stopLocate();
			}

			this._stop();

			remove(this._mapPane);

			if (this._clearControlPos) {
				this._clearControlPos();
			}
			if (this._resizeRequest) {
				cancelAnimFrame(this._resizeRequest);
				this._resizeRequest = null;
			}

			this._clearHandlers();

			if (this._loaded) {
				// @section Map state change events
				// @event unload: Event
				// Fired when the map is destroyed with [remove](#map-remove) method.
				this.fire('unload');
			}

			var i;
			for (i in this._layers) {
				this._layers[i].remove();
			}
			for (i in this._panes) {
				remove(this._panes[i]);
			}

			this._layers = [];
			this._panes = [];
			delete this._mapPane;
			delete this._renderer;

			return this;
		},

		// @section Other Methods
		// @method createPane(name: String, container?: HTMLElement): HTMLElement
		// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
		// then returns it. The pane is created as a child of `container`, or
		// as a child of the main map pane if not set.
		createPane: function (name, container) {
			var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
			    pane = create$1('div', className, container || this._mapPane);

			if (name) {
				this._panes[name] = pane;
			}
			return pane;
		},

		// @section Methods for Getting Map State

		// @method getCenter(): LatLng
		// Returns the geographical center of the map view
		getCenter: function () {
			this._checkIfLoaded();

			if (this._lastCenter && !this._moved()) {
				return this._lastCenter;
			}
			return this.layerPointToLatLng(this._getCenterLayerPoint());
		},

		// @method getZoom(): Number
		// Returns the current zoom level of the map view
		getZoom: function () {
			return this._zoom;
		},

		// @method getBounds(): LatLngBounds
		// Returns the geographical bounds visible in the current map view
		getBounds: function () {
			var bounds = this.getPixelBounds(),
			    sw = this.unproject(bounds.getBottomLeft()),
			    ne = this.unproject(bounds.getTopRight());

			return new LatLngBounds(sw, ne);
		},

		// @method getMinZoom(): Number
		// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
		getMinZoom: function () {
			return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
		},

		// @method getMaxZoom(): Number
		// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
		getMaxZoom: function () {
			return this.options.maxZoom === undefined ?
				(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
				this.options.maxZoom;
		},

		// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
		// Returns the maximum zoom level on which the given bounds fit to the map
		// view in its entirety. If `inside` (optional) is set to `true`, the method
		// instead returns the minimum zoom level on which the map view fits into
		// the given bounds in its entirety.
		getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
			bounds = toLatLngBounds(bounds);
			padding = toPoint(padding || [0, 0]);

			var zoom = this.getZoom() || 0,
			    min = this.getMinZoom(),
			    max = this.getMaxZoom(),
			    nw = bounds.getNorthWest(),
			    se = bounds.getSouthEast(),
			    size = this.getSize().subtract(padding),
			    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
			    snap = any3d ? this.options.zoomSnap : 1,
			    scalex = size.x / boundsSize.x,
			    scaley = size.y / boundsSize.y,
			    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

			zoom = this.getScaleZoom(scale, zoom);

			if (snap) {
				zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
				zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
			}

			return Math.max(min, Math.min(max, zoom));
		},

		// @method getSize(): Point
		// Returns the current size of the map container (in pixels).
		getSize: function () {
			if (!this._size || this._sizeChanged) {
				this._size = new Point(
					this._container.clientWidth || 0,
					this._container.clientHeight || 0);

				this._sizeChanged = false;
			}
			return this._size.clone();
		},

		// @method getPixelBounds(): Bounds
		// Returns the bounds of the current map view in projected pixel
		// coordinates (sometimes useful in layer and overlay implementations).
		getPixelBounds: function (center, zoom) {
			var topLeftPoint = this._getTopLeftPoint(center, zoom);
			return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
		},

		// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
		// the map pane? "left point of the map layer" can be confusing, specially
		// since there can be negative offsets.
		// @method getPixelOrigin(): Point
		// Returns the projected pixel coordinates of the top left point of
		// the map layer (useful in custom layer and overlay implementations).
		getPixelOrigin: function () {
			this._checkIfLoaded();
			return this._pixelOrigin;
		},

		// @method getPixelWorldBounds(zoom?: Number): Bounds
		// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
		// If `zoom` is omitted, the map's current zoom level is used.
		getPixelWorldBounds: function (zoom) {
			return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
		},

		// @section Other Methods

		// @method getPane(pane: String|HTMLElement): HTMLElement
		// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
		getPane: function (pane) {
			return typeof pane === 'string' ? this._panes[pane] : pane;
		},

		// @method getPanes(): Object
		// Returns a plain object containing the names of all [panes](#map-pane) as keys and
		// the panes as values.
		getPanes: function () {
			return this._panes;
		},

		// @method getContainer: HTMLElement
		// Returns the HTML element that contains the map.
		getContainer: function () {
			return this._container;
		},


		// @section Conversion Methods

		// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
		// Returns the scale factor to be applied to a map transition from zoom level
		// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
		getZoomScale: function (toZoom, fromZoom) {
			// TODO replace with universal implementation after refactoring projections
			var crs = this.options.crs;
			fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
			return crs.scale(toZoom) / crs.scale(fromZoom);
		},

		// @method getScaleZoom(scale: Number, fromZoom: Number): Number
		// Returns the zoom level that the map would end up at, if it is at `fromZoom`
		// level and everything is scaled by a factor of `scale`. Inverse of
		// [`getZoomScale`](#map-getZoomScale).
		getScaleZoom: function (scale, fromZoom) {
			var crs = this.options.crs;
			fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
			var zoom = crs.zoom(scale * crs.scale(fromZoom));
			return isNaN(zoom) ? Infinity : zoom;
		},

		// @method project(latlng: LatLng, zoom: Number): Point
		// Projects a geographical coordinate `LatLng` according to the projection
		// of the map's CRS, then scales it according to `zoom` and the CRS's
		// `Transformation`. The result is pixel coordinate relative to
		// the CRS origin.
		project: function (latlng, zoom) {
			zoom = zoom === undefined ? this._zoom : zoom;
			return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
		},

		// @method unproject(point: Point, zoom: Number): LatLng
		// Inverse of [`project`](#map-project).
		unproject: function (point, zoom) {
			zoom = zoom === undefined ? this._zoom : zoom;
			return this.options.crs.pointToLatLng(toPoint(point), zoom);
		},

		// @method layerPointToLatLng(point: Point): LatLng
		// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
		// returns the corresponding geographical coordinate (for the current zoom level).
		layerPointToLatLng: function (point) {
			var projectedPoint = toPoint(point).add(this.getPixelOrigin());
			return this.unproject(projectedPoint);
		},

		// @method latLngToLayerPoint(latlng: LatLng): Point
		// Given a geographical coordinate, returns the corresponding pixel coordinate
		// relative to the [origin pixel](#map-getpixelorigin).
		latLngToLayerPoint: function (latlng) {
			var projectedPoint = this.project(toLatLng(latlng))._round();
			return projectedPoint._subtract(this.getPixelOrigin());
		},

		// @method wrapLatLng(latlng: LatLng): LatLng
		// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
		// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
		// CRS's bounds.
		// By default this means longitude is wrapped around the dateline so its
		// value is between -180 and +180 degrees.
		wrapLatLng: function (latlng) {
			return this.options.crs.wrapLatLng(toLatLng(latlng));
		},

		// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
		// Returns a `LatLngBounds` with the same size as the given one, ensuring that
		// its center is within the CRS's bounds.
		// By default this means the center longitude is wrapped around the dateline so its
		// value is between -180 and +180 degrees, and the majority of the bounds
		// overlaps the CRS's bounds.
		wrapLatLngBounds: function (latlng) {
			return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
		},

		// @method distance(latlng1: LatLng, latlng2: LatLng): Number
		// Returns the distance between two geographical coordinates according to
		// the map's CRS. By default this measures distance in meters.
		distance: function (latlng1, latlng2) {
			return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
		},

		// @method containerPointToLayerPoint(point: Point): Point
		// Given a pixel coordinate relative to the map container, returns the corresponding
		// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
		containerPointToLayerPoint: function (point) { // (Point)
			return toPoint(point).subtract(this._getMapPanePos());
		},

		// @method layerPointToContainerPoint(point: Point): Point
		// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
		// returns the corresponding pixel coordinate relative to the map container.
		layerPointToContainerPoint: function (point) { // (Point)
			return toPoint(point).add(this._getMapPanePos());
		},

		// @method containerPointToLatLng(point: Point): LatLng
		// Given a pixel coordinate relative to the map container, returns
		// the corresponding geographical coordinate (for the current zoom level).
		containerPointToLatLng: function (point) {
			var layerPoint = this.containerPointToLayerPoint(toPoint(point));
			return this.layerPointToLatLng(layerPoint);
		},

		// @method latLngToContainerPoint(latlng: LatLng): Point
		// Given a geographical coordinate, returns the corresponding pixel coordinate
		// relative to the map container.
		latLngToContainerPoint: function (latlng) {
			return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
		},

		// @method mouseEventToContainerPoint(ev: MouseEvent): Point
		// Given a MouseEvent object, returns the pixel coordinate relative to the
		// map container where the event took place.
		mouseEventToContainerPoint: function (e) {
			return getMousePosition(e, this._container);
		},

		// @method mouseEventToLayerPoint(ev: MouseEvent): Point
		// Given a MouseEvent object, returns the pixel coordinate relative to
		// the [origin pixel](#map-getpixelorigin) where the event took place.
		mouseEventToLayerPoint: function (e) {
			return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
		},

		// @method mouseEventToLatLng(ev: MouseEvent): LatLng
		// Given a MouseEvent object, returns geographical coordinate where the
		// event took place.
		mouseEventToLatLng: function (e) { // (MouseEvent)
			return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
		},


		// map initialization methods

		_initContainer: function (id) {
			var container = this._container = get(id);

			if (!container) {
				throw new Error('Map container not found.');
			} else if (container._leaflet_id) {
				throw new Error('Map container is already initialized.');
			}

			on(container, 'scroll', this._onScroll, this);
			this._containerId = stamp(container);
		},

		_initLayout: function () {
			var container = this._container;

			this._fadeAnimated = this.options.fadeAnimation && any3d;

			addClass(container, 'leaflet-container' +
				(touch ? ' leaflet-touch' : '') +
				(retina ? ' leaflet-retina' : '') +
				(ielt9 ? ' leaflet-oldie' : '') +
				(safari ? ' leaflet-safari' : '') +
				(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

			var position = getStyle(container, 'position');

			if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
				container.style.position = 'relative';
			}

			this._initPanes();

			if (this._initControlPos) {
				this._initControlPos();
			}
		},

		_initPanes: function () {
			var panes = this._panes = {};
			this._paneRenderers = {};

			// @section
			//
			// Panes are DOM elements used to control the ordering of layers on the map. You
			// can access panes with [`map.getPane`](#map-getpane) or
			// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
			// [`map.createPane`](#map-createpane) method.
			//
			// Every map has the following default panes that differ only in zIndex.
			//
			// @pane mapPane: HTMLElement = 'auto'
			// Pane that contains all other map panes

			this._mapPane = this.createPane('mapPane', this._container);
			setPosition(this._mapPane, new Point(0, 0));

			// @pane tilePane: HTMLElement = 200
			// Pane for `GridLayer`s and `TileLayer`s
			this.createPane('tilePane');
			// @pane overlayPane: HTMLElement = 400
			// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
			this.createPane('shadowPane');
			// @pane shadowPane: HTMLElement = 500
			// Pane for overlay shadows (e.g. `Marker` shadows)
			this.createPane('overlayPane');
			// @pane markerPane: HTMLElement = 600
			// Pane for `Icon`s of `Marker`s
			this.createPane('markerPane');
			// @pane tooltipPane: HTMLElement = 650
			// Pane for `Tooltip`s.
			this.createPane('tooltipPane');
			// @pane popupPane: HTMLElement = 700
			// Pane for `Popup`s.
			this.createPane('popupPane');

			if (!this.options.markerZoomAnimation) {
				addClass(panes.markerPane, 'leaflet-zoom-hide');
				addClass(panes.shadowPane, 'leaflet-zoom-hide');
			}
		},


		// private methods that modify map state

		// @section Map state change events
		_resetView: function (center, zoom) {
			setPosition(this._mapPane, new Point(0, 0));

			var loading = !this._loaded;
			this._loaded = true;
			zoom = this._limitZoom(zoom);

			this.fire('viewprereset');

			var zoomChanged = this._zoom !== zoom;
			this
				._moveStart(zoomChanged, false)
				._move(center, zoom)
				._moveEnd(zoomChanged);

			// @event viewreset: Event
			// Fired when the map needs to redraw its content (this usually happens
			// on map zoom or load). Very useful for creating custom overlays.
			this.fire('viewreset');

			// @event load: Event
			// Fired when the map is initialized (when its center and zoom are set
			// for the first time).
			if (loading) {
				this.fire('load');
			}
		},

		_moveStart: function (zoomChanged, noMoveStart) {
			// @event zoomstart: Event
			// Fired when the map zoom is about to change (e.g. before zoom animation).
			// @event movestart: Event
			// Fired when the view of the map starts changing (e.g. user starts dragging the map).
			if (zoomChanged) {
				this.fire('zoomstart');
			}
			if (!noMoveStart) {
				this.fire('movestart');
			}
			return this;
		},

		_move: function (center, zoom, data) {
			if (zoom === undefined) {
				zoom = this._zoom;
			}
			var zoomChanged = this._zoom !== zoom;

			this._zoom = zoom;
			this._lastCenter = center;
			this._pixelOrigin = this._getNewPixelOrigin(center);

			// @event zoom: Event
			// Fired repeatedly during any change in zoom level, including zoom
			// and fly animations.
			if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
				this.fire('zoom', data);
			}

			// @event move: Event
			// Fired repeatedly during any movement of the map, including pan and
			// fly animations.
			return this.fire('move', data);
		},

		_moveEnd: function (zoomChanged) {
			// @event zoomend: Event
			// Fired when the map has changed, after any animations.
			if (zoomChanged) {
				this.fire('zoomend');
			}

			// @event moveend: Event
			// Fired when the center of the map stops changing (e.g. user stopped
			// dragging the map).
			return this.fire('moveend');
		},

		_stop: function () {
			cancelAnimFrame(this._flyToFrame);
			if (this._panAnim) {
				this._panAnim.stop();
			}
			return this;
		},

		_rawPanBy: function (offset) {
			setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
		},

		_getZoomSpan: function () {
			return this.getMaxZoom() - this.getMinZoom();
		},

		_panInsideMaxBounds: function () {
			if (!this._enforcingBounds) {
				this.panInsideBounds(this.options.maxBounds);
			}
		},

		_checkIfLoaded: function () {
			if (!this._loaded) {
				throw new Error('Set map center and zoom first.');
			}
		},

		// DOM event handling

		// @section Interaction events
		_initEvents: function (remove$$1) {
			this._targets = {};
			this._targets[stamp(this._container)] = this;

			var onOff = remove$$1 ? off : on;

			// @event click: MouseEvent
			// Fired when the user clicks (or taps) the map.
			// @event dblclick: MouseEvent
			// Fired when the user double-clicks (or double-taps) the map.
			// @event mousedown: MouseEvent
			// Fired when the user pushes the mouse button on the map.
			// @event mouseup: MouseEvent
			// Fired when the user releases the mouse button on the map.
			// @event mouseover: MouseEvent
			// Fired when the mouse enters the map.
			// @event mouseout: MouseEvent
			// Fired when the mouse leaves the map.
			// @event mousemove: MouseEvent
			// Fired while the mouse moves over the map.
			// @event contextmenu: MouseEvent
			// Fired when the user pushes the right mouse button on the map, prevents
			// default browser context menu from showing if there are listeners on
			// this event. Also fired on mobile when the user holds a single touch
			// for a second (also called long press).
			// @event keypress: KeyboardEvent
			// Fired when the user presses a key from the keyboard while the map is focused.
			onOff(this._container, 'click dblclick mousedown mouseup ' +
				'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

			if (this.options.trackResize) {
				onOff(window, 'resize', this._onResize, this);
			}

			if (any3d && this.options.transform3DLimit) {
				(remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
			}
		},

		_onResize: function () {
			cancelAnimFrame(this._resizeRequest);
			this._resizeRequest = requestAnimFrame(
			        function () { this.invalidateSize({debounceMoveend: true}); }, this);
		},

		_onScroll: function () {
			this._container.scrollTop  = 0;
			this._container.scrollLeft = 0;
		},

		_onMoveEnd: function () {
			var pos = this._getMapPanePos();
			if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
				// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
				// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
				this._resetView(this.getCenter(), this.getZoom());
			}
		},

		_findEventTargets: function (e, type) {
			var targets = [],
			    target,
			    isHover = type === 'mouseout' || type === 'mouseover',
			    src = e.target || e.srcElement,
			    dragging = false;

			while (src) {
				target = this._targets[stamp(src)];
				if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
					// Prevent firing click after you just dragged an object.
					dragging = true;
					break;
				}
				if (target && target.listens(type, true)) {
					if (isHover && !isExternalTarget(src, e)) { break; }
					targets.push(target);
					if (isHover) { break; }
				}
				if (src === this._container) { break; }
				src = src.parentNode;
			}
			if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
				targets = [this];
			}
			return targets;
		},

		_handleDOMEvent: function (e) {
			if (!this._loaded || skipped(e)) { return; }

			var type = e.type;

			if (type === 'mousedown' || type === 'keypress') {
				// prevents outline when clicking on keyboard-focusable element
				preventOutline(e.target || e.srcElement);
			}

			this._fireDOMEvent(e, type);
		},

		_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

		_fireDOMEvent: function (e, type, targets) {

			if (e.type === 'click') {
				// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
				// @event preclick: MouseEvent
				// Fired before mouse click on the map (sometimes useful when you
				// want something to happen on click before any existing click
				// handlers start running).
				var synth = extend({}, e);
				synth.type = 'preclick';
				this._fireDOMEvent(synth, synth.type, targets);
			}

			if (e._stopped) { return; }

			// Find the layer the event is propagating from and its parents.
			targets = (targets || []).concat(this._findEventTargets(e, type));

			if (!targets.length) { return; }

			var target = targets[0];
			if (type === 'contextmenu' && target.listens(type, true)) {
				preventDefault(e);
			}

			var data = {
				originalEvent: e
			};

			if (e.type !== 'keypress') {
				var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
				data.containerPoint = isMarker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
				data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
				data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
			}

			for (var i = 0; i < targets.length; i++) {
				targets[i].fire(type, data, true);
				if (data.originalEvent._stopped ||
					(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
			}
		},

		_draggableMoved: function (obj) {
			obj = obj.dragging && obj.dragging.enabled() ? obj : this;
			return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
		},

		_clearHandlers: function () {
			for (var i = 0, len = this._handlers.length; i < len; i++) {
				this._handlers[i].disable();
			}
		},

		// @section Other Methods

		// @method whenReady(fn: Function, context?: Object): this
		// Runs the given function `fn` when the map gets initialized with
		// a view (center and zoom) and at least one layer, or immediately
		// if it's already initialized, optionally passing a function context.
		whenReady: function (callback, context) {
			if (this._loaded) {
				callback.call(context || this, {target: this});
			} else {
				this.on('load', callback, context);
			}
			return this;
		},


		// private methods for getting map state

		_getMapPanePos: function () {
			return getPosition(this._mapPane) || new Point(0, 0);
		},

		_moved: function () {
			var pos = this._getMapPanePos();
			return pos && !pos.equals([0, 0]);
		},

		_getTopLeftPoint: function (center, zoom) {
			var pixelOrigin = center && zoom !== undefined ?
				this._getNewPixelOrigin(center, zoom) :
				this.getPixelOrigin();
			return pixelOrigin.subtract(this._getMapPanePos());
		},

		_getNewPixelOrigin: function (center, zoom) {
			var viewHalf = this.getSize()._divideBy(2);
			return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
		},

		_latLngToNewLayerPoint: function (latlng, zoom, center) {
			var topLeft = this._getNewPixelOrigin(center, zoom);
			return this.project(latlng, zoom)._subtract(topLeft);
		},

		_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
			var topLeft = this._getNewPixelOrigin(center, zoom);
			return toBounds([
				this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
				this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
				this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
				this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
			]);
		},

		// layer point of the current center
		_getCenterLayerPoint: function () {
			return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
		},

		// offset of the specified place to the current center in pixels
		_getCenterOffset: function (latlng) {
			return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
		},

		// adjust center for view to get inside bounds
		_limitCenter: function (center, zoom, bounds) {

			if (!bounds) { return center; }

			var centerPoint = this.project(center, zoom),
			    viewHalf = this.getSize().divideBy(2),
			    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
			    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

			// If offset is less than a pixel, ignore.
			// This prevents unstable projections from getting into
			// an infinite loop of tiny offsets.
			if (offset.round().equals([0, 0])) {
				return center;
			}

			return this.unproject(centerPoint.add(offset), zoom);
		},

		// adjust offset for view to get inside bounds
		_limitOffset: function (offset, bounds) {
			if (!bounds) { return offset; }

			var viewBounds = this.getPixelBounds(),
			    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

			return offset.add(this._getBoundsOffset(newBounds, bounds));
		},

		// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
		_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
			var projectedMaxBounds = toBounds(
			        this.project(maxBounds.getNorthEast(), zoom),
			        this.project(maxBounds.getSouthWest(), zoom)
			    ),
			    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
			    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

			    dx = this._rebound(minOffset.x, -maxOffset.x),
			    dy = this._rebound(minOffset.y, -maxOffset.y);

			return new Point(dx, dy);
		},

		_rebound: function (left, right) {
			return left + right > 0 ?
				Math.round(left - right) / 2 :
				Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
		},

		_limitZoom: function (zoom) {
			var min = this.getMinZoom(),
			    max = this.getMaxZoom(),
			    snap = any3d ? this.options.zoomSnap : 1;
			if (snap) {
				zoom = Math.round(zoom / snap) * snap;
			}
			return Math.max(min, Math.min(max, zoom));
		},

		_onPanTransitionStep: function () {
			this.fire('move');
		},

		_onPanTransitionEnd: function () {
			removeClass(this._mapPane, 'leaflet-pan-anim');
			this.fire('moveend');
		},

		_tryAnimatedPan: function (center, options) {
			// difference between the new and current centers in pixels
			var offset = this._getCenterOffset(center)._trunc();

			// don't animate too far unless animate: true specified in options
			if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

			this.panBy(offset, options);

			return true;
		},

		_createAnimProxy: function () {

			var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
			this._panes.mapPane.appendChild(proxy);

			this.on('zoomanim', function (e) {
				var prop = TRANSFORM,
				    transform = this._proxy.style[prop];

				setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

				// workaround for case when transform is the same and so transitionend event is not fired
				if (transform === this._proxy.style[prop] && this._animatingZoom) {
					this._onZoomTransitionEnd();
				}
			}, this);

			this.on('load moveend', function () {
				var c = this.getCenter(),
				    z = this.getZoom();
				setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
			}, this);

			this._on('unload', this._destroyAnimProxy, this);
		},

		_destroyAnimProxy: function () {
			remove(this._proxy);
			delete this._proxy;
		},

		_catchTransitionEnd: function (e) {
			if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
				this._onZoomTransitionEnd();
			}
		},

		_nothingToAnimate: function () {
			return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
		},

		_tryAnimatedZoom: function (center, zoom, options) {

			if (this._animatingZoom) { return true; }

			options = options || {};

			// don't animate if disabled, not supported or zoom difference is too large
			if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
			        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

			// offset is the pixel coords of the zoom origin relative to the current center
			var scale = this.getZoomScale(zoom),
			    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

			// don't animate if the zoom origin isn't within one screen from the current center, unless forced
			if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

			requestAnimFrame(function () {
				this
				    ._moveStart(true, false)
				    ._animateZoom(center, zoom, true);
			}, this);

			return true;
		},

		_animateZoom: function (center, zoom, startAnim, noUpdate) {
			if (!this._mapPane) { return; }

			if (startAnim) {
				this._animatingZoom = true;

				// remember what center/zoom to set after animation
				this._animateToCenter = center;
				this._animateToZoom = zoom;

				addClass(this._mapPane, 'leaflet-zoom-anim');
			}

			// @event zoomanim: ZoomAnimEvent
			// Fired at least once per zoom animation. For continous zoom, like pinch zooming, fired once per frame during zoom.
			this.fire('zoomanim', {
				center: center,
				zoom: zoom,
				noUpdate: noUpdate
			});

			// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
			setTimeout(bind(this._onZoomTransitionEnd, this), 250);
		},

		_onZoomTransitionEnd: function () {
			if (!this._animatingZoom) { return; }

			if (this._mapPane) {
				removeClass(this._mapPane, 'leaflet-zoom-anim');
			}

			this._animatingZoom = false;

			this._move(this._animateToCenter, this._animateToZoom);

			// This anim frame should prevent an obscure iOS webkit tile loading race condition.
			requestAnimFrame(function () {
				this._moveEnd(true);
			}, this);
		}
	});

	// @section

	// @factory L.map(id: String, options?: Map options)
	// Instantiates a map object given the DOM ID of a `<div>` element
	// and optionally an object literal with `Map options`.
	//
	// @alternative
	// @factory L.map(el: HTMLElement, options?: Map options)
	// Instantiates a map object given an instance of a `<div>` HTML element
	// and optionally an object literal with `Map options`.
	function createMap(id, options) {
		return new Map(id, options);
	}

	/*
	 * @class Control
	 * @aka L.Control
	 * @inherits Class
	 *
	 * L.Control is a base class for implementing map controls. Handles positioning.
	 * All other controls extend from this class.
	 */

	var Control = Class.extend({
		// @section
		// @aka Control options
		options: {
			// @option position: String = 'topright'
			// The position of the control (one of the map corners). Possible values are `'topleft'`,
			// `'topright'`, `'bottomleft'` or `'bottomright'`
			position: 'topright'
		},

		initialize: function (options) {
			setOptions(this, options);
		},

		/* @section
		 * Classes extending L.Control will inherit the following methods:
		 *
		 * @method getPosition: string
		 * Returns the position of the control.
		 */
		getPosition: function () {
			return this.options.position;
		},

		// @method setPosition(position: string): this
		// Sets the position of the control.
		setPosition: function (position) {
			var map = this._map;

			if (map) {
				map.removeControl(this);
			}

			this.options.position = position;

			if (map) {
				map.addControl(this);
			}

			return this;
		},

		// @method getContainer: HTMLElement
		// Returns the HTMLElement that contains the control.
		getContainer: function () {
			return this._container;
		},

		// @method addTo(map: Map): this
		// Adds the control to the given map.
		addTo: function (map) {
			this.remove();
			this._map = map;

			var container = this._container = this.onAdd(map),
			    pos = this.getPosition(),
			    corner = map._controlCorners[pos];

			addClass(container, 'leaflet-control');

			if (pos.indexOf('bottom') !== -1) {
				corner.insertBefore(container, corner.firstChild);
			} else {
				corner.appendChild(container);
			}

			return this;
		},

		// @method remove: this
		// Removes the control from the map it is currently active on.
		remove: function () {
			if (!this._map) {
				return this;
			}

			remove(this._container);

			if (this.onRemove) {
				this.onRemove(this._map);
			}

			this._map = null;

			return this;
		},

		_refocusOnMap: function (e) {
			// if map exists and event is not a keyboard event
			if (this._map && e && e.screenX > 0 && e.screenY > 0) {
				this._map.getContainer().focus();
			}
		}
	});

	var control = function (options) {
		return new Control(options);
	};

	/* @section Extension methods
	 * @uninheritable
	 *
	 * Every control should extend from `L.Control` and (re-)implement the following methods.
	 *
	 * @method onAdd(map: Map): HTMLElement
	 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
	 *
	 * @method onRemove(map: Map)
	 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
	 */

	/* @namespace Map
	 * @section Methods for Layers and Controls
	 */
	Map.include({
		// @method addControl(control: Control): this
		// Adds the given control to the map
		addControl: function (control) {
			control.addTo(this);
			return this;
		},

		// @method removeControl(control: Control): this
		// Removes the given control from the map
		removeControl: function (control) {
			control.remove();
			return this;
		},

		_initControlPos: function () {
			var corners = this._controlCorners = {},
			    l = 'leaflet-',
			    container = this._controlContainer =
			            create$1('div', l + 'control-container', this._container);

			function createCorner(vSide, hSide) {
				var className = l + vSide + ' ' + l + hSide;

				corners[vSide + hSide] = create$1('div', className, container);
			}

			createCorner('top', 'left');
			createCorner('top', 'right');
			createCorner('bottom', 'left');
			createCorner('bottom', 'right');
		},

		_clearControlPos: function () {
			for (var i in this._controlCorners) {
				remove(this._controlCorners[i]);
			}
			remove(this._controlContainer);
			delete this._controlCorners;
			delete this._controlContainer;
		}
	});

	/*
	 * @class Control.Layers
	 * @aka L.Control.Layers
	 * @inherits Control
	 *
	 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
	 *
	 * @example
	 *
	 * ```js
	 * var baseLayers = {
	 * 	"Mapbox": mapbox,
	 * 	"OpenStreetMap": osm
	 * };
	 *
	 * var overlays = {
	 * 	"Marker": marker,
	 * 	"Roads": roadsLayer
	 * };
	 *
	 * L.control.layers(baseLayers, overlays).addTo(map);
	 * ```
	 *
	 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
	 *
	 * ```js
	 * {
	 *     "<someName1>": layer1,
	 *     "<someName2>": layer2
	 * }
	 * ```
	 *
	 * The layer names can contain HTML, which allows you to add additional styling to the items:
	 *
	 * ```js
	 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
	 * ```
	 */

	var Layers = Control.extend({
		// @section
		// @aka Control.Layers options
		options: {
			// @option collapsed: Boolean = true
			// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
			collapsed: true,
			position: 'topright',

			// @option autoZIndex: Boolean = true
			// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
			autoZIndex: true,

			// @option hideSingleBase: Boolean = false
			// If `true`, the base layers in the control will be hidden when there is only one.
			hideSingleBase: false,

			// @option sortLayers: Boolean = false
			// Whether to sort the layers. When `false`, layers will keep the order
			// in which they were added to the control.
			sortLayers: false,

			// @option sortFunction: Function = *
			// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
			// that will be used for sorting the layers, when `sortLayers` is `true`.
			// The function receives both the `L.Layer` instances and their names, as in
			// `sortFunction(layerA, layerB, nameA, nameB)`.
			// By default, it sorts layers alphabetically by their name.
			sortFunction: function (layerA, layerB, nameA, nameB) {
				return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
			}
		},

		initialize: function (baseLayers, overlays, options) {
			setOptions(this, options);

			this._layerControlInputs = [];
			this._layers = [];
			this._lastZIndex = 0;
			this._handlingClick = false;

			for (var i in baseLayers) {
				this._addLayer(baseLayers[i], i);
			}

			for (i in overlays) {
				this._addLayer(overlays[i], i, true);
			}
		},

		onAdd: function (map) {
			this._initLayout();
			this._update();

			this._map = map;
			map.on('zoomend', this._checkDisabledLayers, this);

			for (var i = 0; i < this._layers.length; i++) {
				this._layers[i].layer.on('add remove', this._onLayerChange, this);
			}

			return this._container;
		},

		addTo: function (map) {
			Control.prototype.addTo.call(this, map);
			// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
			return this._expandIfNotCollapsed();
		},

		onRemove: function () {
			this._map.off('zoomend', this._checkDisabledLayers, this);

			for (var i = 0; i < this._layers.length; i++) {
				this._layers[i].layer.off('add remove', this._onLayerChange, this);
			}
		},

		// @method addBaseLayer(layer: Layer, name: String): this
		// Adds a base layer (radio button entry) with the given name to the control.
		addBaseLayer: function (layer, name) {
			this._addLayer(layer, name);
			return (this._map) ? this._update() : this;
		},

		// @method addOverlay(layer: Layer, name: String): this
		// Adds an overlay (checkbox entry) with the given name to the control.
		addOverlay: function (layer, name) {
			this._addLayer(layer, name, true);
			return (this._map) ? this._update() : this;
		},

		// @method removeLayer(layer: Layer): this
		// Remove the given layer from the control.
		removeLayer: function (layer) {
			layer.off('add remove', this._onLayerChange, this);

			var obj = this._getLayer(stamp(layer));
			if (obj) {
				this._layers.splice(this._layers.indexOf(obj), 1);
			}
			return (this._map) ? this._update() : this;
		},

		// @method expand(): this
		// Expand the control container if collapsed.
		expand: function () {
			addClass(this._container, 'leaflet-control-layers-expanded');
			this._section.style.height = null;
			var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
			if (acceptableHeight < this._section.clientHeight) {
				addClass(this._section, 'leaflet-control-layers-scrollbar');
				this._section.style.height = acceptableHeight + 'px';
			} else {
				removeClass(this._section, 'leaflet-control-layers-scrollbar');
			}
			this._checkDisabledLayers();
			return this;
		},

		// @method collapse(): this
		// Collapse the control container if expanded.
		collapse: function () {
			removeClass(this._container, 'leaflet-control-layers-expanded');
			return this;
		},

		_initLayout: function () {
			var className = 'leaflet-control-layers',
			    container = this._container = create$1('div', className),
			    collapsed = this.options.collapsed;

			// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
			container.setAttribute('aria-haspopup', true);

			disableClickPropagation(container);
			disableScrollPropagation(container);

			var section = this._section = create$1('section', className + '-list');

			if (collapsed) {
				this._map.on('click', this.collapse, this);

				if (!android) {
					on(container, {
						mouseenter: this.expand,
						mouseleave: this.collapse
					}, this);
				}
			}

			var link = this._layersLink = create$1('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (touch) {
				on(link, 'click', stop);
				on(link, 'click', this.expand, this);
			} else {
				on(link, 'focus', this.expand, this);
			}

			if (!collapsed) {
				this.expand();
			}

			this._baseLayersList = create$1('div', className + '-base', section);
			this._separator = create$1('div', className + '-separator', section);
			this._overlaysList = create$1('div', className + '-overlays', section);

			container.appendChild(section);
		},

		_getLayer: function (id) {
			for (var i = 0; i < this._layers.length; i++) {

				if (this._layers[i] && stamp(this._layers[i].layer) === id) {
					return this._layers[i];
				}
			}
		},

		_addLayer: function (layer, name, overlay) {
			if (this._map) {
				layer.on('add remove', this._onLayerChange, this);
			}

			this._layers.push({
				layer: layer,
				name: name,
				overlay: overlay
			});

			if (this.options.sortLayers) {
				this._layers.sort(bind(function (a, b) {
					return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
				}, this));
			}

			if (this.options.autoZIndex && layer.setZIndex) {
				this._lastZIndex++;
				layer.setZIndex(this._lastZIndex);
			}

			this._expandIfNotCollapsed();
		},

		_update: function () {
			if (!this._container) { return this; }

			empty(this._baseLayersList);
			empty(this._overlaysList);

			this._layerControlInputs = [];
			var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

			for (i = 0; i < this._layers.length; i++) {
				obj = this._layers[i];
				this._addItem(obj);
				overlaysPresent = overlaysPresent || obj.overlay;
				baseLayersPresent = baseLayersPresent || !obj.overlay;
				baseLayersCount += !obj.overlay ? 1 : 0;
			}

			// Hide base layers section if there's only one layer.
			if (this.options.hideSingleBase) {
				baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
				this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
			}

			this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

			return this;
		},

		_onLayerChange: function (e) {
			if (!this._handlingClick) {
				this._update();
			}

			var obj = this._getLayer(stamp(e.target));

			// @namespace Map
			// @section Layer events
			// @event baselayerchange: LayersControlEvent
			// Fired when the base layer is changed through the [layer control](#control-layers).
			// @event overlayadd: LayersControlEvent
			// Fired when an overlay is selected through the [layer control](#control-layers).
			// @event overlayremove: LayersControlEvent
			// Fired when an overlay is deselected through the [layer control](#control-layers).
			// @namespace Control.Layers
			var type = obj.overlay ?
				(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
				(e.type === 'add' ? 'baselayerchange' : null);

			if (type) {
				this._map.fire(type, obj);
			}
		},

		// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
		_createRadioElement: function (name, checked) {

			var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
					name + '"' + (checked ? ' checked="checked"' : '') + '/>';

			var radioFragment = document.createElement('div');
			radioFragment.innerHTML = radioHtml;

			return radioFragment.firstChild;
		},

		_addItem: function (obj) {
			var label = document.createElement('label'),
			    checked = this._map.hasLayer(obj.layer),
			    input;

			if (obj.overlay) {
				input = document.createElement('input');
				input.type = 'checkbox';
				input.className = 'leaflet-control-layers-selector';
				input.defaultChecked = checked;
			} else {
				input = this._createRadioElement('leaflet-base-layers', checked);
			}

			this._layerControlInputs.push(input);
			input.layerId = stamp(obj.layer);

			on(input, 'click', this._onInputClick, this);

			var name = document.createElement('span');
			name.innerHTML = ' ' + obj.name;

			// Helps from preventing layer control flicker when checkboxes are disabled
			// https://github.com/Leaflet/Leaflet/issues/2771
			var holder = document.createElement('div');

			label.appendChild(holder);
			holder.appendChild(input);
			holder.appendChild(name);

			var container = obj.overlay ? this._overlaysList : this._baseLayersList;
			container.appendChild(label);

			this._checkDisabledLayers();
			return label;
		},

		_onInputClick: function () {
			var inputs = this._layerControlInputs,
			    input, layer;
			var addedLayers = [],
			    removedLayers = [];

			this._handlingClick = true;

			for (var i = inputs.length - 1; i >= 0; i--) {
				input = inputs[i];
				layer = this._getLayer(input.layerId).layer;

				if (input.checked) {
					addedLayers.push(layer);
				} else if (!input.checked) {
					removedLayers.push(layer);
				}
			}

			// Bugfix issue 2318: Should remove all old layers before readding new ones
			for (i = 0; i < removedLayers.length; i++) {
				if (this._map.hasLayer(removedLayers[i])) {
					this._map.removeLayer(removedLayers[i]);
				}
			}
			for (i = 0; i < addedLayers.length; i++) {
				if (!this._map.hasLayer(addedLayers[i])) {
					this._map.addLayer(addedLayers[i]);
				}
			}

			this._handlingClick = false;

			this._refocusOnMap();
		},

		_checkDisabledLayers: function () {
			var inputs = this._layerControlInputs,
			    input,
			    layer,
			    zoom = this._map.getZoom();

			for (var i = inputs.length - 1; i >= 0; i--) {
				input = inputs[i];
				layer = this._getLayer(input.layerId).layer;
				input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
				                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

			}
		},

		_expandIfNotCollapsed: function () {
			if (this._map && !this.options.collapsed) {
				this.expand();
			}
			return this;
		},

		_expand: function () {
			// Backward compatibility, remove me in 1.1.
			return this.expand();
		},

		_collapse: function () {
			// Backward compatibility, remove me in 1.1.
			return this.collapse();
		}

	});


	// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
	// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
	var layers = function (baseLayers, overlays, options) {
		return new Layers(baseLayers, overlays, options);
	};

	/*
	 * @class Control.Zoom
	 * @aka L.Control.Zoom
	 * @inherits Control
	 *
	 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
	 */

	var Zoom = Control.extend({
		// @section
		// @aka Control.Zoom options
		options: {
			position: 'topleft',

			// @option zoomInText: String = '+'
			// The text set on the 'zoom in' button.
			zoomInText: '+',

			// @option zoomInTitle: String = 'Zoom in'
			// The title set on the 'zoom in' button.
			zoomInTitle: 'Zoom in',

			// @option zoomOutText: String = '&#x2212;'
			// The text set on the 'zoom out' button.
			zoomOutText: '&#x2212;',

			// @option zoomOutTitle: String = 'Zoom out'
			// The title set on the 'zoom out' button.
			zoomOutTitle: 'Zoom out'
		},

		onAdd: function (map) {
			var zoomName = 'leaflet-control-zoom',
			    container = create$1('div', zoomName + ' leaflet-bar'),
			    options = this.options;

			this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
			        zoomName + '-in',  container, this._zoomIn);
			this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
			        zoomName + '-out', container, this._zoomOut);

			this._updateDisabled();
			map.on('zoomend zoomlevelschange', this._updateDisabled, this);

			return container;
		},

		onRemove: function (map) {
			map.off('zoomend zoomlevelschange', this._updateDisabled, this);
		},

		disable: function () {
			this._disabled = true;
			this._updateDisabled();
			return this;
		},

		enable: function () {
			this._disabled = false;
			this._updateDisabled();
			return this;
		},

		_zoomIn: function (e) {
			if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
				this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
			}
		},

		_zoomOut: function (e) {
			if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
				this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
			}
		},

		_createButton: function (html, title, className, container, fn) {
			var link = create$1('a', className, container);
			link.innerHTML = html;
			link.href = '#';
			link.title = title;

			/*
			 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
			 */
			link.setAttribute('role', 'button');
			link.setAttribute('aria-label', title);

			disableClickPropagation(link);
			on(link, 'click', stop);
			on(link, 'click', fn, this);
			on(link, 'click', this._refocusOnMap, this);

			return link;
		},

		_updateDisabled: function () {
			var map = this._map,
			    className = 'leaflet-disabled';

			removeClass(this._zoomInButton, className);
			removeClass(this._zoomOutButton, className);

			if (this._disabled || map._zoom === map.getMinZoom()) {
				addClass(this._zoomOutButton, className);
			}
			if (this._disabled || map._zoom === map.getMaxZoom()) {
				addClass(this._zoomInButton, className);
			}
		}
	});

	// @namespace Map
	// @section Control options
	// @option zoomControl: Boolean = true
	// Whether a [zoom control](#control-zoom) is added to the map by default.
	Map.mergeOptions({
		zoomControl: true
	});

	Map.addInitHook(function () {
		if (this.options.zoomControl) {
			// @section Controls
			// @property zoomControl: Control.Zoom
			// The default zoom control (only available if the
			// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
			this.zoomControl = new Zoom();
			this.addControl(this.zoomControl);
		}
	});

	// @namespace Control.Zoom
	// @factory L.control.zoom(options: Control.Zoom options)
	// Creates a zoom control
	var zoom = function (options) {
		return new Zoom(options);
	};

	/*
	 * @class Control.Scale
	 * @aka L.Control.Scale
	 * @inherits Control
	 *
	 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
	 *
	 * @example
	 *
	 * ```js
	 * L.control.scale().addTo(map);
	 * ```
	 */

	var Scale = Control.extend({
		// @section
		// @aka Control.Scale options
		options: {
			position: 'bottomleft',

			// @option maxWidth: Number = 100
			// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
			maxWidth: 100,

			// @option metric: Boolean = True
			// Whether to show the metric scale line (m/km).
			metric: true,

			// @option imperial: Boolean = True
			// Whether to show the imperial scale line (mi/ft).
			imperial: true

			// @option updateWhenIdle: Boolean = false
			// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
		},

		onAdd: function (map) {
			var className = 'leaflet-control-scale',
			    container = create$1('div', className),
			    options = this.options;

			this._addScales(options, className + '-line', container);

			map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
			map.whenReady(this._update, this);

			return container;
		},

		onRemove: function (map) {
			map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		},

		_addScales: function (options, className, container) {
			if (options.metric) {
				this._mScale = create$1('div', className, container);
			}
			if (options.imperial) {
				this._iScale = create$1('div', className, container);
			}
		},

		_update: function () {
			var map = this._map,
			    y = map.getSize().y / 2;

			var maxMeters = map.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

			this._updateScales(maxMeters);
		},

		_updateScales: function (maxMeters) {
			if (this.options.metric && maxMeters) {
				this._updateMetric(maxMeters);
			}
			if (this.options.imperial && maxMeters) {
				this._updateImperial(maxMeters);
			}
		},

		_updateMetric: function (maxMeters) {
			var meters = this._getRoundNum(maxMeters),
			    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

			this._updateScale(this._mScale, label, meters / maxMeters);
		},

		_updateImperial: function (maxMeters) {
			var maxFeet = maxMeters * 3.2808399,
			    maxMiles, miles, feet;

			if (maxFeet > 5280) {
				maxMiles = maxFeet / 5280;
				miles = this._getRoundNum(maxMiles);
				this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

			} else {
				feet = this._getRoundNum(maxFeet);
				this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
			}
		},

		_updateScale: function (scale, text, ratio) {
			scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
			scale.innerHTML = text;
		},

		_getRoundNum: function (num) {
			var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
			    d = num / pow10;

			d = d >= 10 ? 10 :
			    d >= 5 ? 5 :
			    d >= 3 ? 3 :
			    d >= 2 ? 2 : 1;

			return pow10 * d;
		}
	});


	// @factory L.control.scale(options?: Control.Scale options)
	// Creates an scale control with the given options.
	var scale = function (options) {
		return new Scale(options);
	};

	/*
	 * @class Control.Attribution
	 * @aka L.Control.Attribution
	 * @inherits Control
	 *
	 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
	 */

	var Attribution = Control.extend({
		// @section
		// @aka Control.Attribution options
		options: {
			position: 'bottomright',

			// @option prefix: String = 'Leaflet'
			// The HTML text shown before the attributions. Pass `false` to disable.
			prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
		},

		initialize: function (options) {
			setOptions(this, options);

			this._attributions = {};
		},

		onAdd: function (map) {
			map.attributionControl = this;
			this._container = create$1('div', 'leaflet-control-attribution');
			disableClickPropagation(this._container);

			// TODO ugly, refactor
			for (var i in map._layers) {
				if (map._layers[i].getAttribution) {
					this.addAttribution(map._layers[i].getAttribution());
				}
			}

			this._update();

			return this._container;
		},

		// @method setPrefix(prefix: String): this
		// Sets the text before the attributions.
		setPrefix: function (prefix) {
			this.options.prefix = prefix;
			this._update();
			return this;
		},

		// @method addAttribution(text: String): this
		// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
		addAttribution: function (text) {
			if (!text) { return this; }

			if (!this._attributions[text]) {
				this._attributions[text] = 0;
			}
			this._attributions[text]++;

			this._update();

			return this;
		},

		// @method removeAttribution(text: String): this
		// Removes an attribution text.
		removeAttribution: function (text) {
			if (!text) { return this; }

			if (this._attributions[text]) {
				this._attributions[text]--;
				this._update();
			}

			return this;
		},

		_update: function () {
			if (!this._map) { return; }

			var attribs = [];

			for (var i in this._attributions) {
				if (this._attributions[i]) {
					attribs.push(i);
				}
			}

			var prefixAndAttribs = [];

			if (this.options.prefix) {
				prefixAndAttribs.push(this.options.prefix);
			}
			if (attribs.length) {
				prefixAndAttribs.push(attribs.join(', '));
			}

			this._container.innerHTML = prefixAndAttribs.join(' | ');
		}
	});

	// @namespace Map
	// @section Control options
	// @option attributionControl: Boolean = true
	// Whether a [attribution control](#control-attribution) is added to the map by default.
	Map.mergeOptions({
		attributionControl: true
	});

	Map.addInitHook(function () {
		if (this.options.attributionControl) {
			new Attribution().addTo(this);
		}
	});

	// @namespace Control.Attribution
	// @factory L.control.attribution(options: Control.Attribution options)
	// Creates an attribution control.
	var attribution = function (options) {
		return new Attribution(options);
	};

	Control.Layers = Layers;
	Control.Zoom = Zoom;
	Control.Scale = Scale;
	Control.Attribution = Attribution;

	control.layers = layers;
	control.zoom = zoom;
	control.scale = scale;
	control.attribution = attribution;

	/*
		L.Handler is a base class for handler classes that are used internally to inject
		interaction features like dragging to classes like Map and Marker.
	*/

	// @class Handler
	// @aka L.Handler
	// Abstract class for map interaction handlers

	var Handler = Class.extend({
		initialize: function (map) {
			this._map = map;
		},

		// @method enable(): this
		// Enables the handler
		enable: function () {
			if (this._enabled) { return this; }

			this._enabled = true;
			this.addHooks();
			return this;
		},

		// @method disable(): this
		// Disables the handler
		disable: function () {
			if (!this._enabled) { return this; }

			this._enabled = false;
			this.removeHooks();
			return this;
		},

		// @method enabled(): Boolean
		// Returns `true` if the handler is enabled
		enabled: function () {
			return !!this._enabled;
		}

		// @section Extension methods
		// Classes inheriting from `Handler` must implement the two following methods:
		// @method addHooks()
		// Called when the handler is enabled, should add event hooks.
		// @method removeHooks()
		// Called when the handler is disabled, should remove the event hooks added previously.
	});

	// @section There is static function which can be called without instantiating L.Handler:
	// @function addTo(map: Map, name: String): this
	// Adds a new Handler to the given map with the given name.
	Handler.addTo = function (map, name) {
		map.addHandler(name, this);
		return this;
	};

	var Mixin = {Events: Events};

	/*
	 * @class Draggable
	 * @aka L.Draggable
	 * @inherits Evented
	 *
	 * A class for making DOM elements draggable (including touch support).
	 * Used internally for map and marker dragging. Only works for elements
	 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
	 *
	 * @example
	 * ```js
	 * var draggable = new L.Draggable(elementToDrag);
	 * draggable.enable();
	 * ```
	 */

	var START = touch ? 'touchstart mousedown' : 'mousedown';
	var END = {
		mousedown: 'mouseup',
		touchstart: 'touchend',
		pointerdown: 'touchend',
		MSPointerDown: 'touchend'
	};
	var MOVE = {
		mousedown: 'mousemove',
		touchstart: 'touchmove',
		pointerdown: 'touchmove',
		MSPointerDown: 'touchmove'
	};


	var Draggable = Evented.extend({

		options: {
			// @section
			// @aka Draggable options
			// @option clickTolerance: Number = 3
			// The max number of pixels a user can shift the mouse pointer during a click
			// for it to be considered a valid click (as opposed to a mouse drag).
			clickTolerance: 3
		},

		// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
		// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
		initialize: function (element, dragStartTarget, preventOutline$$1, options) {
			setOptions(this, options);

			this._element = element;
			this._dragStartTarget = dragStartTarget || element;
			this._preventOutline = preventOutline$$1;
		},

		// @method enable()
		// Enables the dragging ability
		enable: function () {
			if (this._enabled) { return; }

			on(this._dragStartTarget, START, this._onDown, this);

			this._enabled = true;
		},

		// @method disable()
		// Disables the dragging ability
		disable: function () {
			if (!this._enabled) { return; }

			// If we're currently dragging this draggable,
			// disabling it counts as first ending the drag.
			if (Draggable._dragging === this) {
				this.finishDrag();
			}

			off(this._dragStartTarget, START, this._onDown, this);

			this._enabled = false;
			this._moved = false;
		},

		_onDown: function (e) {
			// Ignore simulated events, since we handle both touch and
			// mouse explicitly; otherwise we risk getting duplicates of
			// touch events, see #4315.
			// Also ignore the event if disabled; this happens in IE11
			// under some circumstances, see #3666.
			if (e._simulated || !this._enabled) { return; }

			this._moved = false;

			if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

			if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
			Draggable._dragging = this;  // Prevent dragging multiple objects at once.

			if (this._preventOutline) {
				preventOutline(this._element);
			}

			disableImageDrag();
			disableTextSelection();

			if (this._moving) { return; }

			// @event down: Event
			// Fired when a drag is about to start.
			this.fire('down');

			var first = e.touches ? e.touches[0] : e,
			    sizedParent = getSizedParentNode(this._element);

			this._startPoint = new Point(first.clientX, first.clientY);

			// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
			this._parentScale = getScale(sizedParent);

			on(document, MOVE[e.type], this._onMove, this);
			on(document, END[e.type], this._onUp, this);
		},

		_onMove: function (e) {
			// Ignore simulated events, since we handle both touch and
			// mouse explicitly; otherwise we risk getting duplicates of
			// touch events, see #4315.
			// Also ignore the event if disabled; this happens in IE11
			// under some circumstances, see #3666.
			if (e._simulated || !this._enabled) { return; }

			if (e.touches && e.touches.length > 1) {
				this._moved = true;
				return;
			}

			var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
			    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

			if (!offset.x && !offset.y) { return; }
			if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

			// We assume that the parent container's position, border and scale do not change for the duration of the drag.
			// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
			// and we can use the cached value for the scale.
			offset.x /= this._parentScale.x;
			offset.y /= this._parentScale.y;

			preventDefault(e);

			if (!this._moved) {
				// @event dragstart: Event
				// Fired when a drag starts
				this.fire('dragstart');

				this._moved = true;
				this._startPos = getPosition(this._element).subtract(offset);

				addClass(document.body, 'leaflet-dragging');

				this._lastTarget = e.target || e.srcElement;
				// IE and Edge do not give the <use> element, so fetch it
				// if necessary
				if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
					this._lastTarget = this._lastTarget.correspondingUseElement;
				}
				addClass(this._lastTarget, 'leaflet-drag-target');
			}

			this._newPos = this._startPos.add(offset);
			this._moving = true;

			cancelAnimFrame(this._animRequest);
			this._lastEvent = e;
			this._animRequest = requestAnimFrame(this._updatePosition, this, true);
		},

		_updatePosition: function () {
			var e = {originalEvent: this._lastEvent};

			// @event predrag: Event
			// Fired continuously during dragging *before* each corresponding
			// update of the element's position.
			this.fire('predrag', e);
			setPosition(this._element, this._newPos);

			// @event drag: Event
			// Fired continuously during dragging.
			this.fire('drag', e);
		},

		_onUp: function (e) {
			// Ignore simulated events, since we handle both touch and
			// mouse explicitly; otherwise we risk getting duplicates of
			// touch events, see #4315.
			// Also ignore the event if disabled; this happens in IE11
			// under some circumstances, see #3666.
			if (e._simulated || !this._enabled) { return; }
			this.finishDrag();
		},

		finishDrag: function () {
			removeClass(document.body, 'leaflet-dragging');

			if (this._lastTarget) {
				removeClass(this._lastTarget, 'leaflet-drag-target');
				this._lastTarget = null;
			}

			for (var i in MOVE) {
				off(document, MOVE[i], this._onMove, this);
				off(document, END[i], this._onUp, this);
			}

			enableImageDrag();
			enableTextSelection();

			if (this._moved && this._moving) {
				// ensure drag is not fired after dragend
				cancelAnimFrame(this._animRequest);

				// @event dragend: DragEndEvent
				// Fired when the drag ends.
				this.fire('dragend', {
					distance: this._newPos.distanceTo(this._startPos)
				});
			}

			this._moving = false;
			Draggable._dragging = false;
		}

	});

	/*
	 * @namespace LineUtil
	 *
	 * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
	 */

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	// @function simplify(points: Point[], tolerance: Number): Point[]
	// Dramatically reduces the number of points in a polyline while retaining
	// its shape and returns a new array of simplified points, using the
	// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
	// Used for a huge performance boost when processing/displaying Leaflet polylines for
	// each zoom level and also reducing visual noise. tolerance affects the amount of
	// simplification (lesser value means higher quality but slower and with more points).
	// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
	function simplify(points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		    // stage 1: vertex reduction
		    points = _reducePoints(points, sqTolerance);

		    // stage 2: Douglas-Peucker simplification
		    points = _simplifyDP(points, sqTolerance);

		return points;
	}

	// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
	// Returns the distance between point `p` and segment `p1` to `p2`.
	function pointToSegmentDistance(p, p1, p2) {
		return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
	}

	// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
	// Returns the closest point from a point `p` on a segment `p1` to `p2`.
	function closestPointOnSegment(p, p1, p2) {
		return _sqClosestPointOnSegment(p, p1, p2);
	}

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	function _simplifyDP(points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		    markers[0] = markers[len - 1] = 1;

		_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	}

	function _simplifyDPStep(points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			_simplifyDPStep(points, markers, sqTolerance, first, index);
			_simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	}

	// reduce points that are too close to each other to a single point
	function _reducePoints(points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (_sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	}

	var _lastCode;

	// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
	// Clips the segment a to b by rectangular bounds with the
	// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
	// (modifying the segment points directly!). Used by Leaflet to only show polyline
	// points that are on the screen or near, increasing performance.
	function clipSegment(a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
		    codeB = _getBitCode(b, bounds),

		    codeOut, p, newCode;

		    // save 2nd code to avoid calculating it on the next segment
		    _lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			}

			// if a,b is outside the clip window (trivial reject)
			if (codeA & codeB) {
				return false;
			}

			// other cases
			codeOut = codeA || codeB;
			p = _getEdgeIntersection(a, b, codeOut, bounds, round);
			newCode = _getBitCode(p, bounds);

			if (codeOut === codeA) {
				a = p;
				codeA = newCode;
			} else {
				b = p;
				codeB = newCode;
			}
		}
	}

	function _getEdgeIntersection(a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new Point(x, y, round);
	}

	function _getBitCode(p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	}

	// square distance (to avoid unnecessary Math.sqrt calls)
	function _sqDist(p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	}

	// return closest point on segment or distance to that point
	function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new Point(x, y);
	}


	// @function isFlat(latlngs: LatLng[]): Boolean
	// Returns true if `latlngs` is a flat array, false is nested.
	function isFlat(latlngs) {
		return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
	}

	function _flat(latlngs) {
		console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
		return isFlat(latlngs);
	}


	var LineUtil = (Object.freeze || Object)({
		simplify: simplify,
		pointToSegmentDistance: pointToSegmentDistance,
		closestPointOnSegment: closestPointOnSegment,
		clipSegment: clipSegment,
		_getEdgeIntersection: _getEdgeIntersection,
		_getBitCode: _getBitCode,
		_sqClosestPointOnSegment: _sqClosestPointOnSegment,
		isFlat: isFlat,
		_flat: _flat
	});

	/*
	 * @namespace PolyUtil
	 * Various utility functions for polygon geometries.
	 */

	/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
	 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
	 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
	 * performance. Note that polygon points needs different algorithm for clipping
	 * than polyline, so there's a separate method for it.
	 */
	function clipPolygon(points, bounds, round) {
		var clippedPoints,
		    edges = [1, 4, 2, 8],
		    i, j, k,
		    a, b,
		    len, edge, p;

		for (i = 0, len = points.length; i < len; i++) {
			points[i]._code = _getBitCode(points[i], bounds);
		}

		// for each edge (left, bottom, right, top)
		for (k = 0; k < 4; k++) {
			edge = edges[k];
			clippedPoints = [];

			for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
				a = points[i];
				b = points[j];

				// if a is inside the clip window
				if (!(a._code & edge)) {
					// if b is outside the clip window (a->b goes out of screen)
					if (b._code & edge) {
						p = _getEdgeIntersection(b, a, edge, bounds, round);
						p._code = _getBitCode(p, bounds);
						clippedPoints.push(p);
					}
					clippedPoints.push(a);

				// else if b is inside the clip window (a->b enters the screen)
				} else if (!(b._code & edge)) {
					p = _getEdgeIntersection(b, a, edge, bounds, round);
					p._code = _getBitCode(p, bounds);
					clippedPoints.push(p);
				}
			}
			points = clippedPoints;
		}

		return points;
	}


	var PolyUtil = (Object.freeze || Object)({
		clipPolygon: clipPolygon
	});

	/*
	 * @namespace Projection
	 * @section
	 * Leaflet comes with a set of already defined Projections out of the box:
	 *
	 * @projection L.Projection.LonLat
	 *
	 * Equirectangular, or Plate Carree projection — the most simple projection,
	 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
	 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
	 * `EPSG:4326` and `Simple` CRS.
	 */

	var LonLat = {
		project: function (latlng) {
			return new Point(latlng.lng, latlng.lat);
		},

		unproject: function (point) {
			return new LatLng(point.y, point.x);
		},

		bounds: new Bounds([-180, -90], [180, 90])
	};

	/*
	 * @namespace Projection
	 * @projection L.Projection.Mercator
	 *
	 * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
	 */

	var Mercator = {
		R: 6378137,
		R_MINOR: 6356752.314245179,

		bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

		project: function (latlng) {
			var d = Math.PI / 180,
			    r = this.R,
			    y = latlng.lat * d,
			    tmp = this.R_MINOR / r,
			    e = Math.sqrt(1 - tmp * tmp),
			    con = e * Math.sin(y);

			var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
			y = -r * Math.log(Math.max(ts, 1E-10));

			return new Point(latlng.lng * d * r, y);
		},

		unproject: function (point) {
			var d = 180 / Math.PI,
			    r = this.R,
			    tmp = this.R_MINOR / r,
			    e = Math.sqrt(1 - tmp * tmp),
			    ts = Math.exp(-point.y / r),
			    phi = Math.PI / 2 - 2 * Math.atan(ts);

			for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
				con = e * Math.sin(phi);
				con = Math.pow((1 - con) / (1 + con), e / 2);
				dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
				phi += dphi;
			}

			return new LatLng(phi * d, point.x * d / r);
		}
	};

	/*
	 * @class Projection

	 * An object with methods for projecting geographical coordinates of the world onto
	 * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

	 * @property bounds: Bounds
	 * The bounds (specified in CRS units) where the projection is valid

	 * @method project(latlng: LatLng): Point
	 * Projects geographical coordinates into a 2D point.
	 * Only accepts actual `L.LatLng` instances, not arrays.

	 * @method unproject(point: Point): LatLng
	 * The inverse of `project`. Projects a 2D point into a geographical location.
	 * Only accepts actual `L.Point` instances, not arrays.

	 * Note that the projection instances do not inherit from Leafet's `Class` object,
	 * and can't be instantiated. Also, new classes can't inherit from them,
	 * and methods can't be added to them with the `include` function.

	 */




	var index = (Object.freeze || Object)({
		LonLat: LonLat,
		Mercator: Mercator,
		SphericalMercator: SphericalMercator
	});

	/*
	 * @namespace CRS
	 * @crs L.CRS.EPSG3395
	 *
	 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
	 */
	var EPSG3395 = extend({}, Earth, {
		code: 'EPSG:3395',
		projection: Mercator,

		transformation: (function () {
			var scale = 0.5 / (Math.PI * Mercator.R);
			return toTransformation(scale, 0.5, -scale, 0.5);
		}())
	});

	/*
	 * @namespace CRS
	 * @crs L.CRS.EPSG4326
	 *
	 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
	 *
	 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
	 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
	 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
	 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
	 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
	 */

	var EPSG4326 = extend({}, Earth, {
		code: 'EPSG:4326',
		projection: LonLat,
		transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
	});

	/*
	 * @namespace CRS
	 * @crs L.CRS.Simple
	 *
	 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
	 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
	 * axis should still be inverted (going from bottom to top). `distance()` returns
	 * simple euclidean distance.
	 */

	var Simple = extend({}, CRS, {
		projection: LonLat,
		transformation: toTransformation(1, 0, -1, 0),

		scale: function (zoom) {
			return Math.pow(2, zoom);
		},

		zoom: function (scale) {
			return Math.log(scale) / Math.LN2;
		},

		distance: function (latlng1, latlng2) {
			var dx = latlng2.lng - latlng1.lng,
			    dy = latlng2.lat - latlng1.lat;

			return Math.sqrt(dx * dx + dy * dy);
		},

		infinite: true
	});

	CRS.Earth = Earth;
	CRS.EPSG3395 = EPSG3395;
	CRS.EPSG3857 = EPSG3857;
	CRS.EPSG900913 = EPSG900913;
	CRS.EPSG4326 = EPSG4326;
	CRS.Simple = Simple;

	/*
	 * @class Layer
	 * @inherits Evented
	 * @aka L.Layer
	 * @aka ILayer
	 *
	 * A set of methods from the Layer base class that all Leaflet layers use.
	 * Inherits all methods, options and events from `L.Evented`.
	 *
	 * @example
	 *
	 * ```js
	 * var layer = L.Marker(latlng).addTo(map);
	 * layer.addTo(map);
	 * layer.remove();
	 * ```
	 *
	 * @event add: Event
	 * Fired after the layer is added to a map
	 *
	 * @event remove: Event
	 * Fired after the layer is removed from a map
	 */


	var Layer = Evented.extend({

		// Classes extending `L.Layer` will inherit the following options:
		options: {
			// @option pane: String = 'overlayPane'
			// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
			pane: 'overlayPane',

			// @option attribution: String = null
			// String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
			attribution: null,

			bubblingMouseEvents: true
		},

		/* @section
		 * Classes extending `L.Layer` will inherit the following methods:
		 *
		 * @method addTo(map: Map|LayerGroup): this
		 * Adds the layer to the given map or layer group.
		 */
		addTo: function (map) {
			map.addLayer(this);
			return this;
		},

		// @method remove: this
		// Removes the layer from the map it is currently active on.
		remove: function () {
			return this.removeFrom(this._map || this._mapToAdd);
		},

		// @method removeFrom(map: Map): this
		// Removes the layer from the given map
		removeFrom: function (obj) {
			if (obj) {
				obj.removeLayer(this);
			}
			return this;
		},

		// @method getPane(name? : String): HTMLElement
		// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
		getPane: function (name) {
			return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
		},

		addInteractiveTarget: function (targetEl) {
			this._map._targets[stamp(targetEl)] = this;
			return this;
		},

		removeInteractiveTarget: function (targetEl) {
			delete this._map._targets[stamp(targetEl)];
			return this;
		},

		// @method getAttribution: String
		// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
		getAttribution: function () {
			return this.options.attribution;
		},

		_layerAdd: function (e) {
			var map = e.target;

			// check in case layer gets added and then removed before the map is ready
			if (!map.hasLayer(this)) { return; }

			this._map = map;
			this._zoomAnimated = map._zoomAnimated;

			if (this.getEvents) {
				var events = this.getEvents();
				map.on(events, this);
				this.once('remove', function () {
					map.off(events, this);
				}, this);
			}

			this.onAdd(map);

			if (this.getAttribution && map.attributionControl) {
				map.attributionControl.addAttribution(this.getAttribution());
			}

			this.fire('add');
			map.fire('layeradd', {layer: this});
		}
	});

	/* @section Extension methods
	 * @uninheritable
	 *
	 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
	 *
	 * @method onAdd(map: Map): this
	 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
	 *
	 * @method onRemove(map: Map): this
	 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
	 *
	 * @method getEvents(): Object
	 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
	 *
	 * @method getAttribution(): String
	 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
	 *
	 * @method beforeAdd(map: Map): this
	 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
	 */


	/* @namespace Map
	 * @section Layer events
	 *
	 * @event layeradd: LayerEvent
	 * Fired when a new layer is added to the map.
	 *
	 * @event layerremove: LayerEvent
	 * Fired when some layer is removed from the map
	 *
	 * @section Methods for Layers and Controls
	 */
	Map.include({
		// @method addLayer(layer: Layer): this
		// Adds the given layer to the map
		addLayer: function (layer) {
			if (!layer._layerAdd) {
				throw new Error('The provided object is not a Layer.');
			}

			var id = stamp(layer);
			if (this._layers[id]) { return this; }
			this._layers[id] = layer;

			layer._mapToAdd = this;

			if (layer.beforeAdd) {
				layer.beforeAdd(this);
			}

			this.whenReady(layer._layerAdd, layer);

			return this;
		},

		// @method removeLayer(layer: Layer): this
		// Removes the given layer from the map.
		removeLayer: function (layer) {
			var id = stamp(layer);

			if (!this._layers[id]) { return this; }

			if (this._loaded) {
				layer.onRemove(this);
			}

			if (layer.getAttribution && this.attributionControl) {
				this.attributionControl.removeAttribution(layer.getAttribution());
			}

			delete this._layers[id];

			if (this._loaded) {
				this.fire('layerremove', {layer: layer});
				layer.fire('remove');
			}

			layer._map = layer._mapToAdd = null;

			return this;
		},

		// @method hasLayer(layer: Layer): Boolean
		// Returns `true` if the given layer is currently added to the map
		hasLayer: function (layer) {
			return !!layer && (stamp(layer) in this._layers);
		},

		/* @method eachLayer(fn: Function, context?: Object): this
		 * Iterates over the layers of the map, optionally specifying context of the iterator function.
		 * ```
		 * map.eachLayer(function(layer){
		 *     layer.bindPopup('Hello');
		 * });
		 * ```
		 */
		eachLayer: function (method, context) {
			for (var i in this._layers) {
				method.call(context, this._layers[i]);
			}
			return this;
		},

		_addLayers: function (layers) {
			layers = layers ? (isArray(layers) ? layers : [layers]) : [];

			for (var i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		},

		_addZoomLimit: function (layer) {
			if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
				this._zoomBoundLayers[stamp(layer)] = layer;
				this._updateZoomLevels();
			}
		},

		_removeZoomLimit: function (layer) {
			var id = stamp(layer);

			if (this._zoomBoundLayers[id]) {
				delete this._zoomBoundLayers[id];
				this._updateZoomLevels();
			}
		},

		_updateZoomLevels: function () {
			var minZoom = Infinity,
			    maxZoom = -Infinity,
			    oldZoomSpan = this._getZoomSpan();

			for (var i in this._zoomBoundLayers) {
				var options = this._zoomBoundLayers[i].options;

				minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
				maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
			}

			this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
			this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

			// @section Map state change events
			// @event zoomlevelschange: Event
			// Fired when the number of zoomlevels on the map is changed due
			// to adding or removing a layer.
			if (oldZoomSpan !== this._getZoomSpan()) {
				this.fire('zoomlevelschange');
			}

			if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
				this.setZoom(this._layersMaxZoom);
			}
			if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
				this.setZoom(this._layersMinZoom);
			}
		}
	});

	/*
	 * @class LayerGroup
	 * @aka L.LayerGroup
	 * @inherits Layer
	 *
	 * Used to group several layers and handle them as one. If you add it to the map,
	 * any layers added or removed from the group will be added/removed on the map as
	 * well. Extends `Layer`.
	 *
	 * @example
	 *
	 * ```js
	 * L.layerGroup([marker1, marker2])
	 * 	.addLayer(polyline)
	 * 	.addTo(map);
	 * ```
	 */

	var LayerGroup = Layer.extend({

		initialize: function (layers, options) {
			setOptions(this, options);

			this._layers = {};

			var i, len;

			if (layers) {
				for (i = 0, len = layers.length; i < len; i++) {
					this.addLayer(layers[i]);
				}
			}
		},

		// @method addLayer(layer: Layer): this
		// Adds the given layer to the group.
		addLayer: function (layer) {
			var id = this.getLayerId(layer);

			this._layers[id] = layer;

			if (this._map) {
				this._map.addLayer(layer);
			}

			return this;
		},

		// @method removeLayer(layer: Layer): this
		// Removes the given layer from the group.
		// @alternative
		// @method removeLayer(id: Number): this
		// Removes the layer with the given internal ID from the group.
		removeLayer: function (layer) {
			var id = layer in this._layers ? layer : this.getLayerId(layer);

			if (this._map && this._layers[id]) {
				this._map.removeLayer(this._layers[id]);
			}

			delete this._layers[id];

			return this;
		},

		// @method hasLayer(layer: Layer): Boolean
		// Returns `true` if the given layer is currently added to the group.
		// @alternative
		// @method hasLayer(id: Number): Boolean
		// Returns `true` if the given internal ID is currently added to the group.
		hasLayer: function (layer) {
			return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
		},

		// @method clearLayers(): this
		// Removes all the layers from the group.
		clearLayers: function () {
			return this.eachLayer(this.removeLayer, this);
		},

		// @method invoke(methodName: String, …): this
		// Calls `methodName` on every layer contained in this group, passing any
		// additional parameters. Has no effect if the layers contained do not
		// implement `methodName`.
		invoke: function (methodName) {
			var args = Array.prototype.slice.call(arguments, 1),
			    i, layer;

			for (i in this._layers) {
				layer = this._layers[i];

				if (layer[methodName]) {
					layer[methodName].apply(layer, args);
				}
			}

			return this;
		},

		onAdd: function (map) {
			this.eachLayer(map.addLayer, map);
		},

		onRemove: function (map) {
			this.eachLayer(map.removeLayer, map);
		},

		// @method eachLayer(fn: Function, context?: Object): this
		// Iterates over the layers of the group, optionally specifying context of the iterator function.
		// ```js
		// group.eachLayer(function (layer) {
		// 	layer.bindPopup('Hello');
		// });
		// ```
		eachLayer: function (method, context) {
			for (var i in this._layers) {
				method.call(context, this._layers[i]);
			}
			return this;
		},

		// @method getLayer(id: Number): Layer
		// Returns the layer with the given internal ID.
		getLayer: function (id) {
			return this._layers[id];
		},

		// @method getLayers(): Layer[]
		// Returns an array of all the layers added to the group.
		getLayers: function () {
			var layers = [];
			this.eachLayer(layers.push, layers);
			return layers;
		},

		// @method setZIndex(zIndex: Number): this
		// Calls `setZIndex` on every layer contained in this group, passing the z-index.
		setZIndex: function (zIndex) {
			return this.invoke('setZIndex', zIndex);
		},

		// @method getLayerId(layer: Layer): Number
		// Returns the internal ID for a layer
		getLayerId: function (layer) {
			return stamp(layer);
		}
	});


	// @factory L.layerGroup(layers?: Layer[], options?: Object)
	// Create a layer group, optionally given an initial set of layers and an `options` object.
	var layerGroup = function (layers, options) {
		return new LayerGroup(layers, options);
	};

	/*
	 * @class FeatureGroup
	 * @aka L.FeatureGroup
	 * @inherits LayerGroup
	 *
	 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
	 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
	 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
	 * handler, it will handle events from any of the layers. This includes mouse events
	 * and custom events.
	 *  * Has `layeradd` and `layerremove` events
	 *
	 * @example
	 *
	 * ```js
	 * L.featureGroup([marker1, marker2, polyline])
	 * 	.bindPopup('Hello world!')
	 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
	 * 	.addTo(map);
	 * ```
	 */

	var FeatureGroup = LayerGroup.extend({

		addLayer: function (layer) {
			if (this.hasLayer(layer)) {
				return this;
			}

			layer.addEventParent(this);

			LayerGroup.prototype.addLayer.call(this, layer);

			// @event layeradd: LayerEvent
			// Fired when a layer is added to this `FeatureGroup`
			return this.fire('layeradd', {layer: layer});
		},

		removeLayer: function (layer) {
			if (!this.hasLayer(layer)) {
				return this;
			}
			if (layer in this._layers) {
				layer = this._layers[layer];
			}

			layer.removeEventParent(this);

			LayerGroup.prototype.removeLayer.call(this, layer);

			// @event layerremove: LayerEvent
			// Fired when a layer is removed from this `FeatureGroup`
			return this.fire('layerremove', {layer: layer});
		},

		// @method setStyle(style: Path options): this
		// Sets the given path options to each layer of the group that has a `setStyle` method.
		setStyle: function (style) {
			return this.invoke('setStyle', style);
		},

		// @method bringToFront(): this
		// Brings the layer group to the top of all other layers
		bringToFront: function () {
			return this.invoke('bringToFront');
		},

		// @method bringToBack(): this
		// Brings the layer group to the back of all other layers
		bringToBack: function () {
			return this.invoke('bringToBack');
		},

		// @method getBounds(): LatLngBounds
		// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
		getBounds: function () {
			var bounds = new LatLngBounds();

			for (var id in this._layers) {
				var layer = this._layers[id];
				bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
			}
			return bounds;
		}
	});

	// @factory L.featureGroup(layers: Layer[])
	// Create a feature group, optionally given an initial set of layers.
	var featureGroup = function (layers) {
		return new FeatureGroup(layers);
	};

	/*
	 * @class Icon
	 * @aka L.Icon
	 *
	 * Represents an icon to provide when creating a marker.
	 *
	 * @example
	 *
	 * ```js
	 * var myIcon = L.icon({
	 *     iconUrl: 'my-icon.png',
	 *     iconRetinaUrl: 'my-icon@2x.png',
	 *     iconSize: [38, 95],
	 *     iconAnchor: [22, 94],
	 *     popupAnchor: [-3, -76],
	 *     shadowUrl: 'my-icon-shadow.png',
	 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
	 *     shadowSize: [68, 95],
	 *     shadowAnchor: [22, 94]
	 * });
	 *
	 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
	 * ```
	 *
	 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
	 *
	 */

	var Icon = Class.extend({

		/* @section
		 * @aka Icon options
		 *
		 * @option iconUrl: String = null
		 * **(required)** The URL to the icon image (absolute or relative to your script path).
		 *
		 * @option iconRetinaUrl: String = null
		 * The URL to a retina sized version of the icon image (absolute or relative to your
		 * script path). Used for Retina screen devices.
		 *
		 * @option iconSize: Point = null
		 * Size of the icon image in pixels.
		 *
		 * @option iconAnchor: Point = null
		 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
		 * will be aligned so that this point is at the marker's geographical location. Centered
		 * by default if size is specified, also can be set in CSS with negative margins.
		 *
		 * @option popupAnchor: Point = [0, 0]
		 * The coordinates of the point from which popups will "open", relative to the icon anchor.
		 *
		 * @option tooltipAnchor: Point = [0, 0]
		 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
		 *
		 * @option shadowUrl: String = null
		 * The URL to the icon shadow image. If not specified, no shadow image will be created.
		 *
		 * @option shadowRetinaUrl: String = null
		 *
		 * @option shadowSize: Point = null
		 * Size of the shadow image in pixels.
		 *
		 * @option shadowAnchor: Point = null
		 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
		 * as iconAnchor if not specified).
		 *
		 * @option className: String = ''
		 * A custom class name to assign to both icon and shadow images. Empty by default.
		 */

		options: {
			popupAnchor: [0, 0],
			tooltipAnchor: [0, 0]
		},

		initialize: function (options) {
			setOptions(this, options);
		},

		// @method createIcon(oldIcon?: HTMLElement): HTMLElement
		// Called internally when the icon has to be shown, returns a `<img>` HTML element
		// styled according to the options.
		createIcon: function (oldIcon) {
			return this._createIcon('icon', oldIcon);
		},

		// @method createShadow(oldIcon?: HTMLElement): HTMLElement
		// As `createIcon`, but for the shadow beneath it.
		createShadow: function (oldIcon) {
			return this._createIcon('shadow', oldIcon);
		},

		_createIcon: function (name, oldIcon) {
			var src = this._getIconUrl(name);

			if (!src) {
				if (name === 'icon') {
					throw new Error('iconUrl not set in Icon options (see the docs).');
				}
				return null;
			}

			var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
			this._setIconStyles(img, name);

			return img;
		},

		_setIconStyles: function (img, name) {
			var options = this.options;
			var sizeOption = options[name + 'Size'];

			if (typeof sizeOption === 'number') {
				sizeOption = [sizeOption, sizeOption];
			}

			var size = toPoint(sizeOption),
			    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
			            size && size.divideBy(2, true));

			img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

			if (anchor) {
				img.style.marginLeft = (-anchor.x) + 'px';
				img.style.marginTop  = (-anchor.y) + 'px';
			}

			if (size) {
				img.style.width  = size.x + 'px';
				img.style.height = size.y + 'px';
			}
		},

		_createImg: function (src, el) {
			el = el || document.createElement('img');
			el.src = src;
			return el;
		},

		_getIconUrl: function (name) {
			return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
		}
	});


	// @factory L.icon(options: Icon options)
	// Creates an icon instance with the given options.
	function icon(options) {
		return new Icon(options);
	}

	/*
	 * @miniclass Icon.Default (Icon)
	 * @aka L.Icon.Default
	 * @section
	 *
	 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
	 * no icon is specified. Points to the blue marker image distributed with Leaflet
	 * releases.
	 *
	 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
	 * (which is a set of `Icon options`).
	 *
	 * If you want to _completely_ replace the default icon, override the
	 * `L.Marker.prototype.options.icon` with your own icon instead.
	 */

	var IconDefault = Icon.extend({

		options: {
			iconUrl:       'marker-icon.png',
			iconRetinaUrl: 'marker-icon-2x.png',
			shadowUrl:     'marker-shadow.png',
			iconSize:    [25, 41],
			iconAnchor:  [12, 41],
			popupAnchor: [1, -34],
			tooltipAnchor: [16, -28],
			shadowSize:  [41, 41]
		},

		_getIconUrl: function (name) {
			if (!IconDefault.imagePath) {	// Deprecated, backwards-compatibility only
				IconDefault.imagePath = this._detectIconPath();
			}

			// @option imagePath: String
			// `Icon.Default` will try to auto-detect the location of the
			// blue icon images. If you are placing these images in a non-standard
			// way, set this option to point to the right path.
			return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
		},

		_detectIconPath: function () {
			var el = create$1('div',  'leaflet-default-icon-path', document.body);
			var path = getStyle(el, 'background-image') ||
			           getStyle(el, 'backgroundImage');	// IE8

			document.body.removeChild(el);

			if (path === null || path.indexOf('url') !== 0) {
				path = '';
			} else {
				path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
			}

			return path;
		}
	});

	/*
	 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
	 */


	/* @namespace Marker
	 * @section Interaction handlers
	 *
	 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
	 *
	 * ```js
	 * marker.dragging.disable();
	 * ```
	 *
	 * @property dragging: Handler
	 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
	 */

	var MarkerDrag = Handler.extend({
		initialize: function (marker) {
			this._marker = marker;
		},

		addHooks: function () {
			var icon = this._marker._icon;

			if (!this._draggable) {
				this._draggable = new Draggable(icon, icon, true);
			}

			this._draggable.on({
				dragstart: this._onDragStart,
				predrag: this._onPreDrag,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this).enable();

			addClass(icon, 'leaflet-marker-draggable');
		},

		removeHooks: function () {
			this._draggable.off({
				dragstart: this._onDragStart,
				predrag: this._onPreDrag,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this).disable();

			if (this._marker._icon) {
				removeClass(this._marker._icon, 'leaflet-marker-draggable');
			}
		},

		moved: function () {
			return this._draggable && this._draggable._moved;
		},

		_adjustPan: function (e) {
			var marker = this._marker,
			    map = marker._map,
			    speed = this._marker.options.autoPanSpeed,
			    padding = this._marker.options.autoPanPadding,
			    iconPos = getPosition(marker._icon),
			    bounds = map.getPixelBounds(),
			    origin = map.getPixelOrigin();

			var panBounds = toBounds(
				bounds.min._subtract(origin).add(padding),
				bounds.max._subtract(origin).subtract(padding)
			);

			if (!panBounds.contains(iconPos)) {
				// Compute incremental movement
				var movement = toPoint(
					(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
					(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

					(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
					(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
				).multiplyBy(speed);

				map.panBy(movement, {animate: false});

				this._draggable._newPos._add(movement);
				this._draggable._startPos._add(movement);

				setPosition(marker._icon, this._draggable._newPos);
				this._onDrag(e);

				this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
			}
		},

		_onDragStart: function () {
			// @section Dragging events
			// @event dragstart: Event
			// Fired when the user starts dragging the marker.

			// @event movestart: Event
			// Fired when the marker starts moving (because of dragging).

			this._oldLatLng = this._marker.getLatLng();
			this._marker
			    .closePopup()
			    .fire('movestart')
			    .fire('dragstart');
		},

		_onPreDrag: function (e) {
			if (this._marker.options.autoPan) {
				cancelAnimFrame(this._panRequest);
				this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
			}
		},

		_onDrag: function (e) {
			var marker = this._marker,
			    shadow = marker._shadow,
			    iconPos = getPosition(marker._icon),
			    latlng = marker._map.layerPointToLatLng(iconPos);

			// update shadow position
			if (shadow) {
				setPosition(shadow, iconPos);
			}

			marker._latlng = latlng;
			e.latlng = latlng;
			e.oldLatLng = this._oldLatLng;

			// @event drag: Event
			// Fired repeatedly while the user drags the marker.
			marker
			    .fire('move', e)
			    .fire('drag', e);
		},

		_onDragEnd: function (e) {
			// @event dragend: DragEndEvent
			// Fired when the user stops dragging the marker.

			 cancelAnimFrame(this._panRequest);

			// @event moveend: Event
			// Fired when the marker stops moving (because of dragging).
			delete this._oldLatLng;
			this._marker
			    .fire('moveend')
			    .fire('dragend', e);
		}
	});

	/*
	 * @class Marker
	 * @inherits Interactive layer
	 * @aka L.Marker
	 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
	 *
	 * @example
	 *
	 * ```js
	 * L.marker([50.5, 30.5]).addTo(map);
	 * ```
	 */

	var Marker = Layer.extend({

		// @section
		// @aka Marker options
		options: {
			// @option icon: Icon = *
			// Icon instance to use for rendering the marker.
			// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
			// If not specified, a common instance of `L.Icon.Default` is used.
			icon: new IconDefault(),

			// Option inherited from "Interactive layer" abstract class
			interactive: true,

			// @option keyboard: Boolean = true
			// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
			keyboard: true,

			// @option title: String = ''
			// Text for the browser tooltip that appear on marker hover (no tooltip by default).
			title: '',

			// @option alt: String = ''
			// Text for the `alt` attribute of the icon image (useful for accessibility).
			alt: '',

			// @option zIndexOffset: Number = 0
			// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
			zIndexOffset: 0,

			// @option opacity: Number = 1.0
			// The opacity of the marker.
			opacity: 1,

			// @option riseOnHover: Boolean = false
			// If `true`, the marker will get on top of others when you hover the mouse over it.
			riseOnHover: false,

			// @option riseOffset: Number = 250
			// The z-index offset used for the `riseOnHover` feature.
			riseOffset: 250,

			// @option pane: String = 'markerPane'
			// `Map pane` where the markers icon will be added.
			pane: 'markerPane',

			// @option bubblingMouseEvents: Boolean = false
			// When `true`, a mouse event on this marker will trigger the same event on the map
			// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
			bubblingMouseEvents: false,

			// @section Draggable marker options
			// @option draggable: Boolean = false
			// Whether the marker is draggable with mouse/touch or not.
			draggable: false,

			// @option autoPan: Boolean = false
			// Whether to pan the map when dragging this marker near its edge or not.
			autoPan: false,

			// @option autoPanPadding: Point = Point(50, 50)
			// Distance (in pixels to the left/right and to the top/bottom) of the
			// map edge to start panning the map.
			autoPanPadding: [50, 50],

			// @option autoPanSpeed: Number = 10
			// Number of pixels the map should pan by.
			autoPanSpeed: 10
		},

		/* @section
		 *
		 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
		 */

		initialize: function (latlng, options) {
			setOptions(this, options);
			this._latlng = toLatLng(latlng);
		},

		onAdd: function (map) {
			this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

			if (this._zoomAnimated) {
				map.on('zoomanim', this._animateZoom, this);
			}

			this._initIcon();
			this.update();
		},

		onRemove: function (map) {
			if (this.dragging && this.dragging.enabled()) {
				this.options.draggable = true;
				this.dragging.removeHooks();
			}
			delete this.dragging;

			if (this._zoomAnimated) {
				map.off('zoomanim', this._animateZoom, this);
			}

			this._removeIcon();
			this._removeShadow();
		},

		getEvents: function () {
			return {
				zoom: this.update,
				viewreset: this.update
			};
		},

		// @method getLatLng: LatLng
		// Returns the current geographical position of the marker.
		getLatLng: function () {
			return this._latlng;
		},

		// @method setLatLng(latlng: LatLng): this
		// Changes the marker position to the given point.
		setLatLng: function (latlng) {
			var oldLatLng = this._latlng;
			this._latlng = toLatLng(latlng);
			this.update();

			// @event move: Event
			// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
			return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
		},

		// @method setZIndexOffset(offset: Number): this
		// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
		setZIndexOffset: function (offset) {
			this.options.zIndexOffset = offset;
			return this.update();
		},

		// @method setIcon(icon: Icon): this
		// Changes the marker icon.
		setIcon: function (icon) {

			this.options.icon = icon;

			if (this._map) {
				this._initIcon();
				this.update();
			}

			if (this._popup) {
				this.bindPopup(this._popup, this._popup.options);
			}

			return this;
		},

		getElement: function () {
			return this._icon;
		},

		update: function () {

			if (this._icon && this._map) {
				var pos = this._map.latLngToLayerPoint(this._latlng).round();
				this._setPos(pos);
			}

			return this;
		},

		_initIcon: function () {
			var options = this.options,
			    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

			var icon = options.icon.createIcon(this._icon),
			    addIcon = false;

			// if we're not reusing the icon, remove the old one and init new one
			if (icon !== this._icon) {
				if (this._icon) {
					this._removeIcon();
				}
				addIcon = true;

				if (options.title) {
					icon.title = options.title;
				}

				if (icon.tagName === 'IMG') {
					icon.alt = options.alt || '';
				}
			}

			addClass(icon, classToAdd);

			if (options.keyboard) {
				icon.tabIndex = '0';
			}

			this._icon = icon;

			if (options.riseOnHover) {
				this.on({
					mouseover: this._bringToFront,
					mouseout: this._resetZIndex
				});
			}

			var newShadow = options.icon.createShadow(this._shadow),
			    addShadow = false;

			if (newShadow !== this._shadow) {
				this._removeShadow();
				addShadow = true;
			}

			if (newShadow) {
				addClass(newShadow, classToAdd);
				newShadow.alt = '';
			}
			this._shadow = newShadow;


			if (options.opacity < 1) {
				this._updateOpacity();
			}


			if (addIcon) {
				this.getPane().appendChild(this._icon);
			}
			this._initInteraction();
			if (newShadow && addShadow) {
				this.getPane('shadowPane').appendChild(this._shadow);
			}
		},

		_removeIcon: function () {
			if (this.options.riseOnHover) {
				this.off({
					mouseover: this._bringToFront,
					mouseout: this._resetZIndex
				});
			}

			remove(this._icon);
			this.removeInteractiveTarget(this._icon);

			this._icon = null;
		},

		_removeShadow: function () {
			if (this._shadow) {
				remove(this._shadow);
			}
			this._shadow = null;
		},

		_setPos: function (pos) {
			setPosition(this._icon, pos);

			if (this._shadow) {
				setPosition(this._shadow, pos);
			}

			this._zIndex = pos.y + this.options.zIndexOffset;

			this._resetZIndex();
		},

		_updateZIndex: function (offset) {
			this._icon.style.zIndex = this._zIndex + offset;
		},

		_animateZoom: function (opt) {
			var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

			this._setPos(pos);
		},

		_initInteraction: function () {

			if (!this.options.interactive) { return; }

			addClass(this._icon, 'leaflet-interactive');

			this.addInteractiveTarget(this._icon);

			if (MarkerDrag) {
				var draggable = this.options.draggable;
				if (this.dragging) {
					draggable = this.dragging.enabled();
					this.dragging.disable();
				}

				this.dragging = new MarkerDrag(this);

				if (draggable) {
					this.dragging.enable();
				}
			}
		},

		// @method setOpacity(opacity: Number): this
		// Changes the opacity of the marker.
		setOpacity: function (opacity) {
			this.options.opacity = opacity;
			if (this._map) {
				this._updateOpacity();
			}

			return this;
		},

		_updateOpacity: function () {
			var opacity = this.options.opacity;

			setOpacity(this._icon, opacity);

			if (this._shadow) {
				setOpacity(this._shadow, opacity);
			}
		},

		_bringToFront: function () {
			this._updateZIndex(this.options.riseOffset);
		},

		_resetZIndex: function () {
			this._updateZIndex(0);
		},

		_getPopupAnchor: function () {
			return this.options.icon.options.popupAnchor;
		},

		_getTooltipAnchor: function () {
			return this.options.icon.options.tooltipAnchor;
		}
	});


	// factory L.marker(latlng: LatLng, options? : Marker options)

	// @factory L.marker(latlng: LatLng, options? : Marker options)
	// Instantiates a Marker object given a geographical point and optionally an options object.
	function marker(latlng, options) {
		return new Marker(latlng, options);
	}

	/*
	 * @class Path
	 * @aka L.Path
	 * @inherits Interactive layer
	 *
	 * An abstract class that contains options and constants shared between vector
	 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
	 */

	var Path = Layer.extend({

		// @section
		// @aka Path options
		options: {
			// @option stroke: Boolean = true
			// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
			stroke: true,

			// @option color: String = '#3388ff'
			// Stroke color
			color: '#3388ff',

			// @option weight: Number = 3
			// Stroke width in pixels
			weight: 3,

			// @option opacity: Number = 1.0
			// Stroke opacity
			opacity: 1,

			// @option lineCap: String= 'round'
			// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
			lineCap: 'round',

			// @option lineJoin: String = 'round'
			// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
			lineJoin: 'round',

			// @option dashArray: String = null
			// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
			dashArray: null,

			// @option dashOffset: String = null
			// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
			dashOffset: null,

			// @option fill: Boolean = depends
			// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
			fill: false,

			// @option fillColor: String = *
			// Fill color. Defaults to the value of the [`color`](#path-color) option
			fillColor: null,

			// @option fillOpacity: Number = 0.2
			// Fill opacity.
			fillOpacity: 0.2,

			// @option fillRule: String = 'evenodd'
			// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
			fillRule: 'evenodd',

			// className: '',

			// Option inherited from "Interactive layer" abstract class
			interactive: true,

			// @option bubblingMouseEvents: Boolean = true
			// When `true`, a mouse event on this path will trigger the same event on the map
			// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
			bubblingMouseEvents: true
		},

		beforeAdd: function (map) {
			// Renderer is set here because we need to call renderer.getEvents
			// before this.getEvents.
			this._renderer = map.getRenderer(this);
		},

		onAdd: function () {
			this._renderer._initPath(this);
			this._reset();
			this._renderer._addPath(this);
		},

		onRemove: function () {
			this._renderer._removePath(this);
		},

		// @method redraw(): this
		// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
		redraw: function () {
			if (this._map) {
				this._renderer._updatePath(this);
			}
			return this;
		},

		// @method setStyle(style: Path options): this
		// Changes the appearance of a Path based on the options in the `Path options` object.
		setStyle: function (style) {
			setOptions(this, style);
			if (this._renderer) {
				this._renderer._updateStyle(this);
			}
			return this;
		},

		// @method bringToFront(): this
		// Brings the layer to the top of all path layers.
		bringToFront: function () {
			if (this._renderer) {
				this._renderer._bringToFront(this);
			}
			return this;
		},

		// @method bringToBack(): this
		// Brings the layer to the bottom of all path layers.
		bringToBack: function () {
			if (this._renderer) {
				this._renderer._bringToBack(this);
			}
			return this;
		},

		getElement: function () {
			return this._path;
		},

		_reset: function () {
			// defined in child classes
			this._project();
			this._update();
		},

		_clickTolerance: function () {
			// used when doing hit detection for Canvas layers
			return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
		}
	});

	/*
	 * @class CircleMarker
	 * @aka L.CircleMarker
	 * @inherits Path
	 *
	 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
	 */

	var CircleMarker = Path.extend({

		// @section
		// @aka CircleMarker options
		options: {
			fill: true,

			// @option radius: Number = 10
			// Radius of the circle marker, in pixels
			radius: 10
		},

		initialize: function (latlng, options) {
			setOptions(this, options);
			this._latlng = toLatLng(latlng);
			this._radius = this.options.radius;
		},

		// @method setLatLng(latLng: LatLng): this
		// Sets the position of a circle marker to a new location.
		setLatLng: function (latlng) {
			this._latlng = toLatLng(latlng);
			this.redraw();
			return this.fire('move', {latlng: this._latlng});
		},

		// @method getLatLng(): LatLng
		// Returns the current geographical position of the circle marker
		getLatLng: function () {
			return this._latlng;
		},

		// @method setRadius(radius: Number): this
		// Sets the radius of a circle marker. Units are in pixels.
		setRadius: function (radius) {
			this.options.radius = this._radius = radius;
			return this.redraw();
		},

		// @method getRadius(): Number
		// Returns the current radius of the circle
		getRadius: function () {
			return this._radius;
		},

		setStyle : function (options) {
			var radius = options && options.radius || this._radius;
			Path.prototype.setStyle.call(this, options);
			this.setRadius(radius);
			return this;
		},

		_project: function () {
			this._point = this._map.latLngToLayerPoint(this._latlng);
			this._updateBounds();
		},

		_updateBounds: function () {
			var r = this._radius,
			    r2 = this._radiusY || r,
			    w = this._clickTolerance(),
			    p = [r + w, r2 + w];
			this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
		},

		_update: function () {
			if (this._map) {
				this._updatePath();
			}
		},

		_updatePath: function () {
			this._renderer._updateCircle(this);
		},

		_empty: function () {
			return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
		},

		// Needed by the `Canvas` renderer for interactivity
		_containsPoint: function (p) {
			return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
		}
	});


	// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
	// Instantiates a circle marker object given a geographical point, and an optional options object.
	function circleMarker(latlng, options) {
		return new CircleMarker(latlng, options);
	}

	/*
	 * @class Circle
	 * @aka L.Circle
	 * @inherits CircleMarker
	 *
	 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
	 *
	 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
	 *
	 * @example
	 *
	 * ```js
	 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
	 * ```
	 */

	var Circle = CircleMarker.extend({

		initialize: function (latlng, options, legacyOptions) {
			if (typeof options === 'number') {
				// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
				options = extend({}, legacyOptions, {radius: options});
			}
			setOptions(this, options);
			this._latlng = toLatLng(latlng);

			if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

			// @section
			// @aka Circle options
			// @option radius: Number; Radius of the circle, in meters.
			this._mRadius = this.options.radius;
		},

		// @method setRadius(radius: Number): this
		// Sets the radius of a circle. Units are in meters.
		setRadius: function (radius) {
			this._mRadius = radius;
			return this.redraw();
		},

		// @method getRadius(): Number
		// Returns the current radius of a circle. Units are in meters.
		getRadius: function () {
			return this._mRadius;
		},

		// @method getBounds(): LatLngBounds
		// Returns the `LatLngBounds` of the path.
		getBounds: function () {
			var half = [this._radius, this._radiusY || this._radius];

			return new LatLngBounds(
				this._map.layerPointToLatLng(this._point.subtract(half)),
				this._map.layerPointToLatLng(this._point.add(half)));
		},

		setStyle: Path.prototype.setStyle,

		_project: function () {

			var lng = this._latlng.lng,
			    lat = this._latlng.lat,
			    map = this._map,
			    crs = map.options.crs;

			if (crs.distance === Earth.distance) {
				var d = Math.PI / 180,
				    latR = (this._mRadius / Earth.R) / d,
				    top = map.project([lat + latR, lng]),
				    bottom = map.project([lat - latR, lng]),
				    p = top.add(bottom).divideBy(2),
				    lat2 = map.unproject(p).lat,
				    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
				            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

				if (isNaN(lngR) || lngR === 0) {
					lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
				}

				this._point = p.subtract(map.getPixelOrigin());
				this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
				this._radiusY = p.y - top.y;

			} else {
				var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

				this._point = map.latLngToLayerPoint(this._latlng);
				this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
			}

			this._updateBounds();
		}
	});

	// @factory L.circle(latlng: LatLng, options?: Circle options)
	// Instantiates a circle object given a geographical point, and an options object
	// which contains the circle radius.
	// @alternative
	// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
	// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
	// Do not use in new applications or plugins.
	function circle(latlng, options, legacyOptions) {
		return new Circle(latlng, options, legacyOptions);
	}

	/*
	 * @class Polyline
	 * @aka L.Polyline
	 * @inherits Path
	 *
	 * A class for drawing polyline overlays on a map. Extends `Path`.
	 *
	 * @example
	 *
	 * ```js
	 * // create a red polyline from an array of LatLng points
	 * var latlngs = [
	 * 	[45.51, -122.68],
	 * 	[37.77, -122.43],
	 * 	[34.04, -118.2]
	 * ];
	 *
	 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
	 *
	 * // zoom the map to the polyline
	 * map.fitBounds(polyline.getBounds());
	 * ```
	 *
	 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
	 *
	 * ```js
	 * // create a red polyline from an array of arrays of LatLng points
	 * var latlngs = [
	 * 	[[45.51, -122.68],
	 * 	 [37.77, -122.43],
	 * 	 [34.04, -118.2]],
	 * 	[[40.78, -73.91],
	 * 	 [41.83, -87.62],
	 * 	 [32.76, -96.72]]
	 * ];
	 * ```
	 */


	var Polyline = Path.extend({

		// @section
		// @aka Polyline options
		options: {
			// @option smoothFactor: Number = 1.0
			// How much to simplify the polyline on each zoom level. More means
			// better performance and smoother look, and less means more accurate representation.
			smoothFactor: 1.0,

			// @option noClip: Boolean = false
			// Disable polyline clipping.
			noClip: false
		},

		initialize: function (latlngs, options) {
			setOptions(this, options);
			this._setLatLngs(latlngs);
		},

		// @method getLatLngs(): LatLng[]
		// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
		getLatLngs: function () {
			return this._latlngs;
		},

		// @method setLatLngs(latlngs: LatLng[]): this
		// Replaces all the points in the polyline with the given array of geographical points.
		setLatLngs: function (latlngs) {
			this._setLatLngs(latlngs);
			return this.redraw();
		},

		// @method isEmpty(): Boolean
		// Returns `true` if the Polyline has no LatLngs.
		isEmpty: function () {
			return !this._latlngs.length;
		},

		// @method closestLayerPoint(p: Point): Point
		// Returns the point closest to `p` on the Polyline.
		closestLayerPoint: function (p) {
			var minDistance = Infinity,
			    minPoint = null,
			    closest = _sqClosestPointOnSegment,
			    p1, p2;

			for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
				var points = this._parts[j];

				for (var i = 1, len = points.length; i < len; i++) {
					p1 = points[i - 1];
					p2 = points[i];

					var sqDist = closest(p, p1, p2, true);

					if (sqDist < minDistance) {
						minDistance = sqDist;
						minPoint = closest(p, p1, p2);
					}
				}
			}
			if (minPoint) {
				minPoint.distance = Math.sqrt(minDistance);
			}
			return minPoint;
		},

		// @method getCenter(): LatLng
		// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
		getCenter: function () {
			// throws error when not yet added to map as this center calculation requires projected coordinates
			if (!this._map) {
				throw new Error('Must add layer to map before using getCenter()');
			}

			var i, halfDist, segDist, dist, p1, p2, ratio,
			    points = this._rings[0],
			    len = points.length;

			if (!len) { return null; }

			// polyline centroid algorithm; only uses the first ring if there are multiple

			for (i = 0, halfDist = 0; i < len - 1; i++) {
				halfDist += points[i].distanceTo(points[i + 1]) / 2;
			}

			// The line is so small in the current view that all points are on the same pixel.
			if (halfDist === 0) {
				return this._map.layerPointToLatLng(points[0]);
			}

			for (i = 0, dist = 0; i < len - 1; i++) {
				p1 = points[i];
				p2 = points[i + 1];
				segDist = p1.distanceTo(p2);
				dist += segDist;

				if (dist > halfDist) {
					ratio = (dist - halfDist) / segDist;
					return this._map.layerPointToLatLng([
						p2.x - ratio * (p2.x - p1.x),
						p2.y - ratio * (p2.y - p1.y)
					]);
				}
			}
		},

		// @method getBounds(): LatLngBounds
		// Returns the `LatLngBounds` of the path.
		getBounds: function () {
			return this._bounds;
		},

		// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
		// Adds a given point to the polyline. By default, adds to the first ring of
		// the polyline in case of a multi-polyline, but can be overridden by passing
		// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
		addLatLng: function (latlng, latlngs) {
			latlngs = latlngs || this._defaultShape();
			latlng = toLatLng(latlng);
			latlngs.push(latlng);
			this._bounds.extend(latlng);
			return this.redraw();
		},

		_setLatLngs: function (latlngs) {
			this._bounds = new LatLngBounds();
			this._latlngs = this._convertLatLngs(latlngs);
		},

		_defaultShape: function () {
			return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
		},

		// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
		_convertLatLngs: function (latlngs) {
			var result = [],
			    flat = isFlat(latlngs);

			for (var i = 0, len = latlngs.length; i < len; i++) {
				if (flat) {
					result[i] = toLatLng(latlngs[i]);
					this._bounds.extend(result[i]);
				} else {
					result[i] = this._convertLatLngs(latlngs[i]);
				}
			}

			return result;
		},

		_project: function () {
			var pxBounds = new Bounds();
			this._rings = [];
			this._projectLatlngs(this._latlngs, this._rings, pxBounds);

			var w = this._clickTolerance(),
			    p = new Point(w, w);

			if (this._bounds.isValid() && pxBounds.isValid()) {
				pxBounds.min._subtract(p);
				pxBounds.max._add(p);
				this._pxBounds = pxBounds;
			}
		},

		// recursively turns latlngs into a set of rings with projected coordinates
		_projectLatlngs: function (latlngs, result, projectedBounds) {
			var flat = latlngs[0] instanceof LatLng,
			    len = latlngs.length,
			    i, ring;

			if (flat) {
				ring = [];
				for (i = 0; i < len; i++) {
					ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
					projectedBounds.extend(ring[i]);
				}
				result.push(ring);
			} else {
				for (i = 0; i < len; i++) {
					this._projectLatlngs(latlngs[i], result, projectedBounds);
				}
			}
		},

		// clip polyline by renderer bounds so that we have less to render for performance
		_clipPoints: function () {
			var bounds = this._renderer._bounds;

			this._parts = [];
			if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
				return;
			}

			if (this.options.noClip) {
				this._parts = this._rings;
				return;
			}

			var parts = this._parts,
			    i, j, k, len, len2, segment, points;

			for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
				points = this._rings[i];

				for (j = 0, len2 = points.length; j < len2 - 1; j++) {
					segment = clipSegment(points[j], points[j + 1], bounds, j, true);

					if (!segment) { continue; }

					parts[k] = parts[k] || [];
					parts[k].push(segment[0]);

					// if segment goes out of screen, or it's the last one, it's the end of the line part
					if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
						parts[k].push(segment[1]);
						k++;
					}
				}
			}
		},

		// simplify each clipped part of the polyline for performance
		_simplifyPoints: function () {
			var parts = this._parts,
			    tolerance = this.options.smoothFactor;

			for (var i = 0, len = parts.length; i < len; i++) {
				parts[i] = simplify(parts[i], tolerance);
			}
		},

		_update: function () {
			if (!this._map) { return; }

			this._clipPoints();
			this._simplifyPoints();
			this._updatePath();
		},

		_updatePath: function () {
			this._renderer._updatePoly(this);
		},

		// Needed by the `Canvas` renderer for interactivity
		_containsPoint: function (p, closed) {
			var i, j, k, len, len2, part,
			    w = this._clickTolerance();

			if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

			// hit detection for polylines
			for (i = 0, len = this._parts.length; i < len; i++) {
				part = this._parts[i];

				for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
					if (!closed && (j === 0)) { continue; }

					if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
						return true;
					}
				}
			}
			return false;
		}
	});

	// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
	// Instantiates a polyline object given an array of geographical points and
	// optionally an options object. You can create a `Polyline` object with
	// multiple separate lines (`MultiPolyline`) by passing an array of arrays
	// of geographic points.
	function polyline(latlngs, options) {
		return new Polyline(latlngs, options);
	}

	// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
	Polyline._flat = _flat;

	/*
	 * @class Polygon
	 * @aka L.Polygon
	 * @inherits Polyline
	 *
	 * A class for drawing polygon overlays on a map. Extends `Polyline`.
	 *
	 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
	 *
	 *
	 * @example
	 *
	 * ```js
	 * // create a red polygon from an array of LatLng points
	 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
	 *
	 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
	 *
	 * // zoom the map to the polygon
	 * map.fitBounds(polygon.getBounds());
	 * ```
	 *
	 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
	 *
	 * ```js
	 * var latlngs = [
	 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
	 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
	 * ];
	 * ```
	 *
	 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
	 *
	 * ```js
	 * var latlngs = [
	 *   [ // first polygon
	 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
	 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
	 *   ],
	 *   [ // second polygon
	 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
	 *   ]
	 * ];
	 * ```
	 */

	var Polygon = Polyline.extend({

		options: {
			fill: true
		},

		isEmpty: function () {
			return !this._latlngs.length || !this._latlngs[0].length;
		},

		getCenter: function () {
			// throws error when not yet added to map as this center calculation requires projected coordinates
			if (!this._map) {
				throw new Error('Must add layer to map before using getCenter()');
			}

			var i, j, p1, p2, f, area, x, y, center,
			    points = this._rings[0],
			    len = points.length;

			if (!len) { return null; }

			// polygon centroid algorithm; only uses the first ring if there are multiple

			area = x = y = 0;

			for (i = 0, j = len - 1; i < len; j = i++) {
				p1 = points[i];
				p2 = points[j];

				f = p1.y * p2.x - p2.y * p1.x;
				x += (p1.x + p2.x) * f;
				y += (p1.y + p2.y) * f;
				area += f * 3;
			}

			if (area === 0) {
				// Polygon is so small that all points are on same pixel.
				center = points[0];
			} else {
				center = [x / area, y / area];
			}
			return this._map.layerPointToLatLng(center);
		},

		_convertLatLngs: function (latlngs) {
			var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
			    len = result.length;

			// remove last point if it equals first one
			if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
				result.pop();
			}
			return result;
		},

		_setLatLngs: function (latlngs) {
			Polyline.prototype._setLatLngs.call(this, latlngs);
			if (isFlat(this._latlngs)) {
				this._latlngs = [this._latlngs];
			}
		},

		_defaultShape: function () {
			return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
		},

		_clipPoints: function () {
			// polygons need a different clipping algorithm so we redefine that

			var bounds = this._renderer._bounds,
			    w = this.options.weight,
			    p = new Point(w, w);

			// increase clip padding by stroke width to avoid stroke on clip edges
			bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

			this._parts = [];
			if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
				return;
			}

			if (this.options.noClip) {
				this._parts = this._rings;
				return;
			}

			for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
				clipped = clipPolygon(this._rings[i], bounds, true);
				if (clipped.length) {
					this._parts.push(clipped);
				}
			}
		},

		_updatePath: function () {
			this._renderer._updatePoly(this, true);
		},

		// Needed by the `Canvas` renderer for interactivity
		_containsPoint: function (p) {
			var inside = false,
			    part, p1, p2, i, j, k, len, len2;

			if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

			// ray casting algorithm for detecting if point is in polygon
			for (i = 0, len = this._parts.length; i < len; i++) {
				part = this._parts[i];

				for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
					p1 = part[j];
					p2 = part[k];

					if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
						inside = !inside;
					}
				}
			}

			// also check if it's on polygon stroke
			return inside || Polyline.prototype._containsPoint.call(this, p, true);
		}

	});


	// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
	function polygon(latlngs, options) {
		return new Polygon(latlngs, options);
	}

	/*
	 * @class GeoJSON
	 * @aka L.GeoJSON
	 * @inherits FeatureGroup
	 *
	 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
	 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
	 *
	 * @example
	 *
	 * ```js
	 * L.geoJSON(data, {
	 * 	style: function (feature) {
	 * 		return {color: feature.properties.color};
	 * 	}
	 * }).bindPopup(function (layer) {
	 * 	return layer.feature.properties.description;
	 * }).addTo(map);
	 * ```
	 */

	var GeoJSON = FeatureGroup.extend({

		/* @section
		 * @aka GeoJSON options
		 *
		 * @option pointToLayer: Function = *
		 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
		 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
		 * The default is to spawn a default `Marker`:
		 * ```js
		 * function(geoJsonPoint, latlng) {
		 * 	return L.marker(latlng);
		 * }
		 * ```
		 *
		 * @option style: Function = *
		 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
		 * called internally when data is added.
		 * The default value is to not override any defaults:
		 * ```js
		 * function (geoJsonFeature) {
		 * 	return {}
		 * }
		 * ```
		 *
		 * @option onEachFeature: Function = *
		 * A `Function` that will be called once for each created `Feature`, after it has
		 * been created and styled. Useful for attaching events and popups to features.
		 * The default is to do nothing with the newly created layers:
		 * ```js
		 * function (feature, layer) {}
		 * ```
		 *
		 * @option filter: Function = *
		 * A `Function` that will be used to decide whether to include a feature or not.
		 * The default is to include all features:
		 * ```js
		 * function (geoJsonFeature) {
		 * 	return true;
		 * }
		 * ```
		 * Note: dynamically changing the `filter` option will have effect only on newly
		 * added data. It will _not_ re-evaluate already included features.
		 *
		 * @option coordsToLatLng: Function = *
		 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
		 * The default is the `coordsToLatLng` static method.
		 */

		initialize: function (geojson, options) {
			setOptions(this, options);

			this._layers = {};

			if (geojson) {
				this.addData(geojson);
			}
		},

		// @method addData( <GeoJSON> data ): this
		// Adds a GeoJSON object to the layer.
		addData: function (geojson) {
			var features = isArray(geojson) ? geojson : geojson.features,
			    i, len, feature;

			if (features) {
				for (i = 0, len = features.length; i < len; i++) {
					// only add this if geometry or geometries are set and not null
					feature = features[i];
					if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
						this.addData(feature);
					}
				}
				return this;
			}

			var options = this.options;

			if (options.filter && !options.filter(geojson)) { return this; }

			var layer = geometryToLayer(geojson, options);
			if (!layer) {
				return this;
			}
			layer.feature = asFeature(geojson);

			layer.defaultOptions = layer.options;
			this.resetStyle(layer);

			if (options.onEachFeature) {
				options.onEachFeature(geojson, layer);
			}

			return this.addLayer(layer);
		},

		// @method resetStyle( <Path> layer ): this
		// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
		resetStyle: function (layer) {
			// reset any custom styles
			layer.options = extend({}, layer.defaultOptions);
			this._setLayerStyle(layer, this.options.style);
			return this;
		},

		// @method setStyle( <Function> style ): this
		// Changes styles of GeoJSON vector layers with the given style function.
		setStyle: function (style) {
			return this.eachLayer(function (layer) {
				this._setLayerStyle(layer, style);
			}, this);
		},

		_setLayerStyle: function (layer, style) {
			if (typeof style === 'function') {
				style = style(layer.feature);
			}
			if (layer.setStyle) {
				layer.setStyle(style);
			}
		}
	});

	// @section
	// There are several static functions which can be called without instantiating L.GeoJSON:

	// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
	// Creates a `Layer` from a given GeoJSON feature. Can use a custom
	// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
	// functions if provided as options.
	function geometryToLayer(geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry ? geometry.coordinates : null,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
		    latlng, latlngs, i, len;

		if (!coords && !geometry) {
			return null;
		}

		switch (geometry.type) {
		case 'Point':
			latlng = _coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = _coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng));
			}
			return new FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
			return new Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
			return new Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	}

	// @function coordsToLatLng(coords: Array): LatLng
	// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
	// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
	function coordsToLatLng(coords) {
		return new LatLng(coords[1], coords[0], coords[2]);
	}

	// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
	// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
	// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
	// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
	function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
				coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
				(_coordsToLatLng || coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	}

	// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
	// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
	function latLngToCoords(latlng, precision) {
		precision = typeof precision === 'number' ? precision : 6;
		return latlng.alt !== undefined ?
			[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
			[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
	}

	// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
	// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
	// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
	function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :
				latLngToCoords(latlngs[i], precision));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	}

	function getFeature(layer, newGeometry) {
		return layer.feature ?
			extend({}, layer.feature, {geometry: newGeometry}) :
			asFeature(newGeometry);
	}

	// @function asFeature(geojson: Object): Object
	// Normalize GeoJSON geometries/features into GeoJSON features.
	function asFeature(geojson) {
		if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
			return geojson;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geojson
		};
	}

	var PointToGeoJSON = {
		toGeoJSON: function (precision) {
			return getFeature(this, {
				type: 'Point',
				coordinates: latLngToCoords(this.getLatLng(), precision)
			});
		}
	};

	// @namespace Marker
	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
	Marker.include(PointToGeoJSON);

	// @namespace CircleMarker
	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
	Circle.include(PointToGeoJSON);
	CircleMarker.include(PointToGeoJSON);


	// @namespace Polyline
	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
	Polyline.include({
		toGeoJSON: function (precision) {
			var multi = !isFlat(this._latlngs);

			var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

			return getFeature(this, {
				type: (multi ? 'Multi' : '') + 'LineString',
				coordinates: coords
			});
		}
	});

	// @namespace Polygon
	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
	Polygon.include({
		toGeoJSON: function (precision) {
			var holes = !isFlat(this._latlngs),
			    multi = holes && !isFlat(this._latlngs[0]);

			var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

			if (!holes) {
				coords = [coords];
			}

			return getFeature(this, {
				type: (multi ? 'Multi' : '') + 'Polygon',
				coordinates: coords
			});
		}
	});


	// @namespace LayerGroup
	LayerGroup.include({
		toMultiPoint: function (precision) {
			var coords = [];

			this.eachLayer(function (layer) {
				coords.push(layer.toGeoJSON(precision).geometry.coordinates);
			});

			return getFeature(this, {
				type: 'MultiPoint',
				coordinates: coords
			});
		},

		// @method toGeoJSON(): Object
		// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
		toGeoJSON: function (precision) {

			var type = this.feature && this.feature.geometry && this.feature.geometry.type;

			if (type === 'MultiPoint') {
				return this.toMultiPoint(precision);
			}

			var isGeometryCollection = type === 'GeometryCollection',
			    jsons = [];

			this.eachLayer(function (layer) {
				if (layer.toGeoJSON) {
					var json = layer.toGeoJSON(precision);
					if (isGeometryCollection) {
						jsons.push(json.geometry);
					} else {
						var feature = asFeature(json);
						// Squash nested feature collections
						if (feature.type === 'FeatureCollection') {
							jsons.push.apply(jsons, feature.features);
						} else {
							jsons.push(feature);
						}
					}
				}
			});

			if (isGeometryCollection) {
				return getFeature(this, {
					geometries: jsons,
					type: 'GeometryCollection'
				});
			}

			return {
				type: 'FeatureCollection',
				features: jsons
			};
		}
	});

	// @namespace GeoJSON
	// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
	// Creates a GeoJSON layer. Optionally accepts an object in
	// [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
	// (you can alternatively add it later with `addData` method) and an `options` object.
	function geoJSON(geojson, options) {
		return new GeoJSON(geojson, options);
	}

	// Backward compatibility.
	var geoJson = geoJSON;

	/*
	 * @class ImageOverlay
	 * @aka L.ImageOverlay
	 * @inherits Interactive layer
	 *
	 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
	 *
	 * @example
	 *
	 * ```js
	 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
	 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
	 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
	 * ```
	 */

	var ImageOverlay = Layer.extend({

		// @section
		// @aka ImageOverlay options
		options: {
			// @option opacity: Number = 1.0
			// The opacity of the image overlay.
			opacity: 1,

			// @option alt: String = ''
			// Text for the `alt` attribute of the image (useful for accessibility).
			alt: '',

			// @option interactive: Boolean = false
			// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
			interactive: false,

			// @option crossOrigin: Boolean|String = false
			// Whether the crossOrigin attribute will be added to the image.
			// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
			// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
			crossOrigin: false,

			// @option errorOverlayUrl: String = ''
			// URL to the overlay image to show in place of the overlay that failed to load.
			errorOverlayUrl: '',

			// @option zIndex: Number = 1
			// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
			zIndex: 1,

			// @option className: String = ''
			// A custom class name to assign to the image. Empty by default.
			className: ''
		},

		initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
			this._url = url;
			this._bounds = toLatLngBounds(bounds);

			setOptions(this, options);
		},

		onAdd: function () {
			if (!this._image) {
				this._initImage();

				if (this.options.opacity < 1) {
					this._updateOpacity();
				}
			}

			if (this.options.interactive) {
				addClass(this._image, 'leaflet-interactive');
				this.addInteractiveTarget(this._image);
			}

			this.getPane().appendChild(this._image);
			this._reset();
		},

		onRemove: function () {
			remove(this._image);
			if (this.options.interactive) {
				this.removeInteractiveTarget(this._image);
			}
		},

		// @method setOpacity(opacity: Number): this
		// Sets the opacity of the overlay.
		setOpacity: function (opacity) {
			this.options.opacity = opacity;

			if (this._image) {
				this._updateOpacity();
			}
			return this;
		},

		setStyle: function (styleOpts) {
			if (styleOpts.opacity) {
				this.setOpacity(styleOpts.opacity);
			}
			return this;
		},

		// @method bringToFront(): this
		// Brings the layer to the top of all overlays.
		bringToFront: function () {
			if (this._map) {
				toFront(this._image);
			}
			return this;
		},

		// @method bringToBack(): this
		// Brings the layer to the bottom of all overlays.
		bringToBack: function () {
			if (this._map) {
				toBack(this._image);
			}
			return this;
		},

		// @method setUrl(url: String): this
		// Changes the URL of the image.
		setUrl: function (url) {
			this._url = url;

			if (this._image) {
				this._image.src = url;
			}
			return this;
		},

		// @method setBounds(bounds: LatLngBounds): this
		// Update the bounds that this ImageOverlay covers
		setBounds: function (bounds) {
			this._bounds = toLatLngBounds(bounds);

			if (this._map) {
				this._reset();
			}
			return this;
		},

		getEvents: function () {
			var events = {
				zoom: this._reset,
				viewreset: this._reset
			};

			if (this._zoomAnimated) {
				events.zoomanim = this._animateZoom;
			}

			return events;
		},

		// @method setZIndex(value: Number): this
		// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
		setZIndex: function (value) {
			this.options.zIndex = value;
			this._updateZIndex();
			return this;
		},

		// @method getBounds(): LatLngBounds
		// Get the bounds that this ImageOverlay covers
		getBounds: function () {
			return this._bounds;
		},

		// @method getElement(): HTMLElement
		// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
		// used by this overlay.
		getElement: function () {
			return this._image;
		},

		_initImage: function () {
			var wasElementSupplied = this._url.tagName === 'IMG';
			var img = this._image = wasElementSupplied ? this._url : create$1('img');

			addClass(img, 'leaflet-image-layer');
			if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
			if (this.options.className) { addClass(img, this.options.className); }

			img.onselectstart = falseFn;
			img.onmousemove = falseFn;

			// @event load: Event
			// Fired when the ImageOverlay layer has loaded its image
			img.onload = bind(this.fire, this, 'load');
			img.onerror = bind(this._overlayOnError, this, 'error');

			if (this.options.crossOrigin || this.options.crossOrigin === '') {
				img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
			}

			if (this.options.zIndex) {
				this._updateZIndex();
			}

			if (wasElementSupplied) {
				this._url = img.src;
				return;
			}

			img.src = this._url;
			img.alt = this.options.alt;
		},

		_animateZoom: function (e) {
			var scale = this._map.getZoomScale(e.zoom),
			    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

			setTransform(this._image, offset, scale);
		},

		_reset: function () {
			var image = this._image,
			    bounds = new Bounds(
			        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
			        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
			    size = bounds.getSize();

			setPosition(image, bounds.min);

			image.style.width  = size.x + 'px';
			image.style.height = size.y + 'px';
		},

		_updateOpacity: function () {
			setOpacity(this._image, this.options.opacity);
		},

		_updateZIndex: function () {
			if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
				this._image.style.zIndex = this.options.zIndex;
			}
		},

		_overlayOnError: function () {
			// @event error: Event
			// Fired when the ImageOverlay layer fails to load its image
			this.fire('error');

			var errorUrl = this.options.errorOverlayUrl;
			if (errorUrl && this._url !== errorUrl) {
				this._url = errorUrl;
				this._image.src = errorUrl;
			}
		}
	});

	// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
	// Instantiates an image overlay object given the URL of the image and the
	// geographical bounds it is tied to.
	var imageOverlay = function (url, bounds, options) {
		return new ImageOverlay(url, bounds, options);
	};

	/*
	 * @class VideoOverlay
	 * @aka L.VideoOverlay
	 * @inherits ImageOverlay
	 *
	 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
	 *
	 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
	 * HTML5 element.
	 *
	 * @example
	 *
	 * ```js
	 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
	 * 	videoBounds = [[ 32, -130], [ 13, -100]];
	 * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
	 * ```
	 */

	var VideoOverlay = ImageOverlay.extend({

		// @section
		// @aka VideoOverlay options
		options: {
			// @option autoplay: Boolean = true
			// Whether the video starts playing automatically when loaded.
			autoplay: true,

			// @option loop: Boolean = true
			// Whether the video will loop back to the beginning when played.
			loop: true
		},

		_initImage: function () {
			var wasElementSupplied = this._url.tagName === 'VIDEO';
			var vid = this._image = wasElementSupplied ? this._url : create$1('video');

			addClass(vid, 'leaflet-image-layer');
			if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }

			vid.onselectstart = falseFn;
			vid.onmousemove = falseFn;

			// @event load: Event
			// Fired when the video has finished loading the first frame
			vid.onloadeddata = bind(this.fire, this, 'load');

			if (wasElementSupplied) {
				var sourceElements = vid.getElementsByTagName('source');
				var sources = [];
				for (var j = 0; j < sourceElements.length; j++) {
					sources.push(sourceElements[j].src);
				}

				this._url = (sourceElements.length > 0) ? sources : [vid.src];
				return;
			}

			if (!isArray(this._url)) { this._url = [this._url]; }

			vid.autoplay = !!this.options.autoplay;
			vid.loop = !!this.options.loop;
			for (var i = 0; i < this._url.length; i++) {
				var source = create$1('source');
				source.src = this._url[i];
				vid.appendChild(source);
			}
		}

		// @method getElement(): HTMLVideoElement
		// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
		// used by this overlay.
	});


	// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
	// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
	// geographical bounds it is tied to.

	function videoOverlay(video, bounds, options) {
		return new VideoOverlay(video, bounds, options);
	}

	/*
	 * @class DivOverlay
	 * @inherits Layer
	 * @aka L.DivOverlay
	 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
	 */

	// @namespace DivOverlay
	var DivOverlay = Layer.extend({

		// @section
		// @aka DivOverlay options
		options: {
			// @option offset: Point = Point(0, 7)
			// The offset of the popup position. Useful to control the anchor
			// of the popup when opening it on some overlays.
			offset: [0, 7],

			// @option className: String = ''
			// A custom CSS class name to assign to the popup.
			className: '',

			// @option pane: String = 'popupPane'
			// `Map pane` where the popup will be added.
			pane: 'popupPane'
		},

		initialize: function (options, source) {
			setOptions(this, options);

			this._source = source;
		},

		onAdd: function (map) {
			this._zoomAnimated = map._zoomAnimated;

			if (!this._container) {
				this._initLayout();
			}

			if (map._fadeAnimated) {
				setOpacity(this._container, 0);
			}

			clearTimeout(this._removeTimeout);
			this.getPane().appendChild(this._container);
			this.update();

			if (map._fadeAnimated) {
				setOpacity(this._container, 1);
			}

			this.bringToFront();
		},

		onRemove: function (map) {
			if (map._fadeAnimated) {
				setOpacity(this._container, 0);
				this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
			} else {
				remove(this._container);
			}
		},

		// @namespace Popup
		// @method getLatLng: LatLng
		// Returns the geographical point of popup.
		getLatLng: function () {
			return this._latlng;
		},

		// @method setLatLng(latlng: LatLng): this
		// Sets the geographical point where the popup will open.
		setLatLng: function (latlng) {
			this._latlng = toLatLng(latlng);
			if (this._map) {
				this._updatePosition();
				this._adjustPan();
			}
			return this;
		},

		// @method getContent: String|HTMLElement
		// Returns the content of the popup.
		getContent: function () {
			return this._content;
		},

		// @method setContent(htmlContent: String|HTMLElement|Function): this
		// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
		setContent: function (content) {
			this._content = content;
			this.update();
			return this;
		},

		// @method getElement: String|HTMLElement
		// Alias for [getContent()](#popup-getcontent)
		getElement: function () {
			return this._container;
		},

		// @method update: null
		// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
		update: function () {
			if (!this._map) { return; }

			this._container.style.visibility = 'hidden';

			this._updateContent();
			this._updateLayout();
			this._updatePosition();

			this._container.style.visibility = '';

			this._adjustPan();
		},

		getEvents: function () {
			var events = {
				zoom: this._updatePosition,
				viewreset: this._updatePosition
			};

			if (this._zoomAnimated) {
				events.zoomanim = this._animateZoom;
			}
			return events;
		},

		// @method isOpen: Boolean
		// Returns `true` when the popup is visible on the map.
		isOpen: function () {
			return !!this._map && this._map.hasLayer(this);
		},

		// @method bringToFront: this
		// Brings this popup in front of other popups (in the same map pane).
		bringToFront: function () {
			if (this._map) {
				toFront(this._container);
			}
			return this;
		},

		// @method bringToBack: this
		// Brings this popup to the back of other popups (in the same map pane).
		bringToBack: function () {
			if (this._map) {
				toBack(this._container);
			}
			return this;
		},

		_updateContent: function () {
			if (!this._content) { return; }

			var node = this._contentNode;
			var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

			if (typeof content === 'string') {
				node.innerHTML = content;
			} else {
				while (node.hasChildNodes()) {
					node.removeChild(node.firstChild);
				}
				node.appendChild(content);
			}
			this.fire('contentupdate');
		},

		_updatePosition: function () {
			if (!this._map) { return; }

			var pos = this._map.latLngToLayerPoint(this._latlng),
			    offset = toPoint(this.options.offset),
			    anchor = this._getAnchor();

			if (this._zoomAnimated) {
				setPosition(this._container, pos.add(anchor));
			} else {
				offset = offset.add(pos).add(anchor);
			}

			var bottom = this._containerBottom = -offset.y,
			    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

			// bottom position the popup in case the height of the popup changes (images loading etc)
			this._container.style.bottom = bottom + 'px';
			this._container.style.left = left + 'px';
		},

		_getAnchor: function () {
			return [0, 0];
		}

	});

	/*
	 * @class Popup
	 * @inherits DivOverlay
	 * @aka L.Popup
	 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
	 * open popups while making sure that only one popup is open at one time
	 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
	 *
	 * @example
	 *
	 * If you want to just bind a popup to marker click and then open it, it's really easy:
	 *
	 * ```js
	 * marker.bindPopup(popupContent).openPopup();
	 * ```
	 * Path overlays like polylines also have a `bindPopup` method.
	 * Here's a more complicated way to open a popup on a map:
	 *
	 * ```js
	 * var popup = L.popup()
	 * 	.setLatLng(latlng)
	 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
	 * 	.openOn(map);
	 * ```
	 */


	// @namespace Popup
	var Popup = DivOverlay.extend({

		// @section
		// @aka Popup options
		options: {
			// @option maxWidth: Number = 300
			// Max width of the popup, in pixels.
			maxWidth: 300,

			// @option minWidth: Number = 50
			// Min width of the popup, in pixels.
			minWidth: 50,

			// @option maxHeight: Number = null
			// If set, creates a scrollable container of the given height
			// inside a popup if its content exceeds it.
			maxHeight: null,

			// @option autoPan: Boolean = true
			// Set it to `false` if you don't want the map to do panning animation
			// to fit the opened popup.
			autoPan: true,

			// @option autoPanPaddingTopLeft: Point = null
			// The margin between the popup and the top left corner of the map
			// view after autopanning was performed.
			autoPanPaddingTopLeft: null,

			// @option autoPanPaddingBottomRight: Point = null
			// The margin between the popup and the bottom right corner of the map
			// view after autopanning was performed.
			autoPanPaddingBottomRight: null,

			// @option autoPanPadding: Point = Point(5, 5)
			// Equivalent of setting both top left and bottom right autopan padding to the same value.
			autoPanPadding: [5, 5],

			// @option keepInView: Boolean = false
			// Set it to `true` if you want to prevent users from panning the popup
			// off of the screen while it is open.
			keepInView: false,

			// @option closeButton: Boolean = true
			// Controls the presence of a close button in the popup.
			closeButton: true,

			// @option autoClose: Boolean = true
			// Set it to `false` if you want to override the default behavior of
			// the popup closing when another popup is opened.
			autoClose: true,

			// @option closeOnEscapeKey: Boolean = true
			// Set it to `false` if you want to override the default behavior of
			// the ESC key for closing of the popup.
			closeOnEscapeKey: true,

			// @option closeOnClick: Boolean = *
			// Set it if you want to override the default behavior of the popup closing when user clicks
			// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

			// @option className: String = ''
			// A custom CSS class name to assign to the popup.
			className: ''
		},

		// @namespace Popup
		// @method openOn(map: Map): this
		// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
		openOn: function (map) {
			map.openPopup(this);
			return this;
		},

		onAdd: function (map) {
			DivOverlay.prototype.onAdd.call(this, map);

			// @namespace Map
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup is opened in the map
			map.fire('popupopen', {popup: this});

			if (this._source) {
				// @namespace Layer
				// @section Popup events
				// @event popupopen: PopupEvent
				// Fired when a popup bound to this layer is opened
				this._source.fire('popupopen', {popup: this}, true);
				// For non-path layers, we toggle the popup when clicking
				// again the layer, so prevent the map to reopen it.
				if (!(this._source instanceof Path)) {
					this._source.on('preclick', stopPropagation);
				}
			}
		},

		onRemove: function (map) {
			DivOverlay.prototype.onRemove.call(this, map);

			// @namespace Map
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup in the map is closed
			map.fire('popupclose', {popup: this});

			if (this._source) {
				// @namespace Layer
				// @section Popup events
				// @event popupclose: PopupEvent
				// Fired when a popup bound to this layer is closed
				this._source.fire('popupclose', {popup: this}, true);
				if (!(this._source instanceof Path)) {
					this._source.off('preclick', stopPropagation);
				}
			}
		},

		getEvents: function () {
			var events = DivOverlay.prototype.getEvents.call(this);

			if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
				events.preclick = this._close;
			}

			if (this.options.keepInView) {
				events.moveend = this._adjustPan;
			}

			return events;
		},

		_close: function () {
			if (this._map) {
				this._map.closePopup(this);
			}
		},

		_initLayout: function () {
			var prefix = 'leaflet-popup',
			    container = this._container = create$1('div',
				prefix + ' ' + (this.options.className || '') +
				' leaflet-zoom-animated');

			var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
			this._contentNode = create$1('div', prefix + '-content', wrapper);

			disableClickPropagation(wrapper);
			disableScrollPropagation(this._contentNode);
			on(wrapper, 'contextmenu', stopPropagation);

			this._tipContainer = create$1('div', prefix + '-tip-container', container);
			this._tip = create$1('div', prefix + '-tip', this._tipContainer);

			if (this.options.closeButton) {
				var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
				closeButton.href = '#close';
				closeButton.innerHTML = '&#215;';

				on(closeButton, 'click', this._onCloseButtonClick, this);
			}
		},

		_updateLayout: function () {
			var container = this._contentNode,
			    style = container.style;

			style.width = '';
			style.whiteSpace = 'nowrap';

			var width = container.offsetWidth;
			width = Math.min(width, this.options.maxWidth);
			width = Math.max(width, this.options.minWidth);

			style.width = (width + 1) + 'px';
			style.whiteSpace = '';

			style.height = '';

			var height = container.offsetHeight,
			    maxHeight = this.options.maxHeight,
			    scrolledClass = 'leaflet-popup-scrolled';

			if (maxHeight && height > maxHeight) {
				style.height = maxHeight + 'px';
				addClass(container, scrolledClass);
			} else {
				removeClass(container, scrolledClass);
			}

			this._containerWidth = this._container.offsetWidth;
		},

		_animateZoom: function (e) {
			var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
			    anchor = this._getAnchor();
			setPosition(this._container, pos.add(anchor));
		},

		_adjustPan: function () {
			if (!this.options.autoPan) { return; }
			if (this._map._panAnim) { this._map._panAnim.stop(); }

			var map = this._map,
			    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
			    containerHeight = this._container.offsetHeight + marginBottom,
			    containerWidth = this._containerWidth,
			    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

			layerPos._add(getPosition(this._container));

			var containerPos = map.layerPointToContainerPoint(layerPos),
			    padding = toPoint(this.options.autoPanPadding),
			    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
			    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
			    size = map.getSize(),
			    dx = 0,
			    dy = 0;

			if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
				dx = containerPos.x + containerWidth - size.x + paddingBR.x;
			}
			if (containerPos.x - dx - paddingTL.x < 0) { // left
				dx = containerPos.x - paddingTL.x;
			}
			if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
				dy = containerPos.y + containerHeight - size.y + paddingBR.y;
			}
			if (containerPos.y - dy - paddingTL.y < 0) { // top
				dy = containerPos.y - paddingTL.y;
			}

			// @namespace Map
			// @section Popup events
			// @event autopanstart: Event
			// Fired when the map starts autopanning when opening a popup.
			if (dx || dy) {
				map
				    .fire('autopanstart')
				    .panBy([dx, dy]);
			}
		},

		_onCloseButtonClick: function (e) {
			this._close();
			stop(e);
		},

		_getAnchor: function () {
			// Where should we anchor the popup on the source layer?
			return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
		}

	});

	// @namespace Popup
	// @factory L.popup(options?: Popup options, source?: Layer)
	// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
	var popup = function (options, source) {
		return new Popup(options, source);
	};


	/* @namespace Map
	 * @section Interaction Options
	 * @option closePopupOnClick: Boolean = true
	 * Set it to `false` if you don't want popups to close when user clicks the map.
	 */
	Map.mergeOptions({
		closePopupOnClick: true
	});


	// @namespace Map
	// @section Methods for Layers and Controls
	Map.include({
		// @method openPopup(popup: Popup): this
		// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
		// @alternative
		// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
		// Creates a popup with the specified content and options and opens it in the given point on a map.
		openPopup: function (popup, latlng, options) {
			if (!(popup instanceof Popup)) {
				popup = new Popup(options).setContent(popup);
			}

			if (latlng) {
				popup.setLatLng(latlng);
			}

			if (this.hasLayer(popup)) {
				return this;
			}

			if (this._popup && this._popup.options.autoClose) {
				this.closePopup();
			}

			this._popup = popup;
			return this.addLayer(popup);
		},

		// @method closePopup(popup?: Popup): this
		// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
		closePopup: function (popup) {
			if (!popup || popup === this._popup) {
				popup = this._popup;
				this._popup = null;
			}
			if (popup) {
				this.removeLayer(popup);
			}
			return this;
		}
	});

	/*
	 * @namespace Layer
	 * @section Popup methods example
	 *
	 * All layers share a set of methods convenient for binding popups to it.
	 *
	 * ```js
	 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
	 * layer.openPopup();
	 * layer.closePopup();
	 * ```
	 *
	 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
	 */

	// @section Popup methods
	Layer.include({

		// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
		// Binds a popup to the layer with the passed `content` and sets up the
		// necessary event listeners. If a `Function` is passed it will receive
		// the layer as the first argument and should return a `String` or `HTMLElement`.
		bindPopup: function (content, options) {

			if (content instanceof Popup) {
				setOptions(content, options);
				this._popup = content;
				content._source = this;
			} else {
				if (!this._popup || options) {
					this._popup = new Popup(options, this);
				}
				this._popup.setContent(content);
			}

			if (!this._popupHandlersAdded) {
				this.on({
					click: this._openPopup,
					keypress: this._onKeyPress,
					remove: this.closePopup,
					move: this._movePopup
				});
				this._popupHandlersAdded = true;
			}

			return this;
		},

		// @method unbindPopup(): this
		// Removes the popup previously bound with `bindPopup`.
		unbindPopup: function () {
			if (this._popup) {
				this.off({
					click: this._openPopup,
					keypress: this._onKeyPress,
					remove: this.closePopup,
					move: this._movePopup
				});
				this._popupHandlersAdded = false;
				this._popup = null;
			}
			return this;
		},

		// @method openPopup(latlng?: LatLng): this
		// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
		openPopup: function (layer, latlng) {
			if (!(layer instanceof Layer)) {
				latlng = layer;
				layer = this;
			}

			if (layer instanceof FeatureGroup) {
				for (var id in this._layers) {
					layer = this._layers[id];
					break;
				}
			}

			if (!latlng) {
				latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
			}

			if (this._popup && this._map) {
				// set popup source to this layer
				this._popup._source = layer;

				// update the popup (content, layout, ect...)
				this._popup.update();

				// open the popup on the map
				this._map.openPopup(this._popup, latlng);
			}

			return this;
		},

		// @method closePopup(): this
		// Closes the popup bound to this layer if it is open.
		closePopup: function () {
			if (this._popup) {
				this._popup._close();
			}
			return this;
		},

		// @method togglePopup(): this
		// Opens or closes the popup bound to this layer depending on its current state.
		togglePopup: function (target) {
			if (this._popup) {
				if (this._popup._map) {
					this.closePopup();
				} else {
					this.openPopup(target);
				}
			}
			return this;
		},

		// @method isPopupOpen(): boolean
		// Returns `true` if the popup bound to this layer is currently open.
		isPopupOpen: function () {
			return (this._popup ? this._popup.isOpen() : false);
		},

		// @method setPopupContent(content: String|HTMLElement|Popup): this
		// Sets the content of the popup bound to this layer.
		setPopupContent: function (content) {
			if (this._popup) {
				this._popup.setContent(content);
			}
			return this;
		},

		// @method getPopup(): Popup
		// Returns the popup bound to this layer.
		getPopup: function () {
			return this._popup;
		},

		_openPopup: function (e) {
			var layer = e.layer || e.target;

			if (!this._popup) {
				return;
			}

			if (!this._map) {
				return;
			}

			// prevent map click
			stop(e);

			// if this inherits from Path its a vector and we can just
			// open the popup at the new location
			if (layer instanceof Path) {
				this.openPopup(e.layer || e.target, e.latlng);
				return;
			}

			// otherwise treat it like a marker and figure out
			// if we should toggle it open/closed
			if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
				this.closePopup();
			} else {
				this.openPopup(layer, e.latlng);
			}
		},

		_movePopup: function (e) {
			this._popup.setLatLng(e.latlng);
		},

		_onKeyPress: function (e) {
			if (e.originalEvent.keyCode === 13) {
				this._openPopup(e);
			}
		}
	});

	/*
	 * @class Tooltip
	 * @inherits DivOverlay
	 * @aka L.Tooltip
	 * Used to display small texts on top of map layers.
	 *
	 * @example
	 *
	 * ```js
	 * marker.bindTooltip("my tooltip text").openTooltip();
	 * ```
	 * Note about tooltip offset. Leaflet takes two options in consideration
	 * for computing tooltip offsetting:
	 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
	 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
	 *   move it to the bottom. Negatives will move to the left and top.
	 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
	 *   should adapt this value if you use a custom icon.
	 */


	// @namespace Tooltip
	var Tooltip = DivOverlay.extend({

		// @section
		// @aka Tooltip options
		options: {
			// @option pane: String = 'tooltipPane'
			// `Map pane` where the tooltip will be added.
			pane: 'tooltipPane',

			// @option offset: Point = Point(0, 0)
			// Optional offset of the tooltip position.
			offset: [0, 0],

			// @option direction: String = 'auto'
			// Direction where to open the tooltip. Possible values are: `right`, `left`,
			// `top`, `bottom`, `center`, `auto`.
			// `auto` will dynamically switch between `right` and `left` according to the tooltip
			// position on the map.
			direction: 'auto',

			// @option permanent: Boolean = false
			// Whether to open the tooltip permanently or only on mouseover.
			permanent: false,

			// @option sticky: Boolean = false
			// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
			sticky: false,

			// @option interactive: Boolean = false
			// If true, the tooltip will listen to the feature events.
			interactive: false,

			// @option opacity: Number = 0.9
			// Tooltip container opacity.
			opacity: 0.9
		},

		onAdd: function (map) {
			DivOverlay.prototype.onAdd.call(this, map);
			this.setOpacity(this.options.opacity);

			// @namespace Map
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip is opened in the map.
			map.fire('tooltipopen', {tooltip: this});

			if (this._source) {
				// @namespace Layer
				// @section Tooltip events
				// @event tooltipopen: TooltipEvent
				// Fired when a tooltip bound to this layer is opened.
				this._source.fire('tooltipopen', {tooltip: this}, true);
			}
		},

		onRemove: function (map) {
			DivOverlay.prototype.onRemove.call(this, map);

			// @namespace Map
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip in the map is closed.
			map.fire('tooltipclose', {tooltip: this});

			if (this._source) {
				// @namespace Layer
				// @section Tooltip events
				// @event tooltipclose: TooltipEvent
				// Fired when a tooltip bound to this layer is closed.
				this._source.fire('tooltipclose', {tooltip: this}, true);
			}
		},

		getEvents: function () {
			var events = DivOverlay.prototype.getEvents.call(this);

			if (touch && !this.options.permanent) {
				events.preclick = this._close;
			}

			return events;
		},

		_close: function () {
			if (this._map) {
				this._map.closeTooltip(this);
			}
		},

		_initLayout: function () {
			var prefix = 'leaflet-tooltip',
			    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

			this._contentNode = this._container = create$1('div', className);
		},

		_updateLayout: function () {},

		_adjustPan: function () {},

		_setPosition: function (pos) {
			var map = this._map,
			    container = this._container,
			    centerPoint = map.latLngToContainerPoint(map.getCenter()),
			    tooltipPoint = map.layerPointToContainerPoint(pos),
			    direction = this.options.direction,
			    tooltipWidth = container.offsetWidth,
			    tooltipHeight = container.offsetHeight,
			    offset = toPoint(this.options.offset),
			    anchor = this._getAnchor();

			if (direction === 'top') {
				pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
			} else if (direction === 'bottom') {
				pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));
			} else if (direction === 'center') {
				pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
			} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
				direction = 'right';
				pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
			} else {
				direction = 'left';
				pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
			}

			removeClass(container, 'leaflet-tooltip-right');
			removeClass(container, 'leaflet-tooltip-left');
			removeClass(container, 'leaflet-tooltip-top');
			removeClass(container, 'leaflet-tooltip-bottom');
			addClass(container, 'leaflet-tooltip-' + direction);
			setPosition(container, pos);
		},

		_updatePosition: function () {
			var pos = this._map.latLngToLayerPoint(this._latlng);
			this._setPosition(pos);
		},

		setOpacity: function (opacity) {
			this.options.opacity = opacity;

			if (this._container) {
				setOpacity(this._container, opacity);
			}
		},

		_animateZoom: function (e) {
			var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
			this._setPosition(pos);
		},

		_getAnchor: function () {
			// Where should we anchor the tooltip on the source layer?
			return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
		}

	});

	// @namespace Tooltip
	// @factory L.tooltip(options?: Tooltip options, source?: Layer)
	// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
	var tooltip = function (options, source) {
		return new Tooltip(options, source);
	};

	// @namespace Map
	// @section Methods for Layers and Controls
	Map.include({

		// @method openTooltip(tooltip: Tooltip): this
		// Opens the specified tooltip.
		// @alternative
		// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
		// Creates a tooltip with the specified content and options and open it.
		openTooltip: function (tooltip, latlng, options) {
			if (!(tooltip instanceof Tooltip)) {
				tooltip = new Tooltip(options).setContent(tooltip);
			}

			if (latlng) {
				tooltip.setLatLng(latlng);
			}

			if (this.hasLayer(tooltip)) {
				return this;
			}

			return this.addLayer(tooltip);
		},

		// @method closeTooltip(tooltip?: Tooltip): this
		// Closes the tooltip given as parameter.
		closeTooltip: function (tooltip) {
			if (tooltip) {
				this.removeLayer(tooltip);
			}
			return this;
		}

	});

	/*
	 * @namespace Layer
	 * @section Tooltip methods example
	 *
	 * All layers share a set of methods convenient for binding tooltips to it.
	 *
	 * ```js
	 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
	 * layer.openTooltip();
	 * layer.closeTooltip();
	 * ```
	 */

	// @section Tooltip methods
	Layer.include({

		// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
		// Binds a tooltip to the layer with the passed `content` and sets up the
		// necessary event listeners. If a `Function` is passed it will receive
		// the layer as the first argument and should return a `String` or `HTMLElement`.
		bindTooltip: function (content, options) {

			if (content instanceof Tooltip) {
				setOptions(content, options);
				this._tooltip = content;
				content._source = this;
			} else {
				if (!this._tooltip || options) {
					this._tooltip = new Tooltip(options, this);
				}
				this._tooltip.setContent(content);

			}

			this._initTooltipInteractions();

			if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
				this.openTooltip();
			}

			return this;
		},

		// @method unbindTooltip(): this
		// Removes the tooltip previously bound with `bindTooltip`.
		unbindTooltip: function () {
			if (this._tooltip) {
				this._initTooltipInteractions(true);
				this.closeTooltip();
				this._tooltip = null;
			}
			return this;
		},

		_initTooltipInteractions: function (remove$$1) {
			if (!remove$$1 && this._tooltipHandlersAdded) { return; }
			var onOff = remove$$1 ? 'off' : 'on',
			    events = {
				remove: this.closeTooltip,
				move: this._moveTooltip
			    };
			if (!this._tooltip.options.permanent) {
				events.mouseover = this._openTooltip;
				events.mouseout = this.closeTooltip;
				if (this._tooltip.options.sticky) {
					events.mousemove = this._moveTooltip;
				}
				if (touch) {
					events.click = this._openTooltip;
				}
			} else {
				events.add = this._openTooltip;
			}
			this[onOff](events);
			this._tooltipHandlersAdded = !remove$$1;
		},

		// @method openTooltip(latlng?: LatLng): this
		// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
		openTooltip: function (layer, latlng) {
			if (!(layer instanceof Layer)) {
				latlng = layer;
				layer = this;
			}

			if (layer instanceof FeatureGroup) {
				for (var id in this._layers) {
					layer = this._layers[id];
					break;
				}
			}

			if (!latlng) {
				latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
			}

			if (this._tooltip && this._map) {

				// set tooltip source to this layer
				this._tooltip._source = layer;

				// update the tooltip (content, layout, ect...)
				this._tooltip.update();

				// open the tooltip on the map
				this._map.openTooltip(this._tooltip, latlng);

				// Tooltip container may not be defined if not permanent and never
				// opened.
				if (this._tooltip.options.interactive && this._tooltip._container) {
					addClass(this._tooltip._container, 'leaflet-clickable');
					this.addInteractiveTarget(this._tooltip._container);
				}
			}

			return this;
		},

		// @method closeTooltip(): this
		// Closes the tooltip bound to this layer if it is open.
		closeTooltip: function () {
			if (this._tooltip) {
				this._tooltip._close();
				if (this._tooltip.options.interactive && this._tooltip._container) {
					removeClass(this._tooltip._container, 'leaflet-clickable');
					this.removeInteractiveTarget(this._tooltip._container);
				}
			}
			return this;
		},

		// @method toggleTooltip(): this
		// Opens or closes the tooltip bound to this layer depending on its current state.
		toggleTooltip: function (target) {
			if (this._tooltip) {
				if (this._tooltip._map) {
					this.closeTooltip();
				} else {
					this.openTooltip(target);
				}
			}
			return this;
		},

		// @method isTooltipOpen(): boolean
		// Returns `true` if the tooltip bound to this layer is currently open.
		isTooltipOpen: function () {
			return this._tooltip.isOpen();
		},

		// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
		// Sets the content of the tooltip bound to this layer.
		setTooltipContent: function (content) {
			if (this._tooltip) {
				this._tooltip.setContent(content);
			}
			return this;
		},

		// @method getTooltip(): Tooltip
		// Returns the tooltip bound to this layer.
		getTooltip: function () {
			return this._tooltip;
		},

		_openTooltip: function (e) {
			var layer = e.layer || e.target;

			if (!this._tooltip || !this._map) {
				return;
			}
			this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
		},

		_moveTooltip: function (e) {
			var latlng = e.latlng, containerPoint, layerPoint;
			if (this._tooltip.options.sticky && e.originalEvent) {
				containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
				layerPoint = this._map.containerPointToLayerPoint(containerPoint);
				latlng = this._map.layerPointToLatLng(layerPoint);
			}
			this._tooltip.setLatLng(latlng);
		}
	});

	/*
	 * @class DivIcon
	 * @aka L.DivIcon
	 * @inherits Icon
	 *
	 * Represents a lightweight icon for markers that uses a simple `<div>`
	 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
	 *
	 * @example
	 * ```js
	 * var myIcon = L.divIcon({className: 'my-div-icon'});
	 * // you can set .my-div-icon styles in CSS
	 *
	 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
	 * ```
	 *
	 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
	 */

	var DivIcon = Icon.extend({
		options: {
			// @section
			// @aka DivIcon options
			iconSize: [12, 12], // also can be set through CSS

			// iconAnchor: (Point),
			// popupAnchor: (Point),

			// @option html: String = ''
			// Custom HTML code to put inside the div element, empty by default.
			html: false,

			// @option bgPos: Point = [0, 0]
			// Optional relative position of the background, in pixels
			bgPos: null,

			className: 'leaflet-div-icon'
		},

		createIcon: function (oldIcon) {
			var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
			    options = this.options;

			div.innerHTML = options.html !== false ? options.html : '';

			if (options.bgPos) {
				var bgPos = toPoint(options.bgPos);
				div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
			}
			this._setIconStyles(div, 'icon');

			return div;
		},

		createShadow: function () {
			return null;
		}
	});

	// @factory L.divIcon(options: DivIcon options)
	// Creates a `DivIcon` instance with the given options.
	function divIcon(options) {
		return new DivIcon(options);
	}

	Icon.Default = IconDefault;

	/*
	 * @class GridLayer
	 * @inherits Layer
	 * @aka L.GridLayer
	 *
	 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
	 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
	 *
	 *
	 * @section Synchronous usage
	 * @example
	 *
	 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
	 *
	 * ```js
	 * var CanvasLayer = L.GridLayer.extend({
	 *     createTile: function(coords){
	 *         // create a <canvas> element for drawing
	 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
	 *
	 *         // setup tile width and height according to the options
	 *         var size = this.getTileSize();
	 *         tile.width = size.x;
	 *         tile.height = size.y;
	 *
	 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
	 *         var ctx = tile.getContext('2d');
	 *
	 *         // return the tile so it can be rendered on screen
	 *         return tile;
	 *     }
	 * });
	 * ```
	 *
	 * @section Asynchronous usage
	 * @example
	 *
	 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
	 *
	 * ```js
	 * var CanvasLayer = L.GridLayer.extend({
	 *     createTile: function(coords, done){
	 *         var error;
	 *
	 *         // create a <canvas> element for drawing
	 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
	 *
	 *         // setup tile width and height according to the options
	 *         var size = this.getTileSize();
	 *         tile.width = size.x;
	 *         tile.height = size.y;
	 *
	 *         // draw something asynchronously and pass the tile to the done() callback
	 *         setTimeout(function() {
	 *             done(error, tile);
	 *         }, 1000);
	 *
	 *         return tile;
	 *     }
	 * });
	 * ```
	 *
	 * @section
	 */


	var GridLayer = Layer.extend({

		// @section
		// @aka GridLayer options
		options: {
			// @option tileSize: Number|Point = 256
			// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
			tileSize: 256,

			// @option opacity: Number = 1.0
			// Opacity of the tiles. Can be used in the `createTile()` function.
			opacity: 1,

			// @option updateWhenIdle: Boolean = (depends)
			// Load new tiles only when panning ends.
			// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
			// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
			// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
			updateWhenIdle: mobile,

			// @option updateWhenZooming: Boolean = true
			// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
			updateWhenZooming: true,

			// @option updateInterval: Number = 200
			// Tiles will not update more than once every `updateInterval` milliseconds when panning.
			updateInterval: 200,

			// @option zIndex: Number = 1
			// The explicit zIndex of the tile layer.
			zIndex: 1,

			// @option bounds: LatLngBounds = undefined
			// If set, tiles will only be loaded inside the set `LatLngBounds`.
			bounds: null,

			// @option minZoom: Number = 0
			// The minimum zoom level down to which this layer will be displayed (inclusive).
			minZoom: 0,

			// @option maxZoom: Number = undefined
			// The maximum zoom level up to which this layer will be displayed (inclusive).
			maxZoom: undefined,

			// @option maxNativeZoom: Number = undefined
			// Maximum zoom number the tile source has available. If it is specified,
			// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
			// from `maxNativeZoom` level and auto-scaled.
			maxNativeZoom: undefined,

			// @option minNativeZoom: Number = undefined
			// Minimum zoom number the tile source has available. If it is specified,
			// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
			// from `minNativeZoom` level and auto-scaled.
			minNativeZoom: undefined,

			// @option noWrap: Boolean = false
			// Whether the layer is wrapped around the antimeridian. If `true`, the
			// GridLayer will only be displayed once at low zoom levels. Has no
			// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
			// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
			// tiles outside the CRS limits.
			noWrap: false,

			// @option pane: String = 'tilePane'
			// `Map pane` where the grid layer will be added.
			pane: 'tilePane',

			// @option className: String = ''
			// A custom class name to assign to the tile layer. Empty by default.
			className: '',

			// @option keepBuffer: Number = 2
			// When panning the map, keep this many rows and columns of tiles before unloading them.
			keepBuffer: 2
		},

		initialize: function (options) {
			setOptions(this, options);
		},

		onAdd: function () {
			this._initContainer();

			this._levels = {};
			this._tiles = {};

			this._resetView();
			this._update();
		},

		beforeAdd: function (map) {
			map._addZoomLimit(this);
		},

		onRemove: function (map) {
			this._removeAllTiles();
			remove(this._container);
			map._removeZoomLimit(this);
			this._container = null;
			this._tileZoom = undefined;
		},

		// @method bringToFront: this
		// Brings the tile layer to the top of all tile layers.
		bringToFront: function () {
			if (this._map) {
				toFront(this._container);
				this._setAutoZIndex(Math.max);
			}
			return this;
		},

		// @method bringToBack: this
		// Brings the tile layer to the bottom of all tile layers.
		bringToBack: function () {
			if (this._map) {
				toBack(this._container);
				this._setAutoZIndex(Math.min);
			}
			return this;
		},

		// @method getContainer: HTMLElement
		// Returns the HTML element that contains the tiles for this layer.
		getContainer: function () {
			return this._container;
		},

		// @method setOpacity(opacity: Number): this
		// Changes the [opacity](#gridlayer-opacity) of the grid layer.
		setOpacity: function (opacity) {
			this.options.opacity = opacity;
			this._updateOpacity();
			return this;
		},

		// @method setZIndex(zIndex: Number): this
		// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
		setZIndex: function (zIndex) {
			this.options.zIndex = zIndex;
			this._updateZIndex();

			return this;
		},

		// @method isLoading: Boolean
		// Returns `true` if any tile in the grid layer has not finished loading.
		isLoading: function () {
			return this._loading;
		},

		// @method redraw: this
		// Causes the layer to clear all the tiles and request them again.
		redraw: function () {
			if (this._map) {
				this._removeAllTiles();
				this._update();
			}
			return this;
		},

		getEvents: function () {
			var events = {
				viewprereset: this._invalidateAll,
				viewreset: this._resetView,
				zoom: this._resetView,
				moveend: this._onMoveEnd
			};

			if (!this.options.updateWhenIdle) {
				// update tiles on move, but not more often than once per given interval
				if (!this._onMove) {
					this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
				}

				events.move = this._onMove;
			}

			if (this._zoomAnimated) {
				events.zoomanim = this._animateZoom;
			}

			return events;
		},

		// @section Extension methods
		// Layers extending `GridLayer` shall reimplement the following method.
		// @method createTile(coords: Object, done?: Function): HTMLElement
		// Called only internally, must be overridden by classes extending `GridLayer`.
		// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
		// is specified, it must be called when the tile has finished loading and drawing.
		createTile: function () {
			return document.createElement('div');
		},

		// @section
		// @method getTileSize: Point
		// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
		getTileSize: function () {
			var s = this.options.tileSize;
			return s instanceof Point ? s : new Point(s, s);
		},

		_updateZIndex: function () {
			if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
				this._container.style.zIndex = this.options.zIndex;
			}
		},

		_setAutoZIndex: function (compare) {
			// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

			var layers = this.getPane().children,
			    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

			for (var i = 0, len = layers.length, zIndex; i < len; i++) {

				zIndex = layers[i].style.zIndex;

				if (layers[i] !== this._container && zIndex) {
					edgeZIndex = compare(edgeZIndex, +zIndex);
				}
			}

			if (isFinite(edgeZIndex)) {
				this.options.zIndex = edgeZIndex + compare(-1, 1);
				this._updateZIndex();
			}
		},

		_updateOpacity: function () {
			if (!this._map) { return; }

			// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
			if (ielt9) { return; }

			setOpacity(this._container, this.options.opacity);

			var now = +new Date(),
			    nextFrame = false,
			    willPrune = false;

			for (var key in this._tiles) {
				var tile = this._tiles[key];
				if (!tile.current || !tile.loaded) { continue; }

				var fade = Math.min(1, (now - tile.loaded) / 200);

				setOpacity(tile.el, fade);
				if (fade < 1) {
					nextFrame = true;
				} else {
					if (tile.active) {
						willPrune = true;
					} else {
						this._onOpaqueTile(tile);
					}
					tile.active = true;
				}
			}

			if (willPrune && !this._noPrune) { this._pruneTiles(); }

			if (nextFrame) {
				cancelAnimFrame(this._fadeFrame);
				this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
			}
		},

		_onOpaqueTile: falseFn,

		_initContainer: function () {
			if (this._container) { return; }

			this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
			this._updateZIndex();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}

			this.getPane().appendChild(this._container);
		},

		_updateLevels: function () {

			var zoom = this._tileZoom,
			    maxZoom = this.options.maxZoom;

			if (zoom === undefined) { return undefined; }

			for (var z in this._levels) {
				if (this._levels[z].el.children.length || z === zoom) {
					this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
					this._onUpdateLevel(z);
				} else {
					remove(this._levels[z].el);
					this._removeTilesAtZoom(z);
					this._onRemoveLevel(z);
					delete this._levels[z];
				}
			}

			var level = this._levels[zoom],
			    map = this._map;

			if (!level) {
				level = this._levels[zoom] = {};

				level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
				level.el.style.zIndex = maxZoom;

				level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
				level.zoom = zoom;

				this._setZoomTransform(level, map.getCenter(), map.getZoom());

				// force the browser to consider the newly added element for transition
				falseFn(level.el.offsetWidth);

				this._onCreateLevel(level);
			}

			this._level = level;

			return level;
		},

		_onUpdateLevel: falseFn,

		_onRemoveLevel: falseFn,

		_onCreateLevel: falseFn,

		_pruneTiles: function () {
			if (!this._map) {
				return;
			}

			var key, tile;

			var zoom = this._map.getZoom();
			if (zoom > this.options.maxZoom ||
				zoom < this.options.minZoom) {
				this._removeAllTiles();
				return;
			}

			for (key in this._tiles) {
				tile = this._tiles[key];
				tile.retain = tile.current;
			}

			for (key in this._tiles) {
				tile = this._tiles[key];
				if (tile.current && !tile.active) {
					var coords = tile.coords;
					if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
						this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
					}
				}
			}

			for (key in this._tiles) {
				if (!this._tiles[key].retain) {
					this._removeTile(key);
				}
			}
		},

		_removeTilesAtZoom: function (zoom) {
			for (var key in this._tiles) {
				if (this._tiles[key].coords.z !== zoom) {
					continue;
				}
				this._removeTile(key);
			}
		},

		_removeAllTiles: function () {
			for (var key in this._tiles) {
				this._removeTile(key);
			}
		},

		_invalidateAll: function () {
			for (var z in this._levels) {
				remove(this._levels[z].el);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
			this._removeAllTiles();

			this._tileZoom = undefined;
		},

		_retainParent: function (x, y, z, minZoom) {
			var x2 = Math.floor(x / 2),
			    y2 = Math.floor(y / 2),
			    z2 = z - 1,
			    coords2 = new Point(+x2, +y2);
			coords2.z = +z2;

			var key = this._tileCoordsToKey(coords2),
			    tile = this._tiles[key];

			if (tile && tile.active) {
				tile.retain = true;
				return true;

			} else if (tile && tile.loaded) {
				tile.retain = true;
			}

			if (z2 > minZoom) {
				return this._retainParent(x2, y2, z2, minZoom);
			}

			return false;
		},

		_retainChildren: function (x, y, z, maxZoom) {

			for (var i = 2 * x; i < 2 * x + 2; i++) {
				for (var j = 2 * y; j < 2 * y + 2; j++) {

					var coords = new Point(i, j);
					coords.z = z + 1;

					var key = this._tileCoordsToKey(coords),
					    tile = this._tiles[key];

					if (tile && tile.active) {
						tile.retain = true;
						continue;

					} else if (tile && tile.loaded) {
						tile.retain = true;
					}

					if (z + 1 < maxZoom) {
						this._retainChildren(i, j, z + 1, maxZoom);
					}
				}
			}
		},

		_resetView: function (e) {
			var animating = e && (e.pinch || e.flyTo);
			this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
		},

		_animateZoom: function (e) {
			this._setView(e.center, e.zoom, true, e.noUpdate);
		},

		_clampZoom: function (zoom) {
			var options = this.options;

			if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
				return options.minNativeZoom;
			}

			if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
				return options.maxNativeZoom;
			}

			return zoom;
		},

		_setView: function (center, zoom, noPrune, noUpdate) {
			var tileZoom = this._clampZoom(Math.round(zoom));
			if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
			    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
				tileZoom = undefined;
			}

			var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

			if (!noUpdate || tileZoomChanged) {

				this._tileZoom = tileZoom;

				if (this._abortLoading) {
					this._abortLoading();
				}

				this._updateLevels();
				this._resetGrid();

				if (tileZoom !== undefined) {
					this._update(center);
				}

				if (!noPrune) {
					this._pruneTiles();
				}

				// Flag to prevent _updateOpacity from pruning tiles during
				// a zoom anim or a pinch gesture
				this._noPrune = !!noPrune;
			}

			this._setZoomTransforms(center, zoom);
		},

		_setZoomTransforms: function (center, zoom) {
			for (var i in this._levels) {
				this._setZoomTransform(this._levels[i], center, zoom);
			}
		},

		_setZoomTransform: function (level, center, zoom) {
			var scale = this._map.getZoomScale(zoom, level.zoom),
			    translate = level.origin.multiplyBy(scale)
			        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

			if (any3d) {
				setTransform(level.el, translate, scale);
			} else {
				setPosition(level.el, translate);
			}
		},

		_resetGrid: function () {
			var map = this._map,
			    crs = map.options.crs,
			    tileSize = this._tileSize = this.getTileSize(),
			    tileZoom = this._tileZoom;

			var bounds = this._map.getPixelWorldBounds(this._tileZoom);
			if (bounds) {
				this._globalTileRange = this._pxBoundsToTileRange(bounds);
			}

			this._wrapX = crs.wrapLng && !this.options.noWrap && [
				Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
				Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
			];
			this._wrapY = crs.wrapLat && !this.options.noWrap && [
				Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
				Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
			];
		},

		_onMoveEnd: function () {
			if (!this._map || this._map._animatingZoom) { return; }

			this._update();
		},

		_getTiledPixelBounds: function (center) {
			var map = this._map,
			    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
			    scale = map.getZoomScale(mapZoom, this._tileZoom),
			    pixelCenter = map.project(center, this._tileZoom).floor(),
			    halfSize = map.getSize().divideBy(scale * 2);

			return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
		},

		// Private method to load tiles in the grid's active zoom level according to map bounds
		_update: function (center) {
			var map = this._map;
			if (!map) { return; }
			var zoom = this._clampZoom(map.getZoom());

			if (center === undefined) { center = map.getCenter(); }
			if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

			var pixelBounds = this._getTiledPixelBounds(center),
			    tileRange = this._pxBoundsToTileRange(pixelBounds),
			    tileCenter = tileRange.getCenter(),
			    queue = [],
			    margin = this.options.keepBuffer,
			    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
			                              tileRange.getTopRight().add([margin, -margin]));

			// Sanity check: panic if the tile range contains Infinity somewhere.
			if (!(isFinite(tileRange.min.x) &&
			      isFinite(tileRange.min.y) &&
			      isFinite(tileRange.max.x) &&
			      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

			for (var key in this._tiles) {
				var c = this._tiles[key].coords;
				if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
					this._tiles[key].current = false;
				}
			}

			// _update just loads more tiles. If the tile zoom level differs too much
			// from the map's, let _setView reset levels and prune old tiles.
			if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

			// create a queue of coordinates to load tiles from
			for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
				for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
					var coords = new Point(i, j);
					coords.z = this._tileZoom;

					if (!this._isValidTile(coords)) { continue; }

					var tile = this._tiles[this._tileCoordsToKey(coords)];
					if (tile) {
						tile.current = true;
					} else {
						queue.push(coords);
					}
				}
			}

			// sort tile queue to load tiles in order of their distance to center
			queue.sort(function (a, b) {
				return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
			});

			if (queue.length !== 0) {
				// if it's the first batch of tiles to load
				if (!this._loading) {
					this._loading = true;
					// @event loading: Event
					// Fired when the grid layer starts loading tiles.
					this.fire('loading');
				}

				// create DOM fragment to append tiles in one batch
				var fragment = document.createDocumentFragment();

				for (i = 0; i < queue.length; i++) {
					this._addTile(queue[i], fragment);
				}

				this._level.el.appendChild(fragment);
			}
		},

		_isValidTile: function (coords) {
			var crs = this._map.options.crs;

			if (!crs.infinite) {
				// don't load tile if it's out of bounds and not wrapped
				var bounds = this._globalTileRange;
				if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
				    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
			}

			if (!this.options.bounds) { return true; }

			// don't load tile if it doesn't intersect the bounds in options
			var tileBounds = this._tileCoordsToBounds(coords);
			return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
		},

		_keyToBounds: function (key) {
			return this._tileCoordsToBounds(this._keyToTileCoords(key));
		},

		_tileCoordsToNwSe: function (coords) {
			var map = this._map,
			    tileSize = this.getTileSize(),
			    nwPoint = coords.scaleBy(tileSize),
			    sePoint = nwPoint.add(tileSize),
			    nw = map.unproject(nwPoint, coords.z),
			    se = map.unproject(sePoint, coords.z);
			return [nw, se];
		},

		// converts tile coordinates to its geographical bounds
		_tileCoordsToBounds: function (coords) {
			var bp = this._tileCoordsToNwSe(coords),
			    bounds = new LatLngBounds(bp[0], bp[1]);

			if (!this.options.noWrap) {
				bounds = this._map.wrapLatLngBounds(bounds);
			}
			return bounds;
		},
		// converts tile coordinates to key for the tile cache
		_tileCoordsToKey: function (coords) {
			return coords.x + ':' + coords.y + ':' + coords.z;
		},

		// converts tile cache key to coordinates
		_keyToTileCoords: function (key) {
			var k = key.split(':'),
			    coords = new Point(+k[0], +k[1]);
			coords.z = +k[2];
			return coords;
		},

		_removeTile: function (key) {
			var tile = this._tiles[key];
			if (!tile) { return; }

			remove(tile.el);

			delete this._tiles[key];

			// @event tileunload: TileEvent
			// Fired when a tile is removed (e.g. when a tile goes off the screen).
			this.fire('tileunload', {
				tile: tile.el,
				coords: this._keyToTileCoords(key)
			});
		},

		_initTile: function (tile) {
			addClass(tile, 'leaflet-tile');

			var tileSize = this.getTileSize();
			tile.style.width = tileSize.x + 'px';
			tile.style.height = tileSize.y + 'px';

			tile.onselectstart = falseFn;
			tile.onmousemove = falseFn;

			// update opacity on tiles in IE7-8 because of filter inheritance problems
			if (ielt9 && this.options.opacity < 1) {
				setOpacity(tile, this.options.opacity);
			}

			// without this hack, tiles disappear after zoom on Chrome for Android
			// https://github.com/Leaflet/Leaflet/issues/2078
			if (android && !android23) {
				tile.style.WebkitBackfaceVisibility = 'hidden';
			}
		},

		_addTile: function (coords, container) {
			var tilePos = this._getTilePos(coords),
			    key = this._tileCoordsToKey(coords);

			var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

			this._initTile(tile);

			// if createTile is defined with a second argument ("done" callback),
			// we know that tile is async and will be ready later; otherwise
			if (this.createTile.length < 2) {
				// mark tile as ready, but delay one frame for opacity animation to happen
				requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
			}

			setPosition(tile, tilePos);

			// save tile in cache
			this._tiles[key] = {
				el: tile,
				coords: coords,
				current: true
			};

			container.appendChild(tile);
			// @event tileloadstart: TileEvent
			// Fired when a tile is requested and starts loading.
			this.fire('tileloadstart', {
				tile: tile,
				coords: coords
			});
		},

		_tileReady: function (coords, err, tile) {
			if (err) {
				// @event tileerror: TileErrorEvent
				// Fired when there is an error loading a tile.
				this.fire('tileerror', {
					error: err,
					tile: tile,
					coords: coords
				});
			}

			var key = this._tileCoordsToKey(coords);

			tile = this._tiles[key];
			if (!tile) { return; }

			tile.loaded = +new Date();
			if (this._map._fadeAnimated) {
				setOpacity(tile.el, 0);
				cancelAnimFrame(this._fadeFrame);
				this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
			} else {
				tile.active = true;
				this._pruneTiles();
			}

			if (!err) {
				addClass(tile.el, 'leaflet-tile-loaded');

				// @event tileload: TileEvent
				// Fired when a tile loads.
				this.fire('tileload', {
					tile: tile.el,
					coords: coords
				});
			}

			if (this._noTilesToLoad()) {
				this._loading = false;
				// @event load: Event
				// Fired when the grid layer loaded all visible tiles.
				this.fire('load');

				if (ielt9 || !this._map._fadeAnimated) {
					requestAnimFrame(this._pruneTiles, this);
				} else {
					// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
					// to trigger a pruning.
					setTimeout(bind(this._pruneTiles, this), 250);
				}
			}
		},

		_getTilePos: function (coords) {
			return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
		},

		_wrapCoords: function (coords) {
			var newCoords = new Point(
				this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
				this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
			newCoords.z = coords.z;
			return newCoords;
		},

		_pxBoundsToTileRange: function (bounds) {
			var tileSize = this.getTileSize();
			return new Bounds(
				bounds.min.unscaleBy(tileSize).floor(),
				bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
		},

		_noTilesToLoad: function () {
			for (var key in this._tiles) {
				if (!this._tiles[key].loaded) { return false; }
			}
			return true;
		}
	});

	// @factory L.gridLayer(options?: GridLayer options)
	// Creates a new instance of GridLayer with the supplied options.
	function gridLayer(options) {
		return new GridLayer(options);
	}

	/*
	 * @class TileLayer
	 * @inherits GridLayer
	 * @aka L.TileLayer
	 * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
	 *
	 * @example
	 *
	 * ```js
	 * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'}).addTo(map);
	 * ```
	 *
	 * @section URL template
	 * @example
	 *
	 * A string of the following form:
	 *
	 * ```
	 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
	 * ```
	 *
	 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
	 *
	 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
	 *
	 * ```
	 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
	 * ```
	 */


	var TileLayer = GridLayer.extend({

		// @section
		// @aka TileLayer options
		options: {
			// @option minZoom: Number = 0
			// The minimum zoom level down to which this layer will be displayed (inclusive).
			minZoom: 0,

			// @option maxZoom: Number = 18
			// The maximum zoom level up to which this layer will be displayed (inclusive).
			maxZoom: 18,

			// @option subdomains: String|String[] = 'abc'
			// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
			subdomains: 'abc',

			// @option errorTileUrl: String = ''
			// URL to the tile image to show in place of the tile that failed to load.
			errorTileUrl: '',

			// @option zoomOffset: Number = 0
			// The zoom number used in tile URLs will be offset with this value.
			zoomOffset: 0,

			// @option tms: Boolean = false
			// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
			tms: false,

			// @option zoomReverse: Boolean = false
			// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
			zoomReverse: false,

			// @option detectRetina: Boolean = false
			// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
			detectRetina: false,

			// @option crossOrigin: Boolean|String = false
			// Whether the crossOrigin attribute will be added to the tiles.
			// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
			// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
			crossOrigin: false
		},

		initialize: function (url, options) {

			this._url = url;

			options = setOptions(this, options);

			// detecting retina displays, adjusting tileSize and zoom levels
			if (options.detectRetina && retina && options.maxZoom > 0) {

				options.tileSize = Math.floor(options.tileSize / 2);

				if (!options.zoomReverse) {
					options.zoomOffset++;
					options.maxZoom--;
				} else {
					options.zoomOffset--;
					options.minZoom++;
				}

				options.minZoom = Math.max(0, options.minZoom);
			}

			if (typeof options.subdomains === 'string') {
				options.subdomains = options.subdomains.split('');
			}

			// for https://github.com/Leaflet/Leaflet/issues/137
			if (!android) {
				this.on('tileunload', this._onTileRemove);
			}
		},

		// @method setUrl(url: String, noRedraw?: Boolean): this
		// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
		// If the URL does not change, the layer will not be redrawn unless
		// the noRedraw parameter is set to false.
		setUrl: function (url, noRedraw) {
			if (this._url === url && noRedraw === undefined) {
				noRedraw = true;
			}

			this._url = url;

			if (!noRedraw) {
				this.redraw();
			}
			return this;
		},

		// @method createTile(coords: Object, done?: Function): HTMLElement
		// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
		// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
		// callback is called when the tile has been loaded.
		createTile: function (coords, done) {
			var tile = document.createElement('img');

			on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
			on(tile, 'error', bind(this._tileOnError, this, done, tile));

			if (this.options.crossOrigin || this.options.crossOrigin === '') {
				tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
			}

			/*
			 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
			 http://www.w3.org/TR/WCAG20-TECHS/H67
			*/
			tile.alt = '';

			/*
			 Set role="presentation" to force screen readers to ignore this
			 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
			*/
			tile.setAttribute('role', 'presentation');

			tile.src = this.getTileUrl(coords);

			return tile;
		},

		// @section Extension methods
		// @uninheritable
		// Layers extending `TileLayer` might reimplement the following method.
		// @method getTileUrl(coords: Object): String
		// Called only internally, returns the URL for a tile given its coordinates.
		// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
		getTileUrl: function (coords) {
			var data = {
				r: retina ? '@2x' : '',
				s: this._getSubdomain(coords),
				x: coords.x,
				y: coords.y,
				z: this._getZoomForUrl()
			};
			if (this._map && !this._map.options.crs.infinite) {
				var invertedY = this._globalTileRange.max.y - coords.y;
				if (this.options.tms) {
					data['y'] = invertedY;
				}
				data['-y'] = invertedY;
			}

			return template(this._url, extend(data, this.options));
		},

		_tileOnLoad: function (done, tile) {
			// For https://github.com/Leaflet/Leaflet/issues/3332
			if (ielt9) {
				setTimeout(bind(done, this, null, tile), 0);
			} else {
				done(null, tile);
			}
		},

		_tileOnError: function (done, tile, e) {
			var errorUrl = this.options.errorTileUrl;
			if (errorUrl && tile.getAttribute('src') !== errorUrl) {
				tile.src = errorUrl;
			}
			done(e, tile);
		},

		_onTileRemove: function (e) {
			e.tile.onload = null;
		},

		_getZoomForUrl: function () {
			var zoom = this._tileZoom,
			maxZoom = this.options.maxZoom,
			zoomReverse = this.options.zoomReverse,
			zoomOffset = this.options.zoomOffset;

			if (zoomReverse) {
				zoom = maxZoom - zoom;
			}

			return zoom + zoomOffset;
		},

		_getSubdomain: function (tilePoint) {
			var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
			return this.options.subdomains[index];
		},

		// stops loading all tiles in the background layer
		_abortLoading: function () {
			var i, tile;
			for (i in this._tiles) {
				if (this._tiles[i].coords.z !== this._tileZoom) {
					tile = this._tiles[i].el;

					tile.onload = falseFn;
					tile.onerror = falseFn;

					if (!tile.complete) {
						tile.src = emptyImageUrl;
						remove(tile);
						delete this._tiles[i];
					}
				}
			}
		},

		_removeTile: function (key) {
			var tile = this._tiles[key];
			if (!tile) { return; }

			// Cancels any pending http requests associated with the tile
			// unless we're on Android's stock browser,
			// see https://github.com/Leaflet/Leaflet/issues/137
			if (!androidStock) {
				tile.el.setAttribute('src', emptyImageUrl);
			}

			return GridLayer.prototype._removeTile.call(this, key);
		},

		_tileReady: function (coords, err, tile) {
			if (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {
				return;
			}

			return GridLayer.prototype._tileReady.call(this, coords, err, tile);
		}
	});


	// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
	// Instantiates a tile layer object given a `URL template` and optionally an options object.

	function tileLayer(url, options) {
		return new TileLayer(url, options);
	}

	/*
	 * @class TileLayer.WMS
	 * @inherits TileLayer
	 * @aka L.TileLayer.WMS
	 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
	 *
	 * @example
	 *
	 * ```js
	 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
	 * 	layers: 'nexrad-n0r-900913',
	 * 	format: 'image/png',
	 * 	transparent: true,
	 * 	attribution: "Weather data © 2012 IEM Nexrad"
	 * });
	 * ```
	 */

	var TileLayerWMS = TileLayer.extend({

		// @section
		// @aka TileLayer.WMS options
		// If any custom options not documented here are used, they will be sent to the
		// WMS server as extra parameters in each request URL. This can be useful for
		// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
		defaultWmsParams: {
			service: 'WMS',
			request: 'GetMap',

			// @option layers: String = ''
			// **(required)** Comma-separated list of WMS layers to show.
			layers: '',

			// @option styles: String = ''
			// Comma-separated list of WMS styles.
			styles: '',

			// @option format: String = 'image/jpeg'
			// WMS image format (use `'image/png'` for layers with transparency).
			format: 'image/jpeg',

			// @option transparent: Boolean = false
			// If `true`, the WMS service will return images with transparency.
			transparent: false,

			// @option version: String = '1.1.1'
			// Version of the WMS service to use
			version: '1.1.1'
		},

		options: {
			// @option crs: CRS = null
			// Coordinate Reference System to use for the WMS requests, defaults to
			// map CRS. Don't change this if you're not sure what it means.
			crs: null,

			// @option uppercase: Boolean = false
			// If `true`, WMS request parameter keys will be uppercase.
			uppercase: false
		},

		initialize: function (url, options) {

			this._url = url;

			var wmsParams = extend({}, this.defaultWmsParams);

			// all keys that are not TileLayer options go to WMS params
			for (var i in options) {
				if (!(i in this.options)) {
					wmsParams[i] = options[i];
				}
			}

			options = setOptions(this, options);

			var realRetina = options.detectRetina && retina ? 2 : 1;
			var tileSize = this.getTileSize();
			wmsParams.width = tileSize.x * realRetina;
			wmsParams.height = tileSize.y * realRetina;

			this.wmsParams = wmsParams;
		},

		onAdd: function (map) {

			this._crs = this.options.crs || map.options.crs;
			this._wmsVersion = parseFloat(this.wmsParams.version);

			var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
			this.wmsParams[projectionKey] = this._crs.code;

			TileLayer.prototype.onAdd.call(this, map);
		},

		getTileUrl: function (coords) {

			var tileBounds = this._tileCoordsToNwSe(coords),
			    crs = this._crs,
			    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
			    min = bounds.min,
			    max = bounds.max,
			    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
			    [min.y, min.x, max.y, max.x] :
			    [min.x, min.y, max.x, max.y]).join(','),
			    url = TileLayer.prototype.getTileUrl.call(this, coords);
			return url +
				getParamString(this.wmsParams, url, this.options.uppercase) +
				(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
		},

		// @method setParams(params: Object, noRedraw?: Boolean): this
		// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
		setParams: function (params, noRedraw) {

			extend(this.wmsParams, params);

			if (!noRedraw) {
				this.redraw();
			}

			return this;
		}
	});


	// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
	// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
	function tileLayerWMS(url, options) {
		return new TileLayerWMS(url, options);
	}

	TileLayer.WMS = TileLayerWMS;
	tileLayer.wms = tileLayerWMS;

	/*
	 * @class Renderer
	 * @inherits Layer
	 * @aka L.Renderer
	 *
	 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
	 * DOM container of the renderer, its bounds, and its zoom animation.
	 *
	 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
	 * itself can be added or removed to the map. All paths use a renderer, which can
	 * be implicit (the map will decide the type of renderer and use it automatically)
	 * or explicit (using the [`renderer`](#path-renderer) option of the path).
	 *
	 * Do not use this class directly, use `SVG` and `Canvas` instead.
	 *
	 * @event update: Event
	 * Fired when the renderer updates its bounds, center and zoom, for example when
	 * its map has moved
	 */

	var Renderer = Layer.extend({

		// @section
		// @aka Renderer options
		options: {
			// @option padding: Number = 0.1
			// How much to extend the clip area around the map view (relative to its size)
			// e.g. 0.1 would be 10% of map view in each direction
			padding: 0.1,

			// @option tolerance: Number = 0
			// How much to extend click tolerance round a path/object on the map
			tolerance : 0
		},

		initialize: function (options) {
			setOptions(this, options);
			stamp(this);
			this._layers = this._layers || {};
		},

		onAdd: function () {
			if (!this._container) {
				this._initContainer(); // defined by renderer implementations

				if (this._zoomAnimated) {
					addClass(this._container, 'leaflet-zoom-animated');
				}
			}

			this.getPane().appendChild(this._container);
			this._update();
			this.on('update', this._updatePaths, this);
		},

		onRemove: function () {
			this.off('update', this._updatePaths, this);
			this._destroyContainer();
		},

		getEvents: function () {
			var events = {
				viewreset: this._reset,
				zoom: this._onZoom,
				moveend: this._update,
				zoomend: this._onZoomEnd
			};
			if (this._zoomAnimated) {
				events.zoomanim = this._onAnimZoom;
			}
			return events;
		},

		_onAnimZoom: function (ev) {
			this._updateTransform(ev.center, ev.zoom);
		},

		_onZoom: function () {
			this._updateTransform(this._map.getCenter(), this._map.getZoom());
		},

		_updateTransform: function (center, zoom) {
			var scale = this._map.getZoomScale(zoom, this._zoom),
			    position = getPosition(this._container),
			    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
			    currentCenterPoint = this._map.project(this._center, zoom),
			    destCenterPoint = this._map.project(center, zoom),
			    centerOffset = destCenterPoint.subtract(currentCenterPoint),

			    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

			if (any3d) {
				setTransform(this._container, topLeftOffset, scale);
			} else {
				setPosition(this._container, topLeftOffset);
			}
		},

		_reset: function () {
			this._update();
			this._updateTransform(this._center, this._zoom);

			for (var id in this._layers) {
				this._layers[id]._reset();
			}
		},

		_onZoomEnd: function () {
			for (var id in this._layers) {
				this._layers[id]._project();
			}
		},

		_updatePaths: function () {
			for (var id in this._layers) {
				this._layers[id]._update();
			}
		},

		_update: function () {
			// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
			// Subclasses are responsible of firing the 'update' event.
			var p = this.options.padding,
			    size = this._map.getSize(),
			    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

			this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

			this._center = this._map.getCenter();
			this._zoom = this._map.getZoom();
		}
	});

	/*
	 * @class Canvas
	 * @inherits Renderer
	 * @aka L.Canvas
	 *
	 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
	 * Inherits `Renderer`.
	 *
	 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
	 * available in all web browsers, notably IE8, and overlapping geometries might
	 * not display properly in some edge cases.
	 *
	 * @example
	 *
	 * Use Canvas by default for all paths in the map:
	 *
	 * ```js
	 * var map = L.map('map', {
	 * 	renderer: L.canvas()
	 * });
	 * ```
	 *
	 * Use a Canvas renderer with extra padding for specific vector geometries:
	 *
	 * ```js
	 * var map = L.map('map');
	 * var myRenderer = L.canvas({ padding: 0.5 });
	 * var line = L.polyline( coordinates, { renderer: myRenderer } );
	 * var circle = L.circle( center, { renderer: myRenderer } );
	 * ```
	 */

	var Canvas = Renderer.extend({
		getEvents: function () {
			var events = Renderer.prototype.getEvents.call(this);
			events.viewprereset = this._onViewPreReset;
			return events;
		},

		_onViewPreReset: function () {
			// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
			this._postponeUpdatePaths = true;
		},

		onAdd: function () {
			Renderer.prototype.onAdd.call(this);

			// Redraw vectors since canvas is cleared upon removal,
			// in case of removing the renderer itself from the map.
			this._draw();
		},

		_initContainer: function () {
			var container = this._container = document.createElement('canvas');

			on(container, 'mousemove', throttle(this._onMouseMove, 32, this), this);
			on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
			on(container, 'mouseout', this._handleMouseOut, this);

			this._ctx = container.getContext('2d');
		},

		_destroyContainer: function () {
			cancelAnimFrame(this._redrawRequest);
			delete this._ctx;
			remove(this._container);
			off(this._container);
			delete this._container;
		},

		_updatePaths: function () {
			if (this._postponeUpdatePaths) { return; }

			var layer;
			this._redrawBounds = null;
			for (var id in this._layers) {
				layer = this._layers[id];
				layer._update();
			}
			this._redraw();
		},

		_update: function () {
			if (this._map._animatingZoom && this._bounds) { return; }

			Renderer.prototype._update.call(this);

			var b = this._bounds,
			    container = this._container,
			    size = b.getSize(),
			    m = retina ? 2 : 1;

			setPosition(container, b.min);

			// set canvas size (also clearing it); use double size on retina
			container.width = m * size.x;
			container.height = m * size.y;
			container.style.width = size.x + 'px';
			container.style.height = size.y + 'px';

			if (retina) {
				this._ctx.scale(2, 2);
			}

			// translate so we use the same path coordinates after canvas element moves
			this._ctx.translate(-b.min.x, -b.min.y);

			// Tell paths to redraw themselves
			this.fire('update');
		},

		_reset: function () {
			Renderer.prototype._reset.call(this);

			if (this._postponeUpdatePaths) {
				this._postponeUpdatePaths = false;
				this._updatePaths();
			}
		},

		_initPath: function (layer) {
			this._updateDashArray(layer);
			this._layers[stamp(layer)] = layer;

			var order = layer._order = {
				layer: layer,
				prev: this._drawLast,
				next: null
			};
			if (this._drawLast) { this._drawLast.next = order; }
			this._drawLast = order;
			this._drawFirst = this._drawFirst || this._drawLast;
		},

		_addPath: function (layer) {
			this._requestRedraw(layer);
		},

		_removePath: function (layer) {
			var order = layer._order;
			var next = order.next;
			var prev = order.prev;

			if (next) {
				next.prev = prev;
			} else {
				this._drawLast = prev;
			}
			if (prev) {
				prev.next = next;
			} else {
				this._drawFirst = next;
			}

			delete layer._order;

			delete this._layers[stamp(layer)];

			this._requestRedraw(layer);
		},

		_updatePath: function (layer) {
			// Redraw the union of the layer's old pixel
			// bounds and the new pixel bounds.
			this._extendRedrawBounds(layer);
			layer._project();
			layer._update();
			// The redraw will extend the redraw bounds
			// with the new pixel bounds.
			this._requestRedraw(layer);
		},

		_updateStyle: function (layer) {
			this._updateDashArray(layer);
			this._requestRedraw(layer);
		},

		_updateDashArray: function (layer) {
			if (typeof layer.options.dashArray === 'string') {
				var parts = layer.options.dashArray.split(/[, ]+/),
				    dashArray = [],
				    dashValue,
				    i;
				for (i = 0; i < parts.length; i++) {
					dashValue = Number(parts[i]);
					// Ignore dash array containing invalid lengths
					if (isNaN(dashValue)) { return; }
					dashArray.push(dashValue);
				}
				layer.options._dashArray = dashArray;
			} else {
				layer.options._dashArray = layer.options.dashArray;
			}
		},

		_requestRedraw: function (layer) {
			if (!this._map) { return; }

			this._extendRedrawBounds(layer);
			this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
		},

		_extendRedrawBounds: function (layer) {
			if (layer._pxBounds) {
				var padding = (layer.options.weight || 0) + 1;
				this._redrawBounds = this._redrawBounds || new Bounds();
				this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
				this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
			}
		},

		_redraw: function () {
			this._redrawRequest = null;

			if (this._redrawBounds) {
				this._redrawBounds.min._floor();
				this._redrawBounds.max._ceil();
			}

			this._clear(); // clear layers in redraw bounds
			this._draw(); // draw layers

			this._redrawBounds = null;
		},

		_clear: function () {
			var bounds = this._redrawBounds;
			if (bounds) {
				var size = bounds.getSize();
				this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
			} else {
				this._ctx.clearRect(0, 0, this._container.width, this._container.height);
			}
		},

		_draw: function () {
			var layer, bounds = this._redrawBounds;
			this._ctx.save();
			if (bounds) {
				var size = bounds.getSize();
				this._ctx.beginPath();
				this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
				this._ctx.clip();
			}

			this._drawing = true;

			for (var order = this._drawFirst; order; order = order.next) {
				layer = order.layer;
				if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
					layer._updatePath();
				}
			}

			this._drawing = false;

			this._ctx.restore();  // Restore state before clipping.
		},

		_updatePoly: function (layer, closed) {
			if (!this._drawing) { return; }

			var i, j, len2, p,
			    parts = layer._parts,
			    len = parts.length,
			    ctx = this._ctx;

			if (!len) { return; }

			ctx.beginPath();

			for (i = 0; i < len; i++) {
				for (j = 0, len2 = parts[i].length; j < len2; j++) {
					p = parts[i][j];
					ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
				}
				if (closed) {
					ctx.closePath();
				}
			}

			this._fillStroke(ctx, layer);

			// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
		},

		_updateCircle: function (layer) {

			if (!this._drawing || layer._empty()) { return; }

			var p = layer._point,
			    ctx = this._ctx,
			    r = Math.max(Math.round(layer._radius), 1),
			    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

			if (s !== 1) {
				ctx.save();
				ctx.scale(1, s);
			}

			ctx.beginPath();
			ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

			if (s !== 1) {
				ctx.restore();
			}

			this._fillStroke(ctx, layer);
		},

		_fillStroke: function (ctx, layer) {
			var options = layer.options;

			if (options.fill) {
				ctx.globalAlpha = options.fillOpacity;
				ctx.fillStyle = options.fillColor || options.color;
				ctx.fill(options.fillRule || 'evenodd');
			}

			if (options.stroke && options.weight !== 0) {
				if (ctx.setLineDash) {
					ctx.setLineDash(layer.options && layer.options._dashArray || []);
				}
				ctx.globalAlpha = options.opacity;
				ctx.lineWidth = options.weight;
				ctx.strokeStyle = options.color;
				ctx.lineCap = options.lineCap;
				ctx.lineJoin = options.lineJoin;
				ctx.stroke();
			}
		},

		// Canvas obviously doesn't have mouse events for individual drawn objects,
		// so we emulate that by calculating what's under the mouse on mousemove/click manually

		_onClick: function (e) {
			var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

			for (var order = this._drawFirst; order; order = order.next) {
				layer = order.layer;
				if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
					clickedLayer = layer;
				}
			}
			if (clickedLayer)  {
				fakeStop(e);
				this._fireEvent([clickedLayer], e);
			}
		},

		_onMouseMove: function (e) {
			if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

			var point = this._map.mouseEventToLayerPoint(e);
			this._handleMouseHover(e, point);
		},


		_handleMouseOut: function (e) {
			var layer = this._hoveredLayer;
			if (layer) {
				// if we're leaving the layer, fire mouseout
				removeClass(this._container, 'leaflet-interactive');
				this._fireEvent([layer], e, 'mouseout');
				this._hoveredLayer = null;
			}
		},

		_handleMouseHover: function (e, point) {
			var layer, candidateHoveredLayer;

			for (var order = this._drawFirst; order; order = order.next) {
				layer = order.layer;
				if (layer.options.interactive && layer._containsPoint(point)) {
					candidateHoveredLayer = layer;
				}
			}

			if (candidateHoveredLayer !== this._hoveredLayer) {
				this._handleMouseOut(e);

				if (candidateHoveredLayer) {
					addClass(this._container, 'leaflet-interactive'); // change cursor
					this._fireEvent([candidateHoveredLayer], e, 'mouseover');
					this._hoveredLayer = candidateHoveredLayer;
				}
			}

			if (this._hoveredLayer) {
				this._fireEvent([this._hoveredLayer], e);
			}
		},

		_fireEvent: function (layers, e, type) {
			this._map._fireDOMEvent(e, type || e.type, layers);
		},

		_bringToFront: function (layer) {
			var order = layer._order;

			if (!order) { return; }

			var next = order.next;
			var prev = order.prev;

			if (next) {
				next.prev = prev;
			} else {
				// Already last
				return;
			}
			if (prev) {
				prev.next = next;
			} else if (next) {
				// Update first entry unless this is the
				// single entry
				this._drawFirst = next;
			}

			order.prev = this._drawLast;
			this._drawLast.next = order;

			order.next = null;
			this._drawLast = order;

			this._requestRedraw(layer);
		},

		_bringToBack: function (layer) {
			var order = layer._order;

			if (!order) { return; }

			var next = order.next;
			var prev = order.prev;

			if (prev) {
				prev.next = next;
			} else {
				// Already first
				return;
			}
			if (next) {
				next.prev = prev;
			} else if (prev) {
				// Update last entry unless this is the
				// single entry
				this._drawLast = prev;
			}

			order.prev = null;

			order.next = this._drawFirst;
			this._drawFirst.prev = order;
			this._drawFirst = order;

			this._requestRedraw(layer);
		}
	});

	// @factory L.canvas(options?: Renderer options)
	// Creates a Canvas renderer with the given options.
	function canvas$1(options) {
		return canvas ? new Canvas(options) : null;
	}

	/*
	 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
	 */


	var vmlCreate = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();


	/*
	 * @class SVG
	 *
	 *
	 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
	 * with old versions of Internet Explorer.
	 */

	// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
	var vmlMixin = {

		_initContainer: function () {
			this._container = create$1('div', 'leaflet-vml-container');
		},

		_update: function () {
			if (this._map._animatingZoom) { return; }
			Renderer.prototype._update.call(this);
			this.fire('update');
		},

		_initPath: function (layer) {
			var container = layer._container = vmlCreate('shape');

			addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

			container.coordsize = '1 1';

			layer._path = vmlCreate('path');
			container.appendChild(layer._path);

			this._updateStyle(layer);
			this._layers[stamp(layer)] = layer;
		},

		_addPath: function (layer) {
			var container = layer._container;
			this._container.appendChild(container);

			if (layer.options.interactive) {
				layer.addInteractiveTarget(container);
			}
		},

		_removePath: function (layer) {
			var container = layer._container;
			remove(container);
			layer.removeInteractiveTarget(container);
			delete this._layers[stamp(layer)];
		},

		_updateStyle: function (layer) {
			var stroke = layer._stroke,
			    fill = layer._fill,
			    options = layer.options,
			    container = layer._container;

			container.stroked = !!options.stroke;
			container.filled = !!options.fill;

			if (options.stroke) {
				if (!stroke) {
					stroke = layer._stroke = vmlCreate('stroke');
				}
				container.appendChild(stroke);
				stroke.weight = options.weight + 'px';
				stroke.color = options.color;
				stroke.opacity = options.opacity;

				if (options.dashArray) {
					stroke.dashStyle = isArray(options.dashArray) ?
					    options.dashArray.join(' ') :
					    options.dashArray.replace(/( *, *)/g, ' ');
				} else {
					stroke.dashStyle = '';
				}
				stroke.endcap = options.lineCap.replace('butt', 'flat');
				stroke.joinstyle = options.lineJoin;

			} else if (stroke) {
				container.removeChild(stroke);
				layer._stroke = null;
			}

			if (options.fill) {
				if (!fill) {
					fill = layer._fill = vmlCreate('fill');
				}
				container.appendChild(fill);
				fill.color = options.fillColor || options.color;
				fill.opacity = options.fillOpacity;

			} else if (fill) {
				container.removeChild(fill);
				layer._fill = null;
			}
		},

		_updateCircle: function (layer) {
			var p = layer._point.round(),
			    r = Math.round(layer._radius),
			    r2 = Math.round(layer._radiusY || r);

			this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
		},

		_setPath: function (layer, path) {
			layer._path.v = path;
		},

		_bringToFront: function (layer) {
			toFront(layer._container);
		},

		_bringToBack: function (layer) {
			toBack(layer._container);
		}
	};

	var create$2 = vml ? vmlCreate : svgCreate;

	/*
	 * @class SVG
	 * @inherits Renderer
	 * @aka L.SVG
	 *
	 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
	 * Inherits `Renderer`.
	 *
	 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
	 * available in all web browsers, notably Android 2.x and 3.x.
	 *
	 * Although SVG is not available on IE7 and IE8, these browsers support
	 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
	 * (a now deprecated technology), and the SVG renderer will fall back to VML in
	 * this case.
	 *
	 * @example
	 *
	 * Use SVG by default for all paths in the map:
	 *
	 * ```js
	 * var map = L.map('map', {
	 * 	renderer: L.svg()
	 * });
	 * ```
	 *
	 * Use a SVG renderer with extra padding for specific vector geometries:
	 *
	 * ```js
	 * var map = L.map('map');
	 * var myRenderer = L.svg({ padding: 0.5 });
	 * var line = L.polyline( coordinates, { renderer: myRenderer } );
	 * var circle = L.circle( center, { renderer: myRenderer } );
	 * ```
	 */

	var SVG = Renderer.extend({

		getEvents: function () {
			var events = Renderer.prototype.getEvents.call(this);
			events.zoomstart = this._onZoomStart;
			return events;
		},

		_initContainer: function () {
			this._container = create$2('svg');

			// makes it possible to click through svg root; we'll reset it back in individual paths
			this._container.setAttribute('pointer-events', 'none');

			this._rootGroup = create$2('g');
			this._container.appendChild(this._rootGroup);
		},

		_destroyContainer: function () {
			remove(this._container);
			off(this._container);
			delete this._container;
			delete this._rootGroup;
			delete this._svgSize;
		},

		_onZoomStart: function () {
			// Drag-then-pinch interactions might mess up the center and zoom.
			// In this case, the easiest way to prevent this is re-do the renderer
			//   bounds and padding when the zooming starts.
			this._update();
		},

		_update: function () {
			if (this._map._animatingZoom && this._bounds) { return; }

			Renderer.prototype._update.call(this);

			var b = this._bounds,
			    size = b.getSize(),
			    container = this._container;

			// set size of svg-container if changed
			if (!this._svgSize || !this._svgSize.equals(size)) {
				this._svgSize = size;
				container.setAttribute('width', size.x);
				container.setAttribute('height', size.y);
			}

			// movement: update container viewBox so that we don't have to change coordinates of individual layers
			setPosition(container, b.min);
			container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

			this.fire('update');
		},

		// methods below are called by vector layers implementations

		_initPath: function (layer) {
			var path = layer._path = create$2('path');

			// @namespace Path
			// @option className: String = null
			// Custom class name set on an element. Only for SVG renderer.
			if (layer.options.className) {
				addClass(path, layer.options.className);
			}

			if (layer.options.interactive) {
				addClass(path, 'leaflet-interactive');
			}

			this._updateStyle(layer);
			this._layers[stamp(layer)] = layer;
		},

		_addPath: function (layer) {
			if (!this._rootGroup) { this._initContainer(); }
			this._rootGroup.appendChild(layer._path);
			layer.addInteractiveTarget(layer._path);
		},

		_removePath: function (layer) {
			remove(layer._path);
			layer.removeInteractiveTarget(layer._path);
			delete this._layers[stamp(layer)];
		},

		_updatePath: function (layer) {
			layer._project();
			layer._update();
		},

		_updateStyle: function (layer) {
			var path = layer._path,
			    options = layer.options;

			if (!path) { return; }

			if (options.stroke) {
				path.setAttribute('stroke', options.color);
				path.setAttribute('stroke-opacity', options.opacity);
				path.setAttribute('stroke-width', options.weight);
				path.setAttribute('stroke-linecap', options.lineCap);
				path.setAttribute('stroke-linejoin', options.lineJoin);

				if (options.dashArray) {
					path.setAttribute('stroke-dasharray', options.dashArray);
				} else {
					path.removeAttribute('stroke-dasharray');
				}

				if (options.dashOffset) {
					path.setAttribute('stroke-dashoffset', options.dashOffset);
				} else {
					path.removeAttribute('stroke-dashoffset');
				}
			} else {
				path.setAttribute('stroke', 'none');
			}

			if (options.fill) {
				path.setAttribute('fill', options.fillColor || options.color);
				path.setAttribute('fill-opacity', options.fillOpacity);
				path.setAttribute('fill-rule', options.fillRule || 'evenodd');
			} else {
				path.setAttribute('fill', 'none');
			}
		},

		_updatePoly: function (layer, closed) {
			this._setPath(layer, pointsToPath(layer._parts, closed));
		},

		_updateCircle: function (layer) {
			var p = layer._point,
			    r = Math.max(Math.round(layer._radius), 1),
			    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
			    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

			// drawing a circle with two half-arcs
			var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

			this._setPath(layer, d);
		},

		_setPath: function (layer, path) {
			layer._path.setAttribute('d', path);
		},

		// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
		_bringToFront: function (layer) {
			toFront(layer._path);
		},

		_bringToBack: function (layer) {
			toBack(layer._path);
		}
	});

	if (vml) {
		SVG.include(vmlMixin);
	}

	// @namespace SVG
	// @factory L.svg(options?: Renderer options)
	// Creates a SVG renderer with the given options.
	function svg$1(options) {
		return svg || vml ? new SVG(options) : null;
	}

	Map.include({
		// @namespace Map; @method getRenderer(layer: Path): Renderer
		// Returns the instance of `Renderer` that should be used to render the given
		// `Path`. It will ensure that the `renderer` options of the map and paths
		// are respected, and that the renderers do exist on the map.
		getRenderer: function (layer) {
			// @namespace Path; @option renderer: Renderer
			// Use this specific instance of `Renderer` for this path. Takes
			// precedence over the map's [default renderer](#map-renderer).
			var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

			if (!renderer) {
				renderer = this._renderer = this._createRenderer();
			}

			if (!this.hasLayer(renderer)) {
				this.addLayer(renderer);
			}
			return renderer;
		},

		_getPaneRenderer: function (name) {
			if (name === 'overlayPane' || name === undefined) {
				return false;
			}

			var renderer = this._paneRenderers[name];
			if (renderer === undefined) {
				renderer = this._createRenderer({pane: name});
				this._paneRenderers[name] = renderer;
			}
			return renderer;
		},

		_createRenderer: function (options) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			return (this.options.preferCanvas && canvas$1(options)) || svg$1(options);
		}
	});

	/*
	 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
	 */

	/*
	 * @class Rectangle
	 * @aka L.Rectangle
	 * @inherits Polygon
	 *
	 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
	 *
	 * @example
	 *
	 * ```js
	 * // define rectangle geographical bounds
	 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
	 *
	 * // create an orange rectangle
	 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
	 *
	 * // zoom the map to the rectangle bounds
	 * map.fitBounds(bounds);
	 * ```
	 *
	 */


	var Rectangle = Polygon.extend({
		initialize: function (latLngBounds, options) {
			Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
		},

		// @method setBounds(latLngBounds: LatLngBounds): this
		// Redraws the rectangle with the passed bounds.
		setBounds: function (latLngBounds) {
			return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
		},

		_boundsToLatLngs: function (latLngBounds) {
			latLngBounds = toLatLngBounds(latLngBounds);
			return [
				latLngBounds.getSouthWest(),
				latLngBounds.getNorthWest(),
				latLngBounds.getNorthEast(),
				latLngBounds.getSouthEast()
			];
		}
	});


	// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
	function rectangle(latLngBounds, options) {
		return new Rectangle(latLngBounds, options);
	}

	SVG.create = create$2;
	SVG.pointsToPath = pointsToPath;

	GeoJSON.geometryToLayer = geometryToLayer;
	GeoJSON.coordsToLatLng = coordsToLatLng;
	GeoJSON.coordsToLatLngs = coordsToLatLngs;
	GeoJSON.latLngToCoords = latLngToCoords;
	GeoJSON.latLngsToCoords = latLngsToCoords;
	GeoJSON.getFeature = getFeature;
	GeoJSON.asFeature = asFeature;

	/*
	 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
	 * (zoom to a selected bounding box), enabled by default.
	 */

	// @namespace Map
	// @section Interaction Options
	Map.mergeOptions({
		// @option boxZoom: Boolean = true
		// Whether the map can be zoomed to a rectangular area specified by
		// dragging the mouse while pressing the shift key.
		boxZoom: true
	});

	var BoxZoom = Handler.extend({
		initialize: function (map) {
			this._map = map;
			this._container = map._container;
			this._pane = map._panes.overlayPane;
			this._resetStateTimeout = 0;
			map.on('unload', this._destroy, this);
		},

		addHooks: function () {
			on(this._container, 'mousedown', this._onMouseDown, this);
		},

		removeHooks: function () {
			off(this._container, 'mousedown', this._onMouseDown, this);
		},

		moved: function () {
			return this._moved;
		},

		_destroy: function () {
			remove(this._pane);
			delete this._pane;
		},

		_resetState: function () {
			this._resetStateTimeout = 0;
			this._moved = false;
		},

		_clearDeferredResetState: function () {
			if (this._resetStateTimeout !== 0) {
				clearTimeout(this._resetStateTimeout);
				this._resetStateTimeout = 0;
			}
		},

		_onMouseDown: function (e) {
			if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

			// Clear the deferred resetState if it hasn't executed yet, otherwise it
			// will interrupt the interaction and orphan a box element in the container.
			this._clearDeferredResetState();
			this._resetState();

			disableTextSelection();
			disableImageDrag();

			this._startPoint = this._map.mouseEventToContainerPoint(e);

			on(document, {
				contextmenu: stop,
				mousemove: this._onMouseMove,
				mouseup: this._onMouseUp,
				keydown: this._onKeyDown
			}, this);
		},

		_onMouseMove: function (e) {
			if (!this._moved) {
				this._moved = true;

				this._box = create$1('div', 'leaflet-zoom-box', this._container);
				addClass(this._container, 'leaflet-crosshair');

				this._map.fire('boxzoomstart');
			}

			this._point = this._map.mouseEventToContainerPoint(e);

			var bounds = new Bounds(this._point, this._startPoint),
			    size = bounds.getSize();

			setPosition(this._box, bounds.min);

			this._box.style.width  = size.x + 'px';
			this._box.style.height = size.y + 'px';
		},

		_finish: function () {
			if (this._moved) {
				remove(this._box);
				removeClass(this._container, 'leaflet-crosshair');
			}

			enableTextSelection();
			enableImageDrag();

			off(document, {
				contextmenu: stop,
				mousemove: this._onMouseMove,
				mouseup: this._onMouseUp,
				keydown: this._onKeyDown
			}, this);
		},

		_onMouseUp: function (e) {
			if ((e.which !== 1) && (e.button !== 1)) { return; }

			this._finish();

			if (!this._moved) { return; }
			// Postpone to next JS tick so internal click event handling
			// still see it as "moved".
			this._clearDeferredResetState();
			this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

			var bounds = new LatLngBounds(
			        this._map.containerPointToLatLng(this._startPoint),
			        this._map.containerPointToLatLng(this._point));

			this._map
				.fitBounds(bounds)
				.fire('boxzoomend', {boxZoomBounds: bounds});
		},

		_onKeyDown: function (e) {
			if (e.keyCode === 27) {
				this._finish();
			}
		}
	});

	// @section Handlers
	// @property boxZoom: Handler
	// Box (shift-drag with mouse) zoom handler.
	Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

	/*
	 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
	 */

	// @namespace Map
	// @section Interaction Options

	Map.mergeOptions({
		// @option doubleClickZoom: Boolean|String = true
		// Whether the map can be zoomed in by double clicking on it and
		// zoomed out by double clicking while holding shift. If passed
		// `'center'`, double-click zoom will zoom to the center of the
		//  view regardless of where the mouse was.
		doubleClickZoom: true
	});

	var DoubleClickZoom = Handler.extend({
		addHooks: function () {
			this._map.on('dblclick', this._onDoubleClick, this);
		},

		removeHooks: function () {
			this._map.off('dblclick', this._onDoubleClick, this);
		},

		_onDoubleClick: function (e) {
			var map = this._map,
			    oldZoom = map.getZoom(),
			    delta = map.options.zoomDelta,
			    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

			if (map.options.doubleClickZoom === 'center') {
				map.setZoom(zoom);
			} else {
				map.setZoomAround(e.containerPoint, zoom);
			}
		}
	});

	// @section Handlers
	//
	// Map properties include interaction handlers that allow you to control
	// interaction behavior in runtime, enabling or disabling certain features such
	// as dragging or touch zoom (see `Handler` methods). For example:
	//
	// ```js
	// map.doubleClickZoom.disable();
	// ```
	//
	// @property doubleClickZoom: Handler
	// Double click zoom handler.
	Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

	/*
	 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
	 */

	// @namespace Map
	// @section Interaction Options
	Map.mergeOptions({
		// @option dragging: Boolean = true
		// Whether the map be draggable with mouse/touch or not.
		dragging: true,

		// @section Panning Inertia Options
		// @option inertia: Boolean = *
		// If enabled, panning of the map will have an inertia effect where
		// the map builds momentum while dragging and continues moving in
		// the same direction for some time. Feels especially nice on touch
		// devices. Enabled by default unless running on old Android devices.
		inertia: !android23,

		// @option inertiaDeceleration: Number = 3000
		// The rate with which the inertial movement slows down, in pixels/second².
		inertiaDeceleration: 3400, // px/s^2

		// @option inertiaMaxSpeed: Number = Infinity
		// Max speed of the inertial movement, in pixels/second.
		inertiaMaxSpeed: Infinity, // px/s

		// @option easeLinearity: Number = 0.2
		easeLinearity: 0.2,

		// TODO refactor, move to CRS
		// @option worldCopyJump: Boolean = false
		// With this option enabled, the map tracks when you pan to another "copy"
		// of the world and seamlessly jumps to the original one so that all overlays
		// like markers and vector layers are still visible.
		worldCopyJump: false,

		// @option maxBoundsViscosity: Number = 0.0
		// If `maxBounds` is set, this option will control how solid the bounds
		// are when dragging the map around. The default value of `0.0` allows the
		// user to drag outside the bounds at normal speed, higher values will
		// slow down map dragging outside bounds, and `1.0` makes the bounds fully
		// solid, preventing the user from dragging outside the bounds.
		maxBoundsViscosity: 0.0
	});

	var Drag = Handler.extend({
		addHooks: function () {
			if (!this._draggable) {
				var map = this._map;

				this._draggable = new Draggable(map._mapPane, map._container);

				this._draggable.on({
					dragstart: this._onDragStart,
					drag: this._onDrag,
					dragend: this._onDragEnd
				}, this);

				this._draggable.on('predrag', this._onPreDragLimit, this);
				if (map.options.worldCopyJump) {
					this._draggable.on('predrag', this._onPreDragWrap, this);
					map.on('zoomend', this._onZoomEnd, this);

					map.whenReady(this._onZoomEnd, this);
				}
			}
			addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
			this._draggable.enable();
			this._positions = [];
			this._times = [];
		},

		removeHooks: function () {
			removeClass(this._map._container, 'leaflet-grab');
			removeClass(this._map._container, 'leaflet-touch-drag');
			this._draggable.disable();
		},

		moved: function () {
			return this._draggable && this._draggable._moved;
		},

		moving: function () {
			return this._draggable && this._draggable._moving;
		},

		_onDragStart: function () {
			var map = this._map;

			map._stop();
			if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
				var bounds = toLatLngBounds(this._map.options.maxBounds);

				this._offsetLimit = toBounds(
					this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
					this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
						.add(this._map.getSize()));

				this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
			} else {
				this._offsetLimit = null;
			}

			map
			    .fire('movestart')
			    .fire('dragstart');

			if (map.options.inertia) {
				this._positions = [];
				this._times = [];
			}
		},

		_onDrag: function (e) {
			if (this._map.options.inertia) {
				var time = this._lastTime = +new Date(),
				    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

				this._positions.push(pos);
				this._times.push(time);

				this._prunePositions(time);
			}

			this._map
			    .fire('move', e)
			    .fire('drag', e);
		},

		_prunePositions: function (time) {
			while (this._positions.length > 1 && time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		},

		_onZoomEnd: function () {
			var pxCenter = this._map.getSize().divideBy(2),
			    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

			this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
			this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
		},

		_viscousLimit: function (value, threshold) {
			return value - (value - threshold) * this._viscosity;
		},

		_onPreDragLimit: function () {
			if (!this._viscosity || !this._offsetLimit) { return; }

			var offset = this._draggable._newPos.subtract(this._draggable._startPos);

			var limit = this._offsetLimit;
			if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
			if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
			if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
			if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

			this._draggable._newPos = this._draggable._startPos.add(offset);
		},

		_onPreDragWrap: function () {
			// TODO refactor to be able to adjust map pane position after zoom
			var worldWidth = this._worldWidth,
			    halfWidth = Math.round(worldWidth / 2),
			    dx = this._initialWorldOffset,
			    x = this._draggable._newPos.x,
			    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
			    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
			    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

			this._draggable._absPos = this._draggable._newPos.clone();
			this._draggable._newPos.x = newX;
		},

		_onDragEnd: function (e) {
			var map = this._map,
			    options = map.options,

			    noInertia = !options.inertia || this._times.length < 2;

			map.fire('dragend', e);

			if (noInertia) {
				map.fire('moveend');

			} else {
				this._prunePositions(+new Date());

				var direction = this._lastPos.subtract(this._positions[0]),
				    duration = (this._lastTime - this._times[0]) / 1000,
				    ease = options.easeLinearity,

				    speedVector = direction.multiplyBy(ease / duration),
				    speed = speedVector.distanceTo([0, 0]),

				    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
				    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

				    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
				    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

				if (!offset.x && !offset.y) {
					map.fire('moveend');

				} else {
					offset = map._limitOffset(offset, map.options.maxBounds);

					requestAnimFrame(function () {
						map.panBy(offset, {
							duration: decelerationDuration,
							easeLinearity: ease,
							noMoveStart: true,
							animate: true
						});
					});
				}
			}
		}
	});

	// @section Handlers
	// @property dragging: Handler
	// Map dragging handler (by both mouse and touch).
	Map.addInitHook('addHandler', 'dragging', Drag);

	/*
	 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
	 */

	// @namespace Map
	// @section Keyboard Navigation Options
	Map.mergeOptions({
		// @option keyboard: Boolean = true
		// Makes the map focusable and allows users to navigate the map with keyboard
		// arrows and `+`/`-` keys.
		keyboard: true,

		// @option keyboardPanDelta: Number = 80
		// Amount of pixels to pan when pressing an arrow key.
		keyboardPanDelta: 80
	});

	var Keyboard = Handler.extend({

		keyCodes: {
			left:    [37],
			right:   [39],
			down:    [40],
			up:      [38],
			zoomIn:  [187, 107, 61, 171],
			zoomOut: [189, 109, 54, 173]
		},

		initialize: function (map) {
			this._map = map;

			this._setPanDelta(map.options.keyboardPanDelta);
			this._setZoomDelta(map.options.zoomDelta);
		},

		addHooks: function () {
			var container = this._map._container;

			// make the container focusable by tabbing
			if (container.tabIndex <= 0) {
				container.tabIndex = '0';
			}

			on(container, {
				focus: this._onFocus,
				blur: this._onBlur,
				mousedown: this._onMouseDown
			}, this);

			this._map.on({
				focus: this._addHooks,
				blur: this._removeHooks
			}, this);
		},

		removeHooks: function () {
			this._removeHooks();

			off(this._map._container, {
				focus: this._onFocus,
				blur: this._onBlur,
				mousedown: this._onMouseDown
			}, this);

			this._map.off({
				focus: this._addHooks,
				blur: this._removeHooks
			}, this);
		},

		_onMouseDown: function () {
			if (this._focused) { return; }

			var body = document.body,
			    docEl = document.documentElement,
			    top = body.scrollTop || docEl.scrollTop,
			    left = body.scrollLeft || docEl.scrollLeft;

			this._map._container.focus();

			window.scrollTo(left, top);
		},

		_onFocus: function () {
			this._focused = true;
			this._map.fire('focus');
		},

		_onBlur: function () {
			this._focused = false;
			this._map.fire('blur');
		},

		_setPanDelta: function (panDelta) {
			var keys = this._panKeys = {},
			    codes = this.keyCodes,
			    i, len;

			for (i = 0, len = codes.left.length; i < len; i++) {
				keys[codes.left[i]] = [-1 * panDelta, 0];
			}
			for (i = 0, len = codes.right.length; i < len; i++) {
				keys[codes.right[i]] = [panDelta, 0];
			}
			for (i = 0, len = codes.down.length; i < len; i++) {
				keys[codes.down[i]] = [0, panDelta];
			}
			for (i = 0, len = codes.up.length; i < len; i++) {
				keys[codes.up[i]] = [0, -1 * panDelta];
			}
		},

		_setZoomDelta: function (zoomDelta) {
			var keys = this._zoomKeys = {},
			    codes = this.keyCodes,
			    i, len;

			for (i = 0, len = codes.zoomIn.length; i < len; i++) {
				keys[codes.zoomIn[i]] = zoomDelta;
			}
			for (i = 0, len = codes.zoomOut.length; i < len; i++) {
				keys[codes.zoomOut[i]] = -zoomDelta;
			}
		},

		_addHooks: function () {
			on(document, 'keydown', this._onKeyDown, this);
		},

		_removeHooks: function () {
			off(document, 'keydown', this._onKeyDown, this);
		},

		_onKeyDown: function (e) {
			if (e.altKey || e.ctrlKey || e.metaKey) { return; }

			var key = e.keyCode,
			    map = this._map,
			    offset;

			if (key in this._panKeys) {
				if (!map._panAnim || !map._panAnim._inProgress) {
					offset = this._panKeys[key];
					if (e.shiftKey) {
						offset = toPoint(offset).multiplyBy(3);
					}

					map.panBy(offset);

					if (map.options.maxBounds) {
						map.panInsideBounds(map.options.maxBounds);
					}
				}
			} else if (key in this._zoomKeys) {
				map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

			} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
				map.closePopup();

			} else {
				return;
			}

			stop(e);
		}
	});

	// @section Handlers
	// @section Handlers
	// @property keyboard: Handler
	// Keyboard navigation handler.
	Map.addInitHook('addHandler', 'keyboard', Keyboard);

	/*
	 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
	 */

	// @namespace Map
	// @section Interaction Options
	Map.mergeOptions({
		// @section Mousewheel options
		// @option scrollWheelZoom: Boolean|String = true
		// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
		// it will zoom to the center of the view regardless of where the mouse was.
		scrollWheelZoom: true,

		// @option wheelDebounceTime: Number = 40
		// Limits the rate at which a wheel can fire (in milliseconds). By default
		// user can't zoom via wheel more often than once per 40 ms.
		wheelDebounceTime: 40,

		// @option wheelPxPerZoomLevel: Number = 60
		// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
		// mean a change of one full zoom level. Smaller values will make wheel-zooming
		// faster (and vice versa).
		wheelPxPerZoomLevel: 60
	});

	var ScrollWheelZoom = Handler.extend({
		addHooks: function () {
			on(this._map._container, 'mousewheel', this._onWheelScroll, this);

			this._delta = 0;
		},

		removeHooks: function () {
			off(this._map._container, 'mousewheel', this._onWheelScroll, this);
		},

		_onWheelScroll: function (e) {
			var delta = getWheelDelta(e);

			var debounce = this._map.options.wheelDebounceTime;

			this._delta += delta;
			this._lastMousePos = this._map.mouseEventToContainerPoint(e);

			if (!this._startTime) {
				this._startTime = +new Date();
			}

			var left = Math.max(debounce - (+new Date() - this._startTime), 0);

			clearTimeout(this._timer);
			this._timer = setTimeout(bind(this._performZoom, this), left);

			stop(e);
		},

		_performZoom: function () {
			var map = this._map,
			    zoom = map.getZoom(),
			    snap = this._map.options.zoomSnap || 0;

			map._stop(); // stop panning and fly animations if any

			// map the delta with a sigmoid function to -4..4 range leaning on -1..1
			var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
			    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
			    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
			    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

			this._delta = 0;
			this._startTime = null;

			if (!delta) { return; }

			if (map.options.scrollWheelZoom === 'center') {
				map.setZoom(zoom + delta);
			} else {
				map.setZoomAround(this._lastMousePos, zoom + delta);
			}
		}
	});

	// @section Handlers
	// @property scrollWheelZoom: Handler
	// Scroll wheel zoom handler.
	Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

	/*
	 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
	 */

	// @namespace Map
	// @section Interaction Options
	Map.mergeOptions({
		// @section Touch interaction options
		// @option tap: Boolean = true
		// Enables mobile hacks for supporting instant taps (fixing 200ms click
		// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
		tap: true,

		// @option tapTolerance: Number = 15
		// The max number of pixels a user can shift his finger during touch
		// for it to be considered a valid tap.
		tapTolerance: 15
	});

	var Tap = Handler.extend({
		addHooks: function () {
			on(this._map._container, 'touchstart', this._onDown, this);
		},

		removeHooks: function () {
			off(this._map._container, 'touchstart', this._onDown, this);
		},

		_onDown: function (e) {
			if (!e.touches) { return; }

			preventDefault(e);

			this._fireClick = true;

			// don't simulate click or track longpress if more than 1 touch
			if (e.touches.length > 1) {
				this._fireClick = false;
				clearTimeout(this._holdTimeout);
				return;
			}

			var first = e.touches[0],
			    el = first.target;

			this._startPos = this._newPos = new Point(first.clientX, first.clientY);

			// if touching a link, highlight it
			if (el.tagName && el.tagName.toLowerCase() === 'a') {
				addClass(el, 'leaflet-active');
			}

			// simulate long hold but setting a timeout
			this._holdTimeout = setTimeout(bind(function () {
				if (this._isTapValid()) {
					this._fireClick = false;
					this._onUp();
					this._simulateEvent('contextmenu', first);
				}
			}, this), 1000);

			this._simulateEvent('mousedown', first);

			on(document, {
				touchmove: this._onMove,
				touchend: this._onUp
			}, this);
		},

		_onUp: function (e) {
			clearTimeout(this._holdTimeout);

			off(document, {
				touchmove: this._onMove,
				touchend: this._onUp
			}, this);

			if (this._fireClick && e && e.changedTouches) {

				var first = e.changedTouches[0],
				    el = first.target;

				if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
					removeClass(el, 'leaflet-active');
				}

				this._simulateEvent('mouseup', first);

				// simulate click if the touch didn't move too much
				if (this._isTapValid()) {
					this._simulateEvent('click', first);
				}
			}
		},

		_isTapValid: function () {
			return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
		},

		_onMove: function (e) {
			var first = e.touches[0];
			this._newPos = new Point(first.clientX, first.clientY);
			this._simulateEvent('mousemove', first);
		},

		_simulateEvent: function (type, e) {
			var simulatedEvent = document.createEvent('MouseEvents');

			simulatedEvent._simulated = true;
			e.target._simulatedClick = true;

			simulatedEvent.initMouseEvent(
			        type, true, true, window, 1,
			        e.screenX, e.screenY,
			        e.clientX, e.clientY,
			        false, false, false, false, 0, null);

			e.target.dispatchEvent(simulatedEvent);
		}
	});

	// @section Handlers
	// @property tap: Handler
	// Mobile touch hacks (quick tap and touch hold) handler.
	if (touch && !pointer) {
		Map.addInitHook('addHandler', 'tap', Tap);
	}

	/*
	 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
	 */

	// @namespace Map
	// @section Interaction Options
	Map.mergeOptions({
		// @section Touch interaction options
		// @option touchZoom: Boolean|String = *
		// Whether the map can be zoomed by touch-dragging with two fingers. If
		// passed `'center'`, it will zoom to the center of the view regardless of
		// where the touch events (fingers) were. Enabled for touch-capable web
		// browsers except for old Androids.
		touchZoom: touch && !android23,

		// @option bounceAtZoomLimits: Boolean = true
		// Set it to false if you don't want the map to zoom beyond min/max zoom
		// and then bounce back when pinch-zooming.
		bounceAtZoomLimits: true
	});

	var TouchZoom = Handler.extend({
		addHooks: function () {
			addClass(this._map._container, 'leaflet-touch-zoom');
			on(this._map._container, 'touchstart', this._onTouchStart, this);
		},

		removeHooks: function () {
			removeClass(this._map._container, 'leaflet-touch-zoom');
			off(this._map._container, 'touchstart', this._onTouchStart, this);
		},

		_onTouchStart: function (e) {
			var map = this._map;
			if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

			var p1 = map.mouseEventToContainerPoint(e.touches[0]),
			    p2 = map.mouseEventToContainerPoint(e.touches[1]);

			this._centerPoint = map.getSize()._divideBy(2);
			this._startLatLng = map.containerPointToLatLng(this._centerPoint);
			if (map.options.touchZoom !== 'center') {
				this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
			}

			this._startDist = p1.distanceTo(p2);
			this._startZoom = map.getZoom();

			this._moved = false;
			this._zooming = true;

			map._stop();

			on(document, 'touchmove', this._onTouchMove, this);
			on(document, 'touchend', this._onTouchEnd, this);

			preventDefault(e);
		},

		_onTouchMove: function (e) {
			if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

			var map = this._map,
			    p1 = map.mouseEventToContainerPoint(e.touches[0]),
			    p2 = map.mouseEventToContainerPoint(e.touches[1]),
			    scale = p1.distanceTo(p2) / this._startDist;

			this._zoom = map.getScaleZoom(scale, this._startZoom);

			if (!map.options.bounceAtZoomLimits && (
				(this._zoom < map.getMinZoom() && scale < 1) ||
				(this._zoom > map.getMaxZoom() && scale > 1))) {
				this._zoom = map._limitZoom(this._zoom);
			}

			if (map.options.touchZoom === 'center') {
				this._center = this._startLatLng;
				if (scale === 1) { return; }
			} else {
				// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
				var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
				if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
				this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
			}

			if (!this._moved) {
				map._moveStart(true, false);
				this._moved = true;
			}

			cancelAnimFrame(this._animRequest);

			var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
			this._animRequest = requestAnimFrame(moveFn, this, true);

			preventDefault(e);
		},

		_onTouchEnd: function () {
			if (!this._moved || !this._zooming) {
				this._zooming = false;
				return;
			}

			this._zooming = false;
			cancelAnimFrame(this._animRequest);

			off(document, 'touchmove', this._onTouchMove);
			off(document, 'touchend', this._onTouchEnd);

			// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
			if (this._map.options.zoomAnimation) {
				this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
			} else {
				this._map._resetView(this._center, this._map._limitZoom(this._zoom));
			}
		}
	});

	// @section Handlers
	// @property touchZoom: Handler
	// Touch zoom handler.
	Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

	Map.BoxZoom = BoxZoom;
	Map.DoubleClickZoom = DoubleClickZoom;
	Map.Drag = Drag;
	Map.Keyboard = Keyboard;
	Map.ScrollWheelZoom = ScrollWheelZoom;
	Map.Tap = Tap;
	Map.TouchZoom = TouchZoom;

	Object.freeze = freeze;

	exports.version = version;
	exports.Control = Control;
	exports.control = control;
	exports.Browser = Browser;
	exports.Evented = Evented;
	exports.Mixin = Mixin;
	exports.Util = Util;
	exports.Class = Class;
	exports.Handler = Handler;
	exports.extend = extend;
	exports.bind = bind;
	exports.stamp = stamp;
	exports.setOptions = setOptions;
	exports.DomEvent = DomEvent;
	exports.DomUtil = DomUtil;
	exports.PosAnimation = PosAnimation;
	exports.Draggable = Draggable;
	exports.LineUtil = LineUtil;
	exports.PolyUtil = PolyUtil;
	exports.Point = Point;
	exports.point = toPoint;
	exports.Bounds = Bounds;
	exports.bounds = toBounds;
	exports.Transformation = Transformation;
	exports.transformation = toTransformation;
	exports.Projection = index;
	exports.LatLng = LatLng;
	exports.latLng = toLatLng;
	exports.LatLngBounds = LatLngBounds;
	exports.latLngBounds = toLatLngBounds;
	exports.CRS = CRS;
	exports.GeoJSON = GeoJSON;
	exports.geoJSON = geoJSON;
	exports.geoJson = geoJson;
	exports.Layer = Layer;
	exports.LayerGroup = LayerGroup;
	exports.layerGroup = layerGroup;
	exports.FeatureGroup = FeatureGroup;
	exports.featureGroup = featureGroup;
	exports.ImageOverlay = ImageOverlay;
	exports.imageOverlay = imageOverlay;
	exports.VideoOverlay = VideoOverlay;
	exports.videoOverlay = videoOverlay;
	exports.DivOverlay = DivOverlay;
	exports.Popup = Popup;
	exports.popup = popup;
	exports.Tooltip = Tooltip;
	exports.tooltip = tooltip;
	exports.Icon = Icon;
	exports.icon = icon;
	exports.DivIcon = DivIcon;
	exports.divIcon = divIcon;
	exports.Marker = Marker;
	exports.marker = marker;
	exports.TileLayer = TileLayer;
	exports.tileLayer = tileLayer;
	exports.GridLayer = GridLayer;
	exports.gridLayer = gridLayer;
	exports.SVG = SVG;
	exports.svg = svg$1;
	exports.Renderer = Renderer;
	exports.Canvas = Canvas;
	exports.canvas = canvas$1;
	exports.Path = Path;
	exports.CircleMarker = CircleMarker;
	exports.circleMarker = circleMarker;
	exports.Circle = Circle;
	exports.circle = circle;
	exports.Polyline = Polyline;
	exports.polyline = polyline;
	exports.Polygon = Polygon;
	exports.polygon = polygon;
	exports.Rectangle = Rectangle;
	exports.rectangle = rectangle;
	exports.Map = Map;
	exports.map = createMap;

	var oldL = window.L;
	exports.noConflict = function() {
		window.L = oldL;
		return this;
	};

	// Always export us to window global (see #2364)
	window.L = exports;

	})));

	});

	/*
	 Leaflet.draw 1.0.4+838a63b, a plugin that adds drawing and editing tools to Leaflet powered maps.
	 (c) 2012-2017, Jacob Toye, Jon West, Smartrak, Leaflet

	 https://github.com/Leaflet/Leaflet.draw
	 http://leafletjs.com
	 */
	!function(t,e,i){function o(t,e){for(;(t=t.parentElement)&&!t.classList.contains(e););return t}L.drawVersion="1.0.4+838a63b",L.Draw={},L.drawLocal={draw:{toolbar:{actions:{title:"Cancel drawing",text:"Cancel"},finish:{title:"Finish drawing",text:"Finish"},undo:{title:"Delete last point drawn",text:"Delete last point"},buttons:{polyline:"Draw a polyline",polygon:"Draw a polygon",rectangle:"Draw a rectangle",circle:"Draw a circle",marker:"Draw a marker",circlemarker:"Draw a circlemarker"}},handlers:{circle:{tooltip:{start:"Click and drag to draw circle."},radius:"Radius"},circlemarker:{tooltip:{start:"Click map to place circle marker."}},marker:{tooltip:{start:"Click map to place marker."}},polygon:{tooltip:{start:"Click to start drawing shape.",cont:"Click to continue drawing shape.",end:"Click first point to close this shape."}},polyline:{error:"<strong>Error:</strong> shape edges cannot cross!",tooltip:{start:"Click to start drawing line.",cont:"Click to continue drawing line.",end:"Click last point to finish line."}},rectangle:{tooltip:{start:"Click and drag to draw rectangle."}},simpleshape:{tooltip:{end:"Release mouse to finish drawing."}}}},edit:{toolbar:{actions:{save:{title:"Save changes",text:"Save"},cancel:{title:"Cancel editing, discards all changes",text:"Cancel"},clearAll:{title:"Clear all layers",text:"Clear All"}},buttons:{edit:"Edit layers",editDisabled:"No layers to edit",remove:"Delete layers",removeDisabled:"No layers to delete"}},handlers:{edit:{tooltip:{text:"Drag handles or markers to edit features.",subtext:"Click cancel to undo changes."}},remove:{tooltip:{text:"Click on a feature to remove."}}}}},L.Draw.Event={},L.Draw.Event.CREATED="draw:created",L.Draw.Event.EDITED="draw:edited",L.Draw.Event.DELETED="draw:deleted",L.Draw.Event.DRAWSTART="draw:drawstart",L.Draw.Event.DRAWSTOP="draw:drawstop",L.Draw.Event.DRAWVERTEX="draw:drawvertex",L.Draw.Event.EDITSTART="draw:editstart",L.Draw.Event.EDITMOVE="draw:editmove",L.Draw.Event.EDITRESIZE="draw:editresize",L.Draw.Event.EDITVERTEX="draw:editvertex",L.Draw.Event.EDITSTOP="draw:editstop",L.Draw.Event.DELETESTART="draw:deletestart",L.Draw.Event.DELETESTOP="draw:deletestop",L.Draw.Event.TOOLBAROPENED="draw:toolbaropened",L.Draw.Event.TOOLBARCLOSED="draw:toolbarclosed",L.Draw.Event.MARKERCONTEXT="draw:markercontext",L.Draw=L.Draw||{},L.Draw.Feature=L.Handler.extend({initialize:function(t,e){this._map=t,this._container=t._container,this._overlayPane=t._panes.overlayPane,this._popupPane=t._panes.popupPane,e&&e.shapeOptions&&(e.shapeOptions=L.Util.extend({},this.options.shapeOptions,e.shapeOptions)),L.setOptions(this,e);var i=L.version.split(".");1===parseInt(i[0],10)&&parseInt(i[1],10)>=2?L.Draw.Feature.include(L.Evented.prototype):L.Draw.Feature.include(L.Mixin.Events);},enable:function(){this._enabled||(L.Handler.prototype.enable.call(this),this.fire("enabled",{handler:this.type}),this._map.fire(L.Draw.Event.DRAWSTART,{layerType:this.type}));},disable:function(){this._enabled&&(L.Handler.prototype.disable.call(this),this._map.fire(L.Draw.Event.DRAWSTOP,{layerType:this.type}),this.fire("disabled",{handler:this.type}));},addHooks:function(){var t=this._map;t&&(L.DomUtil.disableTextSelection(),t.getContainer().focus(),this._tooltip=new L.Draw.Tooltip(this._map),L.DomEvent.on(this._container,"keyup",this._cancelDrawing,this));},removeHooks:function(){this._map&&(L.DomUtil.enableTextSelection(),this._tooltip.dispose(),this._tooltip=null,L.DomEvent.off(this._container,"keyup",this._cancelDrawing,this));},setOptions:function(t){L.setOptions(this,t);},_fireCreatedEvent:function(t){this._map.fire(L.Draw.Event.CREATED,{layer:t,layerType:this.type});},_cancelDrawing:function(t){27===t.keyCode&&(this._map.fire("draw:canceled",{layerType:this.type}),this.disable());}}),L.Draw.Polyline=L.Draw.Feature.extend({statics:{TYPE:"polyline"},Poly:L.Polyline,options:{allowIntersection:!0,repeatMode:!1,drawError:{color:"#b00b00",timeout:2500},icon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon"}),touchIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon"}),guidelineDistance:20,maxGuideLineLength:4e3,shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!1,clickable:!0},metric:!0,feet:!0,nautic:!1,showLength:!0,zIndexOffset:2e3,factor:1,maxPoints:0},initialize:function(t,e){L.Browser.touch&&(this.options.icon=this.options.touchIcon),this.options.drawError.message=L.drawLocal.draw.handlers.polyline.error,e&&e.drawError&&(e.drawError=L.Util.extend({},this.options.drawError,e.drawError)),this.type=L.Draw.Polyline.TYPE,L.Draw.Feature.prototype.initialize.call(this,t,e);},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._markers=[],this._markerGroup=new L.LayerGroup,this._map.addLayer(this._markerGroup),this._poly=new L.Polyline([],this.options.shapeOptions),this._tooltip.updateContent(this._getTooltipText()),this._mouseMarker||(this._mouseMarker=L.marker(this._map.getCenter(),{icon:L.divIcon({className:"leaflet-mouse-marker",iconAnchor:[20,20],iconSize:[40,40]}),opacity:0,zIndexOffset:this.options.zIndexOffset})),this._mouseMarker.on("mouseout",this._onMouseOut,this).on("mousemove",this._onMouseMove,this).on("mousedown",this._onMouseDown,this).on("mouseup",this._onMouseUp,this).addTo(this._map),this._map.on("mouseup",this._onMouseUp,this).on("mousemove",this._onMouseMove,this).on("zoomlevelschange",this._onZoomEnd,this).on("touchstart",this._onTouch,this).on("zoomend",this._onZoomEnd,this));},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._clearHideErrorTimeout(),this._cleanUpShape(),this._map.removeLayer(this._markerGroup),delete this._markerGroup,delete this._markers,this._map.removeLayer(this._poly),delete this._poly,this._mouseMarker.off("mousedown",this._onMouseDown,this).off("mouseout",this._onMouseOut,this).off("mouseup",this._onMouseUp,this).off("mousemove",this._onMouseMove,this),this._map.removeLayer(this._mouseMarker),delete this._mouseMarker,this._clearGuides(),this._map.off("mouseup",this._onMouseUp,this).off("mousemove",this._onMouseMove,this).off("zoomlevelschange",this._onZoomEnd,this).off("zoomend",this._onZoomEnd,this).off("touchstart",this._onTouch,this).off("click",this._onTouch,this);},deleteLastVertex:function(){if(!(this._markers.length<=1)){var t=this._markers.pop(),e=this._poly,i=e.getLatLngs(),o=i.splice(-1,1)[0];this._poly.setLatLngs(i),this._markerGroup.removeLayer(t),e.getLatLngs().length<2&&this._map.removeLayer(e),this._vertexChanged(o,!1);}},addVertex:function(t){if(this._markers.length>=2&&!this.options.allowIntersection&&this._poly.newLatLngIntersects(t))return void this._showErrorTooltip();this._errorShown&&this._hideErrorTooltip(),this._markers.push(this._createMarker(t)),this._poly.addLatLng(t),2===this._poly.getLatLngs().length&&this._map.addLayer(this._poly),this._vertexChanged(t,!0);},completeShape:function(){this._markers.length<=1||!this._shapeIsValid()||(this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable());},_finishShape:function(){var t=this._poly._defaultShape?this._poly._defaultShape():this._poly.getLatLngs(),e=this._poly.newLatLngIntersects(t[t.length-1]);if(!this.options.allowIntersection&&e||!this._shapeIsValid())return void this._showErrorTooltip();this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable();},_shapeIsValid:function(){return !0},_onZoomEnd:function(){null!==this._markers&&this._updateGuide();},_onMouseMove:function(t){var e=this._map.mouseEventToLayerPoint(t.originalEvent),i=this._map.layerPointToLatLng(e);this._currentLatLng=i,this._updateTooltip(i),this._updateGuide(e),this._mouseMarker.setLatLng(i),L.DomEvent.preventDefault(t.originalEvent);},_vertexChanged:function(t,e){this._map.fire(L.Draw.Event.DRAWVERTEX,{layers:this._markerGroup}),this._updateFinishHandler(),this._updateRunningMeasure(t,e),this._clearGuides(),this._updateTooltip();},_onMouseDown:function(t){if(!this._clickHandled&&!this._touchHandled&&!this._disableMarkers){this._onMouseMove(t),this._clickHandled=!0,this._disableNewMarkers();var e=t.originalEvent,i=e.clientX,o=e.clientY;this._startPoint.call(this,i,o);}},_startPoint:function(t,e){this._mouseDownOrigin=L.point(t,e);},_onMouseUp:function(t){var e=t.originalEvent,i=e.clientX,o=e.clientY;this._endPoint.call(this,i,o,t),this._clickHandled=null;},_endPoint:function(e,i,o){if(this._mouseDownOrigin){var a=L.point(e,i).distanceTo(this._mouseDownOrigin),n=this._calculateFinishDistance(o.latlng);this.options.maxPoints>1&&this.options.maxPoints==this._markers.length+1?(this.addVertex(o.latlng),this._finishShape()):n<10&&L.Browser.touch?this._finishShape():Math.abs(a)<9*(t.devicePixelRatio||1)&&this.addVertex(o.latlng),this._enableNewMarkers();}this._mouseDownOrigin=null;},_onTouch:function(t){var e,i,o=t.originalEvent;!o.touches||!o.touches[0]||this._clickHandled||this._touchHandled||this._disableMarkers||(e=o.touches[0].clientX,i=o.touches[0].clientY,this._disableNewMarkers(),this._touchHandled=!0,this._startPoint.call(this,e,i),this._endPoint.call(this,e,i,t),this._touchHandled=null),this._clickHandled=null;},_onMouseOut:function(){this._tooltip&&this._tooltip._onMouseOut.call(this._tooltip);},_calculateFinishDistance:function(t){var e;if(this._markers.length>0){var i;if(this.type===L.Draw.Polyline.TYPE)i=this._markers[this._markers.length-1];else{if(this.type!==L.Draw.Polygon.TYPE)return 1/0;i=this._markers[0];}var o=this._map.latLngToContainerPoint(i.getLatLng()),a=new L.Marker(t,{icon:this.options.icon,zIndexOffset:2*this.options.zIndexOffset}),n=this._map.latLngToContainerPoint(a.getLatLng());e=o.distanceTo(n);}else e=1/0;return e},_updateFinishHandler:function(){var t=this._markers.length;t>1&&this._markers[t-1].on("click",this._finishShape,this),t>2&&this._markers[t-2].off("click",this._finishShape,this);},_createMarker:function(t){var e=new L.Marker(t,{icon:this.options.icon,zIndexOffset:2*this.options.zIndexOffset});return this._markerGroup.addLayer(e),e},_updateGuide:function(t){var e=this._markers?this._markers.length:0;e>0&&(t=t||this._map.latLngToLayerPoint(this._currentLatLng),this._clearGuides(),this._drawGuide(this._map.latLngToLayerPoint(this._markers[e-1].getLatLng()),t));},_updateTooltip:function(t){var e=this._getTooltipText();t&&this._tooltip.updatePosition(t),this._errorShown||this._tooltip.updateContent(e);},_drawGuide:function(t,e){var i,o,a,n=Math.floor(Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))),s=this.options.guidelineDistance,r=this.options.maxGuideLineLength,l=n>r?n-r:s;for(this._guidesContainer||(this._guidesContainer=L.DomUtil.create("div","leaflet-draw-guides",this._overlayPane));l<n;l+=this.options.guidelineDistance)i=l/n,o={x:Math.floor(t.x*(1-i)+i*e.x),y:Math.floor(t.y*(1-i)+i*e.y)},a=L.DomUtil.create("div","leaflet-draw-guide-dash",this._guidesContainer),a.style.backgroundColor=this._errorShown?this.options.drawError.color:this.options.shapeOptions.color,L.DomUtil.setPosition(a,o);},_updateGuideColor:function(t){if(this._guidesContainer)for(var e=0,i=this._guidesContainer.childNodes.length;e<i;e++)this._guidesContainer.childNodes[e].style.backgroundColor=t;},_clearGuides:function(){if(this._guidesContainer)for(;this._guidesContainer.firstChild;)this._guidesContainer.removeChild(this._guidesContainer.firstChild);},_getTooltipText:function(){var t,e,i=this.options.showLength;return 0===this._markers.length?t={text:L.drawLocal.draw.handlers.polyline.tooltip.start}:(e=i?this._getMeasurementString():"",t=1===this._markers.length?{text:L.drawLocal.draw.handlers.polyline.tooltip.cont,subtext:e}:{text:L.drawLocal.draw.handlers.polyline.tooltip.end,subtext:e}),t},_updateRunningMeasure:function(t,e){var i,o,a=this._markers.length;1===this._markers.length?this._measurementRunningTotal=0:(i=a-(e?2:1),o=L.GeometryUtil.isVersion07x()?t.distanceTo(this._markers[i].getLatLng())*(this.options.factor||1):this._map.distance(t,this._markers[i].getLatLng())*(this.options.factor||1),this._measurementRunningTotal+=o*(e?1:-1));},_getMeasurementString:function(){var t,e=this._currentLatLng,i=this._markers[this._markers.length-1].getLatLng();return t=L.GeometryUtil.isVersion07x()?i&&e&&e.distanceTo?this._measurementRunningTotal+e.distanceTo(i)*(this.options.factor||1):this._measurementRunningTotal||0:i&&e?this._measurementRunningTotal+this._map.distance(e,i)*(this.options.factor||1):this._measurementRunningTotal||0,L.GeometryUtil.readableDistance(t,this.options.metric,this.options.feet,this.options.nautic,this.options.precision)},_showErrorTooltip:function(){this._errorShown=!0,this._tooltip.showAsError().updateContent({text:this.options.drawError.message}),this._updateGuideColor(this.options.drawError.color),this._poly.setStyle({color:this.options.drawError.color}),this._clearHideErrorTimeout(),this._hideErrorTimeout=setTimeout(L.Util.bind(this._hideErrorTooltip,this),this.options.drawError.timeout);},_hideErrorTooltip:function(){this._errorShown=!1,this._clearHideErrorTimeout(),this._tooltip.removeError().updateContent(this._getTooltipText()),this._updateGuideColor(this.options.shapeOptions.color),this._poly.setStyle({color:this.options.shapeOptions.color});},_clearHideErrorTimeout:function(){this._hideErrorTimeout&&(clearTimeout(this._hideErrorTimeout),this._hideErrorTimeout=null);},_disableNewMarkers:function(){this._disableMarkers=!0;},_enableNewMarkers:function(){setTimeout(function(){this._disableMarkers=!1;}.bind(this),50);},_cleanUpShape:function(){this._markers.length>1&&this._markers[this._markers.length-1].off("click",this._finishShape,this);},_fireCreatedEvent:function(){var t=new this.Poly(this._poly.getLatLngs(),this.options.shapeOptions);L.Draw.Feature.prototype._fireCreatedEvent.call(this,t);}}),L.Draw.Polygon=L.Draw.Polyline.extend({statics:{TYPE:"polygon"},Poly:L.Polygon,options:{showArea:!1,showLength:!1,shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},metric:!0,feet:!0,nautic:!1,precision:{}},initialize:function(t,e){L.Draw.Polyline.prototype.initialize.call(this,t,e),this.type=L.Draw.Polygon.TYPE;},_updateFinishHandler:function(){var t=this._markers.length;1===t&&this._markers[0].on("click",this._finishShape,this),t>2&&(this._markers[t-1].on("dblclick",this._finishShape,this),t>3&&this._markers[t-2].off("dblclick",this._finishShape,this));},_getTooltipText:function(){var t,e;return 0===this._markers.length?t=L.drawLocal.draw.handlers.polygon.tooltip.start:this._markers.length<3?(t=L.drawLocal.draw.handlers.polygon.tooltip.cont,e=this._getMeasurementString()):(t=L.drawLocal.draw.handlers.polygon.tooltip.end,e=this._getMeasurementString()),{text:t,subtext:e}},_getMeasurementString:function(){var t=this._area,e="";return t||this.options.showLength?(this.options.showLength&&(e=L.Draw.Polyline.prototype._getMeasurementString.call(this)),t&&(e+="<br>"+L.GeometryUtil.readableArea(t,this.options.metric,this.options.precision)),e):null},_shapeIsValid:function(){return this._markers.length>=3},_vertexChanged:function(t,e){var i;!this.options.allowIntersection&&this.options.showArea&&(i=this._poly.getLatLngs(),this._area=L.GeometryUtil.geodesicArea(i)),L.Draw.Polyline.prototype._vertexChanged.call(this,t,e);},_cleanUpShape:function(){var t=this._markers.length;t>0&&(this._markers[0].off("click",this._finishShape,this),t>2&&this._markers[t-1].off("dblclick",this._finishShape,this));}}),L.SimpleShape={},L.Draw.SimpleShape=L.Draw.Feature.extend({options:{repeatMode:!1},initialize:function(t,e){this._endLabelText=L.drawLocal.draw.handlers.simpleshape.tooltip.end,L.Draw.Feature.prototype.initialize.call(this,t,e);},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._mapDraggable=this._map.dragging.enabled(),this._mapDraggable&&this._map.dragging.disable(),this._container.style.cursor="crosshair",this._tooltip.updateContent({text:this._initialLabelText}),this._map.on("mousedown",this._onMouseDown,this).on("mousemove",this._onMouseMove,this).on("touchstart",this._onMouseDown,this).on("touchmove",this._onMouseMove,this),e.addEventListener("touchstart",L.DomEvent.preventDefault,{passive:!1}));},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._map&&(this._mapDraggable&&this._map.dragging.enable(),this._container.style.cursor="",this._map.off("mousedown",this._onMouseDown,this).off("mousemove",this._onMouseMove,this).off("touchstart",this._onMouseDown,this).off("touchmove",this._onMouseMove,this),L.DomEvent.off(e,"mouseup",this._onMouseUp,this),L.DomEvent.off(e,"touchend",this._onMouseUp,this),e.removeEventListener("touchstart",L.DomEvent.preventDefault),this._shape&&(this._map.removeLayer(this._shape),delete this._shape)),this._isDrawing=!1;},_getTooltipText:function(){return {text:this._endLabelText}},_onMouseDown:function(t){this._isDrawing=!0,this._startLatLng=t.latlng,L.DomEvent.on(e,"mouseup",this._onMouseUp,this).on(e,"touchend",this._onMouseUp,this).preventDefault(t.originalEvent);},_onMouseMove:function(t){var e=t.latlng;this._tooltip.updatePosition(e),this._isDrawing&&(this._tooltip.updateContent(this._getTooltipText()),this._drawShape(e));},_onMouseUp:function(){this._shape&&this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable();}}),L.Draw.Rectangle=L.Draw.SimpleShape.extend({statics:{TYPE:"rectangle"},options:{shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},showArea:!0,metric:!0},initialize:function(t,e){this.type=L.Draw.Rectangle.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.rectangle.tooltip.start,L.Draw.SimpleShape.prototype.initialize.call(this,t,e);},disable:function(){this._enabled&&(this._isCurrentlyTwoClickDrawing=!1,L.Draw.SimpleShape.prototype.disable.call(this));},_onMouseUp:function(t){if(!this._shape&&!this._isCurrentlyTwoClickDrawing)return void(this._isCurrentlyTwoClickDrawing=!0);this._isCurrentlyTwoClickDrawing&&!o(t.target,"leaflet-pane")||L.Draw.SimpleShape.prototype._onMouseUp.call(this);},_drawShape:function(t){this._shape?this._shape.setBounds(new L.LatLngBounds(this._startLatLng,t)):(this._shape=new L.Rectangle(new L.LatLngBounds(this._startLatLng,t),this.options.shapeOptions),this._map.addLayer(this._shape));},_fireCreatedEvent:function(){var t=new L.Rectangle(this._shape.getBounds(),this.options.shapeOptions);L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this,t);},_getTooltipText:function(){var t,e,i,o=L.Draw.SimpleShape.prototype._getTooltipText.call(this),a=this._shape,n=this.options.showArea;return a&&(t=this._shape._defaultShape?this._shape._defaultShape():this._shape.getLatLngs(),e=L.GeometryUtil.geodesicArea(t),i=n?L.GeometryUtil.readableArea(e,this.options.metric):""),{text:o.text,subtext:i}}}),L.Draw.Marker=L.Draw.Feature.extend({statics:{TYPE:"marker"},options:{icon:new L.Icon.Default,repeatMode:!1,zIndexOffset:2e3},initialize:function(t,e){this.type=L.Draw.Marker.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.marker.tooltip.start,L.Draw.Feature.prototype.initialize.call(this,t,e);},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._tooltip.updateContent({text:this._initialLabelText}),this._mouseMarker||(this._mouseMarker=L.marker(this._map.getCenter(),{icon:L.divIcon({className:"leaflet-mouse-marker",iconAnchor:[20,20],iconSize:[40,40]}),opacity:0,zIndexOffset:this.options.zIndexOffset})),this._mouseMarker.on("click",this._onClick,this).addTo(this._map),this._map.on("mousemove",this._onMouseMove,this),this._map.on("click",this._onTouch,this));},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._map&&(this._map.off("click",this._onClick,this).off("click",this._onTouch,this),this._marker&&(this._marker.off("click",this._onClick,this),this._map.removeLayer(this._marker),delete this._marker),this._mouseMarker.off("click",this._onClick,this),this._map.removeLayer(this._mouseMarker),delete this._mouseMarker,this._map.off("mousemove",this._onMouseMove,this));},_onMouseMove:function(t){var e=t.latlng;this._tooltip.updatePosition(e),this._mouseMarker.setLatLng(e),this._marker?(e=this._mouseMarker.getLatLng(),this._marker.setLatLng(e)):(this._marker=this._createMarker(e),this._marker.on("click",this._onClick,this),this._map.on("click",this._onClick,this).addLayer(this._marker));},_createMarker:function(t){return new L.Marker(t,{icon:this.options.icon,zIndexOffset:this.options.zIndexOffset})},_onClick:function(){this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable();},_onTouch:function(t){this._onMouseMove(t),this._onClick();},_fireCreatedEvent:function(){var t=new L.Marker.Touch(this._marker.getLatLng(),{icon:this.options.icon});L.Draw.Feature.prototype._fireCreatedEvent.call(this,t);}}),L.Draw.CircleMarker=L.Draw.Marker.extend({statics:{TYPE:"circlemarker"},options:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0,zIndexOffset:2e3},initialize:function(t,e){this.type=L.Draw.CircleMarker.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.circlemarker.tooltip.start,L.Draw.Feature.prototype.initialize.call(this,t,e);},_fireCreatedEvent:function(){var t=new L.CircleMarker(this._marker.getLatLng(),this.options);L.Draw.Feature.prototype._fireCreatedEvent.call(this,t);},_createMarker:function(t){return new L.CircleMarker(t,this.options)}}),L.Draw.Circle=L.Draw.SimpleShape.extend({statics:{TYPE:"circle"},options:{shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},showRadius:!0,metric:!0,feet:!0,nautic:!1},initialize:function(t,e){this.type=L.Draw.Circle.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.circle.tooltip.start,L.Draw.SimpleShape.prototype.initialize.call(this,t,e);},_drawShape:function(t){if(L.GeometryUtil.isVersion07x())var e=this._startLatLng.distanceTo(t);else var e=this._map.distance(this._startLatLng,t);this._shape?this._shape.setRadius(e):(this._shape=new L.Circle(this._startLatLng,e,this.options.shapeOptions),this._map.addLayer(this._shape));},_fireCreatedEvent:function(){var t=new L.Circle(this._startLatLng,this._shape.getRadius(),this.options.shapeOptions);L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this,t);},_onMouseMove:function(t){var e,i=t.latlng,o=this.options.showRadius,a=this.options.metric;if(this._tooltip.updatePosition(i),this._isDrawing){this._drawShape(i),e=this._shape.getRadius().toFixed(1);var n="";o&&(n=L.drawLocal.draw.handlers.circle.radius+": "+L.GeometryUtil.readableDistance(e,a,this.options.feet,this.options.nautic)),this._tooltip.updateContent({text:this._endLabelText,subtext:n});}}}),L.Edit=L.Edit||{},L.Edit.Marker=L.Handler.extend({initialize:function(t,e){this._marker=t,L.setOptions(this,e);},addHooks:function(){var t=this._marker;t.dragging.enable(),t.on("dragend",this._onDragEnd,t),this._toggleMarkerHighlight();},removeHooks:function(){var t=this._marker;t.dragging.disable(),t.off("dragend",this._onDragEnd,t),this._toggleMarkerHighlight();},_onDragEnd:function(t){var e=t.target;e.edited=!0,this._map.fire(L.Draw.Event.EDITMOVE,{layer:e});},_toggleMarkerHighlight:function(){var t=this._marker._icon;t&&(t.style.display="none",L.DomUtil.hasClass(t,"leaflet-edit-marker-selected")?(L.DomUtil.removeClass(t,"leaflet-edit-marker-selected"),this._offsetMarker(t,-4)):(L.DomUtil.addClass(t,"leaflet-edit-marker-selected"),this._offsetMarker(t,4)),t.style.display="");},_offsetMarker:function(t,e){var i=parseInt(t.style.marginTop,10)-e,o=parseInt(t.style.marginLeft,10)-e;t.style.marginTop=i+"px",t.style.marginLeft=o+"px";}}),L.Marker.addInitHook(function(){L.Edit.Marker&&(this.editing=new L.Edit.Marker(this),this.options.editable&&this.editing.enable());}),L.Edit=L.Edit||{},L.Edit.Poly=L.Handler.extend({initialize:function(t){this.latlngs=[t._latlngs],t._holes&&(this.latlngs=this.latlngs.concat(t._holes)),this._poly=t,this._poly.on("revert-edited",this._updateLatLngs,this);},_defaultShape:function(){return L.Polyline._flat?L.Polyline._flat(this._poly._latlngs)?this._poly._latlngs:this._poly._latlngs[0]:this._poly._latlngs},_eachVertexHandler:function(t){for(var e=0;e<this._verticesHandlers.length;e++)t(this._verticesHandlers[e]);},addHooks:function(){this._initHandlers(),this._eachVertexHandler(function(t){t.addHooks();});},removeHooks:function(){this._eachVertexHandler(function(t){t.removeHooks();});},updateMarkers:function(){this._eachVertexHandler(function(t){t.updateMarkers();});},_initHandlers:function(){this._verticesHandlers=[];for(var t=0;t<this.latlngs.length;t++)this._verticesHandlers.push(new L.Edit.PolyVerticesEdit(this._poly,this.latlngs[t],this._poly.options.poly));},_updateLatLngs:function(t){this.latlngs=[t.layer._latlngs],t.layer._holes&&(this.latlngs=this.latlngs.concat(t.layer._holes));}}),L.Edit.PolyVerticesEdit=L.Handler.extend({options:{icon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon"}),touchIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon"}),drawError:{color:"#b00b00",timeout:1e3}},initialize:function(t,e,i){L.Browser.touch&&(this.options.icon=this.options.touchIcon),this._poly=t,i&&i.drawError&&(i.drawError=L.Util.extend({},this.options.drawError,i.drawError)),this._latlngs=e,L.setOptions(this,i);},_defaultShape:function(){return L.Polyline._flat?L.Polyline._flat(this._latlngs)?this._latlngs:this._latlngs[0]:this._latlngs},addHooks:function(){var t=this._poly,e=t._path;t instanceof L.Polygon||(t.options.fill=!1,t.options.editing&&(t.options.editing.fill=!1)),e&&t.options.editing&&t.options.editing.className&&(t.options.original.className&&t.options.original.className.split(" ").forEach(function(t){L.DomUtil.removeClass(e,t);}),t.options.editing.className.split(" ").forEach(function(t){L.DomUtil.addClass(e,t);})),t.setStyle(t.options.editing),this._poly._map&&(this._map=this._poly._map,this._markerGroup||this._initMarkers(),this._poly._map.addLayer(this._markerGroup));},removeHooks:function(){var t=this._poly,e=t._path;e&&t.options.editing&&t.options.editing.className&&(t.options.editing.className.split(" ").forEach(function(t){L.DomUtil.removeClass(e,t);}),t.options.original.className&&t.options.original.className.split(" ").forEach(function(t){L.DomUtil.addClass(e,t);})),t.setStyle(t.options.original),t._map&&(t._map.removeLayer(this._markerGroup),delete this._markerGroup,delete this._markers);},updateMarkers:function(){this._markerGroup.clearLayers(),this._initMarkers();},_initMarkers:function(){this._markerGroup||(this._markerGroup=new L.LayerGroup),this._markers=[];var t,e,i,o,a=this._defaultShape();for(t=0,i=a.length;t<i;t++)o=this._createMarker(a[t],t),o.on("click",this._onMarkerClick,this),o.on("contextmenu",this._onContextMenu,this),this._markers.push(o);var n,s;for(t=0,e=i-1;t<i;e=t++)(0!==t||L.Polygon&&this._poly instanceof L.Polygon)&&(n=this._markers[e],s=this._markers[t],this._createMiddleMarker(n,s),this._updatePrevNext(n,s));},_createMarker:function(t,e){var i=new L.Marker.Touch(t,{draggable:!0,icon:this.options.icon});return i._origLatLng=t,i._index=e,i.on("dragstart",this._onMarkerDragStart,this).on("drag",this._onMarkerDrag,this).on("dragend",this._fireEdit,this).on("touchmove",this._onTouchMove,this).on("touchend",this._fireEdit,this).on("MSPointerMove",this._onTouchMove,this).on("MSPointerUp",this._fireEdit,this),this._markerGroup.addLayer(i),i},_onMarkerDragStart:function(){this._poly.fire("editstart");},_spliceLatLngs:function(){var t=this._defaultShape(),e=[].splice.apply(t,arguments);return this._poly._convertLatLngs(t,!0),this._poly.redraw(),e},_removeMarker:function(t){var e=t._index;this._markerGroup.removeLayer(t),this._markers.splice(e,1),this._spliceLatLngs(e,1),this._updateIndexes(e,-1),t.off("dragstart",this._onMarkerDragStart,this).off("drag",this._onMarkerDrag,this).off("dragend",this._fireEdit,this).off("touchmove",this._onMarkerDrag,this).off("touchend",this._fireEdit,this).off("click",this._onMarkerClick,this).off("MSPointerMove",this._onTouchMove,this).off("MSPointerUp",this._fireEdit,this);},_fireEdit:function(){this._poly.edited=!0,this._poly.fire("edit"),this._poly._map.fire(L.Draw.Event.EDITVERTEX,{layers:this._markerGroup,poly:this._poly});},_onMarkerDrag:function(t){var e=t.target,i=this._poly,o=L.LatLngUtil.cloneLatLng(e._origLatLng);if(L.extend(e._origLatLng,e._latlng),i.options.poly){var a=i._map._editTooltip;if(!i.options.poly.allowIntersection&&i.intersects()){L.extend(e._origLatLng,o),e.setLatLng(o);var n=i.options.color;i.setStyle({color:this.options.drawError.color}),a&&a.updateContent({text:L.drawLocal.draw.handlers.polyline.error}),setTimeout(function(){i.setStyle({color:n}),a&&a.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext});},1e3);}}e._middleLeft&&e._middleLeft.setLatLng(this._getMiddleLatLng(e._prev,e)),e._middleRight&&e._middleRight.setLatLng(this._getMiddleLatLng(e,e._next)),this._poly._bounds._southWest=L.latLng(1/0,1/0),this._poly._bounds._northEast=L.latLng(-1/0,-1/0);var s=this._poly.getLatLngs();this._poly._convertLatLngs(s,!0),this._poly.redraw(),this._poly.fire("editdrag");},_onMarkerClick:function(t){var e=L.Polygon&&this._poly instanceof L.Polygon?4:3,i=t.target;this._defaultShape().length<e||(this._removeMarker(i),this._updatePrevNext(i._prev,i._next),i._middleLeft&&this._markerGroup.removeLayer(i._middleLeft),i._middleRight&&this._markerGroup.removeLayer(i._middleRight),i._prev&&i._next?this._createMiddleMarker(i._prev,i._next):i._prev?i._next||(i._prev._middleRight=null):i._next._middleLeft=null,this._fireEdit());},_onContextMenu:function(t){var e=t.target;this._poly;this._poly._map.fire(L.Draw.Event.MARKERCONTEXT,{marker:e,layers:this._markerGroup,poly:this._poly}),L.DomEvent.stopPropagation;},_onTouchMove:function(t){var e=this._map.mouseEventToLayerPoint(t.originalEvent.touches[0]),i=this._map.layerPointToLatLng(e),o=t.target;L.extend(o._origLatLng,i),o._middleLeft&&o._middleLeft.setLatLng(this._getMiddleLatLng(o._prev,o)),o._middleRight&&o._middleRight.setLatLng(this._getMiddleLatLng(o,o._next)),this._poly.redraw(),this.updateMarkers();},_updateIndexes:function(t,e){this._markerGroup.eachLayer(function(i){i._index>t&&(i._index+=e);});},_createMiddleMarker:function(t,e){var i,o,a,n=this._getMiddleLatLng(t,e),s=this._createMarker(n);s.setOpacity(.6),t._middleRight=e._middleLeft=s,o=function(){s.off("touchmove",o,this);var a=e._index;s._index=a,s.off("click",i,this).on("click",this._onMarkerClick,this),n.lat=s.getLatLng().lat,n.lng=s.getLatLng().lng,this._spliceLatLngs(a,0,n),this._markers.splice(a,0,s),s.setOpacity(1),this._updateIndexes(a,1),e._index++,this._updatePrevNext(t,s),this._updatePrevNext(s,e),this._poly.fire("editstart");},a=function(){s.off("dragstart",o,this),s.off("dragend",a,this),s.off("touchmove",o,this),this._createMiddleMarker(t,s),this._createMiddleMarker(s,e);},i=function(){o.call(this),a.call(this),this._fireEdit();},s.on("click",i,this).on("dragstart",o,this).on("dragend",a,this).on("touchmove",o,this),this._markerGroup.addLayer(s);},_updatePrevNext:function(t,e){t&&(t._next=e),e&&(e._prev=t);},_getMiddleLatLng:function(t,e){var i=this._poly._map,o=i.project(t.getLatLng()),a=i.project(e.getLatLng());return i.unproject(o._add(a)._divideBy(2))}}),L.Polyline.addInitHook(function(){this.editing||(L.Edit.Poly&&(this.editing=new L.Edit.Poly(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks();}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks();}));}),L.Edit=L.Edit||{},L.Edit.SimpleShape=L.Handler.extend({options:{moveIcon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-move"}),resizeIcon:new L.DivIcon({iconSize:new L.Point(8,8),
	className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize"}),touchMoveIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-move leaflet-touch-icon"}),touchResizeIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize leaflet-touch-icon"})},initialize:function(t,e){L.Browser.touch&&(this.options.moveIcon=this.options.touchMoveIcon,this.options.resizeIcon=this.options.touchResizeIcon),this._shape=t,L.Util.setOptions(this,e);},addHooks:function(){var t=this._shape;this._shape._map&&(this._map=this._shape._map,t.setStyle(t.options.editing),t._map&&(this._map=t._map,this._markerGroup||this._initMarkers(),this._map.addLayer(this._markerGroup)));},removeHooks:function(){var t=this._shape;if(t.setStyle(t.options.original),t._map){this._unbindMarker(this._moveMarker);for(var e=0,i=this._resizeMarkers.length;e<i;e++)this._unbindMarker(this._resizeMarkers[e]);this._resizeMarkers=null,this._map.removeLayer(this._markerGroup),delete this._markerGroup;}this._map=null;},updateMarkers:function(){this._markerGroup.clearLayers(),this._initMarkers();},_initMarkers:function(){this._markerGroup||(this._markerGroup=new L.LayerGroup),this._createMoveMarker(),this._createResizeMarker();},_createMoveMarker:function(){},_createResizeMarker:function(){},_createMarker:function(t,e){var i=new L.Marker.Touch(t,{draggable:!0,icon:e,zIndexOffset:10});return this._bindMarker(i),this._markerGroup.addLayer(i),i},_bindMarker:function(t){t.on("dragstart",this._onMarkerDragStart,this).on("drag",this._onMarkerDrag,this).on("dragend",this._onMarkerDragEnd,this).on("touchstart",this._onTouchStart,this).on("touchmove",this._onTouchMove,this).on("MSPointerMove",this._onTouchMove,this).on("touchend",this._onTouchEnd,this).on("MSPointerUp",this._onTouchEnd,this);},_unbindMarker:function(t){t.off("dragstart",this._onMarkerDragStart,this).off("drag",this._onMarkerDrag,this).off("dragend",this._onMarkerDragEnd,this).off("touchstart",this._onTouchStart,this).off("touchmove",this._onTouchMove,this).off("MSPointerMove",this._onTouchMove,this).off("touchend",this._onTouchEnd,this).off("MSPointerUp",this._onTouchEnd,this);},_onMarkerDragStart:function(t){t.target.setOpacity(0),this._shape.fire("editstart");},_fireEdit:function(){this._shape.edited=!0,this._shape.fire("edit");},_onMarkerDrag:function(t){var e=t.target,i=e.getLatLng();e===this._moveMarker?this._move(i):this._resize(i),this._shape.redraw(),this._shape.fire("editdrag");},_onMarkerDragEnd:function(t){t.target.setOpacity(1),this._fireEdit();},_onTouchStart:function(t){if(L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this,t),"function"==typeof this._getCorners){var e=this._getCorners(),i=t.target,o=i._cornerIndex;i.setOpacity(0),this._oppositeCorner=e[(o+2)%4],this._toggleCornerMarkers(0,o);}this._shape.fire("editstart");},_onTouchMove:function(t){var e=this._map.mouseEventToLayerPoint(t.originalEvent.touches[0]),i=this._map.layerPointToLatLng(e);return t.target===this._moveMarker?this._move(i):this._resize(i),this._shape.redraw(),!1},_onTouchEnd:function(t){t.target.setOpacity(1),this.updateMarkers(),this._fireEdit();},_move:function(){},_resize:function(){}}),L.Edit=L.Edit||{},L.Edit.Rectangle=L.Edit.SimpleShape.extend({_createMoveMarker:function(){var t=this._shape.getBounds(),e=t.getCenter();this._moveMarker=this._createMarker(e,this.options.moveIcon);},_createResizeMarker:function(){var t=this._getCorners();this._resizeMarkers=[];for(var e=0,i=t.length;e<i;e++)this._resizeMarkers.push(this._createMarker(t[e],this.options.resizeIcon)),this._resizeMarkers[e]._cornerIndex=e;},_onMarkerDragStart:function(t){L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this,t);var e=this._getCorners(),i=t.target,o=i._cornerIndex;this._oppositeCorner=e[(o+2)%4],this._toggleCornerMarkers(0,o);},_onMarkerDragEnd:function(t){var e,i,o=t.target;o===this._moveMarker&&(e=this._shape.getBounds(),i=e.getCenter(),o.setLatLng(i)),this._toggleCornerMarkers(1),this._repositionCornerMarkers(),L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this,t);},_move:function(t){for(var e,i=this._shape._defaultShape?this._shape._defaultShape():this._shape.getLatLngs(),o=this._shape.getBounds(),a=o.getCenter(),n=[],s=0,r=i.length;s<r;s++)e=[i[s].lat-a.lat,i[s].lng-a.lng],n.push([t.lat+e[0],t.lng+e[1]]);this._shape.setLatLngs(n),this._repositionCornerMarkers(),this._map.fire(L.Draw.Event.EDITMOVE,{layer:this._shape});},_resize:function(t){var e;this._shape.setBounds(L.latLngBounds(t,this._oppositeCorner)),e=this._shape.getBounds(),this._moveMarker.setLatLng(e.getCenter()),this._map.fire(L.Draw.Event.EDITRESIZE,{layer:this._shape});},_getCorners:function(){var t=this._shape.getBounds();return [t.getNorthWest(),t.getNorthEast(),t.getSouthEast(),t.getSouthWest()]},_toggleCornerMarkers:function(t){for(var e=0,i=this._resizeMarkers.length;e<i;e++)this._resizeMarkers[e].setOpacity(t);},_repositionCornerMarkers:function(){for(var t=this._getCorners(),e=0,i=this._resizeMarkers.length;e<i;e++)this._resizeMarkers[e].setLatLng(t[e]);}}),L.Rectangle.addInitHook(function(){L.Edit.Rectangle&&(this.editing=new L.Edit.Rectangle(this),this.options.editable&&this.editing.enable());}),L.Edit=L.Edit||{},L.Edit.CircleMarker=L.Edit.SimpleShape.extend({_createMoveMarker:function(){var t=this._shape.getLatLng();this._moveMarker=this._createMarker(t,this.options.moveIcon);},_createResizeMarker:function(){this._resizeMarkers=[];},_move:function(t){if(this._resizeMarkers.length){var e=this._getResizeMarkerPoint(t);this._resizeMarkers[0].setLatLng(e);}this._shape.setLatLng(t),this._map.fire(L.Draw.Event.EDITMOVE,{layer:this._shape});}}),L.CircleMarker.addInitHook(function(){L.Edit.CircleMarker&&(this.editing=new L.Edit.CircleMarker(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks();}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks();});}),L.Edit=L.Edit||{},L.Edit.Circle=L.Edit.CircleMarker.extend({_createResizeMarker:function(){var t=this._shape.getLatLng(),e=this._getResizeMarkerPoint(t);this._resizeMarkers=[],this._resizeMarkers.push(this._createMarker(e,this.options.resizeIcon));},_getResizeMarkerPoint:function(t){var e=this._shape._radius*Math.cos(Math.PI/4),i=this._map.project(t);return this._map.unproject([i.x+e,i.y-e])},_resize:function(t){var e=this._moveMarker.getLatLng();L.GeometryUtil.isVersion07x()?radius=e.distanceTo(t):radius=this._map.distance(e,t),this._shape.setRadius(radius),this._map.editTooltip&&this._map._editTooltip.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.subtext+"<br />"+L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.draw.handlers.circle.radius+": "+L.GeometryUtil.readableDistance(radius,!0,this.options.feet,this.options.nautic)}),this._shape.setRadius(radius),this._map.fire(L.Draw.Event.EDITRESIZE,{layer:this._shape});}}),L.Circle.addInitHook(function(){L.Edit.Circle&&(this.editing=new L.Edit.Circle(this),this.options.editable&&this.editing.enable());}),L.Map.mergeOptions({touchExtend:!0}),L.Map.TouchExtend=L.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane;},addHooks:function(){L.DomEvent.on(this._container,"touchstart",this._onTouchStart,this),L.DomEvent.on(this._container,"touchend",this._onTouchEnd,this),L.DomEvent.on(this._container,"touchmove",this._onTouchMove,this),this._detectIE()?(L.DomEvent.on(this._container,"MSPointerDown",this._onTouchStart,this),L.DomEvent.on(this._container,"MSPointerUp",this._onTouchEnd,this),L.DomEvent.on(this._container,"MSPointerMove",this._onTouchMove,this),L.DomEvent.on(this._container,"MSPointerCancel",this._onTouchCancel,this)):(L.DomEvent.on(this._container,"touchcancel",this._onTouchCancel,this),L.DomEvent.on(this._container,"touchleave",this._onTouchLeave,this));},removeHooks:function(){L.DomEvent.off(this._container,"touchstart",this._onTouchStart,this),L.DomEvent.off(this._container,"touchend",this._onTouchEnd,this),L.DomEvent.off(this._container,"touchmove",this._onTouchMove,this),this._detectIE()?(L.DomEvent.off(this._container,"MSPointerDown",this._onTouchStart,this),L.DomEvent.off(this._container,"MSPointerUp",this._onTouchEnd,this),L.DomEvent.off(this._container,"MSPointerMove",this._onTouchMove,this),L.DomEvent.off(this._container,"MSPointerCancel",this._onTouchCancel,this)):(L.DomEvent.off(this._container,"touchcancel",this._onTouchCancel,this),L.DomEvent.off(this._container,"touchleave",this._onTouchLeave,this));},_touchEvent:function(t,e){var i={};if(void 0!==t.touches){if(!t.touches.length)return;i=t.touches[0];}else{if("touch"!==t.pointerType)return;if(i=t,!this._filterClick(t))return}var o=this._map.mouseEventToContainerPoint(i),a=this._map.mouseEventToLayerPoint(i),n=this._map.layerPointToLatLng(a);this._map.fire(e,{latlng:n,layerPoint:a,containerPoint:o,pageX:i.pageX,pageY:i.pageY,originalEvent:t});},_filterClick:function(t){var e=t.timeStamp||t.originalEvent.timeStamp,i=L.DomEvent._lastClick&&e-L.DomEvent._lastClick;return i&&i>100&&i<500||t.target._simulatedClick&&!t._simulated?(L.DomEvent.stop(t),!1):(L.DomEvent._lastClick=e,!0)},_onTouchStart:function(t){if(this._map._loaded){this._touchEvent(t,"touchstart");}},_onTouchEnd:function(t){if(this._map._loaded){this._touchEvent(t,"touchend");}},_onTouchCancel:function(t){if(this._map._loaded){var e="touchcancel";this._detectIE()&&(e="pointercancel"),this._touchEvent(t,e);}},_onTouchLeave:function(t){if(this._map._loaded){this._touchEvent(t,"touchleave");}},_onTouchMove:function(t){if(this._map._loaded){this._touchEvent(t,"touchmove");}},_detectIE:function(){var e=t.navigator.userAgent,i=e.indexOf("MSIE ");if(i>0)return parseInt(e.substring(i+5,e.indexOf(".",i)),10);if(e.indexOf("Trident/")>0){var o=e.indexOf("rv:");return parseInt(e.substring(o+3,e.indexOf(".",o)),10)}var a=e.indexOf("Edge/");return a>0&&parseInt(e.substring(a+5,e.indexOf(".",a)),10)}}),L.Map.addInitHook("addHandler","touchExtend",L.Map.TouchExtend),L.Marker.Touch=L.Marker.extend({_initInteraction:function(){return this.addInteractiveTarget?L.Marker.prototype._initInteraction.apply(this):this._initInteractionLegacy()},_initInteractionLegacy:function(){if(this.options.clickable){var t=this._icon,e=["dblclick","mousedown","mouseover","mouseout","contextmenu","touchstart","touchend","touchmove"];this._detectIE?e.concat(["MSPointerDown","MSPointerUp","MSPointerMove","MSPointerCancel"]):e.concat(["touchcancel"]),L.DomUtil.addClass(t,"leaflet-clickable"),L.DomEvent.on(t,"click",this._onMouseClick,this),L.DomEvent.on(t,"keypress",this._onKeyPress,this);for(var i=0;i<e.length;i++)L.DomEvent.on(t,e[i],this._fireMouseEvent,this);L.Handler.MarkerDrag&&(this.dragging=new L.Handler.MarkerDrag(this),this.options.draggable&&this.dragging.enable());}},_detectIE:function(){var e=t.navigator.userAgent,i=e.indexOf("MSIE ");if(i>0)return parseInt(e.substring(i+5,e.indexOf(".",i)),10);if(e.indexOf("Trident/")>0){var o=e.indexOf("rv:");return parseInt(e.substring(o+3,e.indexOf(".",o)),10)}var a=e.indexOf("Edge/");return a>0&&parseInt(e.substring(a+5,e.indexOf(".",a)),10)}}),L.LatLngUtil={cloneLatLngs:function(t){for(var e=[],i=0,o=t.length;i<o;i++)Array.isArray(t[i])?e.push(L.LatLngUtil.cloneLatLngs(t[i])):e.push(this.cloneLatLng(t[i]));return e},cloneLatLng:function(t){return L.latLng(t.lat,t.lng)}},function(){var t={km:2,ha:2,m:0,mi:2,ac:2,yd:0,ft:0,nm:2};L.GeometryUtil=L.extend(L.GeometryUtil||{},{geodesicArea:function(t){var e,i,o=t.length,a=0,n=Math.PI/180;if(o>2){for(var s=0;s<o;s++)e=t[s],i=t[(s+1)%o],a+=(i.lng-e.lng)*n*(2+Math.sin(e.lat*n)+Math.sin(i.lat*n));a=6378137*a*6378137/2;}return Math.abs(a)},formattedNumber:function(t,e){var i=parseFloat(t).toFixed(e),o=L.drawLocal.format&&L.drawLocal.format.numeric,a=o&&o.delimiters,n=a&&a.thousands,s=a&&a.decimal;if(n||s){var r=i.split(".");i=n?r[0].replace(/(\d)(?=(\d{3})+(?!\d))/g,"$1"+n):r[0],s=s||".",r.length>1&&(i=i+s+r[1]);}return i},readableArea:function(e,i,o){var a,n,s,o=L.Util.extend({},t,o);return i?(n=["ha","m"],s=typeof i,"string"===s?n=[i]:"boolean"!==s&&(n=i),a=e>=1e6&&-1!==n.indexOf("km")?L.GeometryUtil.formattedNumber(1e-6*e,o.km)+" km²":e>=1e4&&-1!==n.indexOf("ha")?L.GeometryUtil.formattedNumber(1e-4*e,o.ha)+" ha":L.GeometryUtil.formattedNumber(e,o.m)+" m²"):(e/=.836127,a=e>=3097600?L.GeometryUtil.formattedNumber(e/3097600,o.mi)+" mi²":e>=4840?L.GeometryUtil.formattedNumber(e/4840,o.ac)+" acres":L.GeometryUtil.formattedNumber(e,o.yd)+" yd²"),a},readableDistance:function(e,i,o,a,n){var s,n=L.Util.extend({},t,n);switch(i?"string"==typeof i?i:"metric":o?"feet":a?"nauticalMile":"yards"){case"metric":s=e>1e3?L.GeometryUtil.formattedNumber(e/1e3,n.km)+" km":L.GeometryUtil.formattedNumber(e,n.m)+" m";break;case"feet":e*=3.28083,s=L.GeometryUtil.formattedNumber(e,n.ft)+" ft";break;case"nauticalMile":e*=.53996,s=L.GeometryUtil.formattedNumber(e/1e3,n.nm)+" nm";break;case"yards":default:e*=1.09361,s=e>1760?L.GeometryUtil.formattedNumber(e/1760,n.mi)+" miles":L.GeometryUtil.formattedNumber(e,n.yd)+" yd";}return s},isVersion07x:function(){var t=L.version.split(".");return 0===parseInt(t[0],10)&&7===parseInt(t[1],10)}});}(),L.Util.extend(L.LineUtil,{segmentsIntersect:function(t,e,i,o){return this._checkCounterclockwise(t,i,o)!==this._checkCounterclockwise(e,i,o)&&this._checkCounterclockwise(t,e,i)!==this._checkCounterclockwise(t,e,o)},_checkCounterclockwise:function(t,e,i){return (i.y-t.y)*(e.x-t.x)>(e.y-t.y)*(i.x-t.x)}}),L.Polyline.include({intersects:function(){var t,e,i,o=this._getProjectedPoints(),a=o?o.length:0;if(this._tooFewPointsForIntersection())return !1;for(t=a-1;t>=3;t--)if(e=o[t-1],i=o[t],this._lineSegmentsIntersectsRange(e,i,t-2))return !0;return !1},newLatLngIntersects:function(t,e){return !!this._map&&this.newPointIntersects(this._map.latLngToLayerPoint(t),e)},newPointIntersects:function(t,e){var i=this._getProjectedPoints(),o=i?i.length:0,a=i?i[o-1]:null,n=o-2;return !this._tooFewPointsForIntersection(1)&&this._lineSegmentsIntersectsRange(a,t,n,e?1:0)},_tooFewPointsForIntersection:function(t){var e=this._getProjectedPoints(),i=e?e.length:0;return i+=t||0,!e||i<=3},_lineSegmentsIntersectsRange:function(t,e,i,o){var a,n,s=this._getProjectedPoints();o=o||0;for(var r=i;r>o;r--)if(a=s[r-1],n=s[r],L.LineUtil.segmentsIntersect(t,e,a,n))return !0;return !1},_getProjectedPoints:function(){if(!this._defaultShape)return this._originalPoints;for(var t=[],e=this._defaultShape(),i=0;i<e.length;i++)t.push(this._map.latLngToLayerPoint(e[i]));return t}}),L.Polygon.include({intersects:function(){var t,e,i,o,a=this._getProjectedPoints();return !this._tooFewPointsForIntersection()&&(!!L.Polyline.prototype.intersects.call(this)||(t=a.length,e=a[0],i=a[t-1],o=t-2,this._lineSegmentsIntersectsRange(i,e,o,1)))}}),L.Control.Draw=L.Control.extend({options:{position:"topleft",draw:{},edit:!1},initialize:function(t){if(L.version<"0.7")throw new Error("Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/");L.Control.prototype.initialize.call(this,t);var e;this._toolbars={},L.DrawToolbar&&this.options.draw&&(e=new L.DrawToolbar(this.options.draw),this._toolbars[L.DrawToolbar.TYPE]=e,this._toolbars[L.DrawToolbar.TYPE].on("enable",this._toolbarEnabled,this)),L.EditToolbar&&this.options.edit&&(e=new L.EditToolbar(this.options.edit),this._toolbars[L.EditToolbar.TYPE]=e,this._toolbars[L.EditToolbar.TYPE].on("enable",this._toolbarEnabled,this)),L.toolbar=this;},onAdd:function(t){var e,i=L.DomUtil.create("div","leaflet-draw"),o=!1;for(var a in this._toolbars)this._toolbars.hasOwnProperty(a)&&(e=this._toolbars[a].addToolbar(t))&&(o||(L.DomUtil.hasClass(e,"leaflet-draw-toolbar-top")||L.DomUtil.addClass(e.childNodes[0],"leaflet-draw-toolbar-top"),o=!0),i.appendChild(e));return i},onRemove:function(){for(var t in this._toolbars)this._toolbars.hasOwnProperty(t)&&this._toolbars[t].removeToolbar();},setDrawingOptions:function(t){for(var e in this._toolbars)this._toolbars[e]instanceof L.DrawToolbar&&this._toolbars[e].setOptions(t);},_toolbarEnabled:function(t){var e=t.target;for(var i in this._toolbars)this._toolbars[i]!==e&&this._toolbars[i].disable();}}),L.Map.mergeOptions({drawControlTooltips:!0,drawControl:!1}),L.Map.addInitHook(function(){this.options.drawControl&&(this.drawControl=new L.Control.Draw,this.addControl(this.drawControl));}),L.Toolbar=L.Class.extend({initialize:function(t){L.setOptions(this,t),this._modes={},this._actionButtons=[],this._activeMode=null;var e=L.version.split(".");1===parseInt(e[0],10)&&parseInt(e[1],10)>=2?L.Toolbar.include(L.Evented.prototype):L.Toolbar.include(L.Mixin.Events);},enabled:function(){return null!==this._activeMode},disable:function(){this.enabled()&&this._activeMode.handler.disable();},addToolbar:function(t){var e,i=L.DomUtil.create("div","leaflet-draw-section"),o=0,a=this._toolbarClass||"",n=this.getModeHandlers(t);for(this._toolbarContainer=L.DomUtil.create("div","leaflet-draw-toolbar leaflet-bar"),this._map=t,e=0;e<n.length;e++)n[e].enabled&&this._initModeHandler(n[e].handler,this._toolbarContainer,o++,a,n[e].title);if(o)return this._lastButtonIndex=--o,this._actionsContainer=L.DomUtil.create("ul","leaflet-draw-actions"),i.appendChild(this._toolbarContainer),i.appendChild(this._actionsContainer),i},removeToolbar:function(){for(var t in this._modes)this._modes.hasOwnProperty(t)&&(this._disposeButton(this._modes[t].button,this._modes[t].handler.enable,this._modes[t].handler),this._modes[t].handler.disable(),this._modes[t].handler.off("enabled",this._handlerActivated,this).off("disabled",this._handlerDeactivated,this));this._modes={};for(var e=0,i=this._actionButtons.length;e<i;e++)this._disposeButton(this._actionButtons[e].button,this._actionButtons[e].callback,this);this._actionButtons=[],this._actionsContainer=null;},_initModeHandler:function(t,e,i,o,a){var n=t.type;this._modes[n]={},this._modes[n].handler=t,this._modes[n].button=this._createButton({type:n,title:a,className:o+"-"+n,container:e,callback:this._modes[n].handler.enable,context:this._modes[n].handler}),this._modes[n].buttonIndex=i,this._modes[n].handler.on("enabled",this._handlerActivated,this).on("disabled",this._handlerDeactivated,this);},_detectIOS:function(){return /iPad|iPhone|iPod/.test(navigator.userAgent)&&!t.MSStream},_createButton:function(t){var e=L.DomUtil.create("a",t.className||"",t.container),i=L.DomUtil.create("span","sr-only",t.container);e.href="#",e.appendChild(i),t.title&&(e.title=t.title,i.innerHTML=t.title),t.text&&(e.innerHTML=t.text,i.innerHTML=t.text);var o=this._detectIOS()?"touchstart":"click";return L.DomEvent.on(e,"click",L.DomEvent.stopPropagation).on(e,"mousedown",L.DomEvent.stopPropagation).on(e,"dblclick",L.DomEvent.stopPropagation).on(e,"touchstart",L.DomEvent.stopPropagation).on(e,"click",L.DomEvent.preventDefault).on(e,o,t.callback,t.context),e},_disposeButton:function(t,e){var i=this._detectIOS()?"touchstart":"click";L.DomEvent.off(t,"click",L.DomEvent.stopPropagation).off(t,"mousedown",L.DomEvent.stopPropagation).off(t,"dblclick",L.DomEvent.stopPropagation).off(t,"touchstart",L.DomEvent.stopPropagation).off(t,"click",L.DomEvent.preventDefault).off(t,i,e);},_handlerActivated:function(t){this.disable(),this._activeMode=this._modes[t.handler],L.DomUtil.addClass(this._activeMode.button,"leaflet-draw-toolbar-button-enabled"),this._showActionsToolbar(),this.fire("enable");},_handlerDeactivated:function(){this._hideActionsToolbar(),L.DomUtil.removeClass(this._activeMode.button,"leaflet-draw-toolbar-button-enabled"),this._activeMode=null,this.fire("disable");},_createActions:function(t){var e,i,o,a,n=this._actionsContainer,s=this.getActions(t),r=s.length;for(i=0,o=this._actionButtons.length;i<o;i++)this._disposeButton(this._actionButtons[i].button,this._actionButtons[i].callback);for(this._actionButtons=[];n.firstChild;)n.removeChild(n.firstChild);for(var l=0;l<r;l++)"enabled"in s[l]&&!s[l].enabled||(e=L.DomUtil.create("li","",n),a=this._createButton({title:s[l].title,text:s[l].text,container:e,callback:s[l].callback,context:s[l].context}),this._actionButtons.push({button:a,callback:s[l].callback}));},_showActionsToolbar:function(){var t=this._activeMode.buttonIndex,e=this._lastButtonIndex,i=this._activeMode.button.offsetTop-1;this._createActions(this._activeMode.handler),this._actionsContainer.style.top=i+"px",0===t&&(L.DomUtil.addClass(this._toolbarContainer,"leaflet-draw-toolbar-notop"),L.DomUtil.addClass(this._actionsContainer,"leaflet-draw-actions-top")),t===e&&(L.DomUtil.addClass(this._toolbarContainer,"leaflet-draw-toolbar-nobottom"),L.DomUtil.addClass(this._actionsContainer,"leaflet-draw-actions-bottom")),this._actionsContainer.style.display="block",this._map.fire(L.Draw.Event.TOOLBAROPENED);},_hideActionsToolbar:function(){this._actionsContainer.style.display="none",L.DomUtil.removeClass(this._toolbarContainer,"leaflet-draw-toolbar-notop"),L.DomUtil.removeClass(this._toolbarContainer,"leaflet-draw-toolbar-nobottom"),L.DomUtil.removeClass(this._actionsContainer,"leaflet-draw-actions-top"),L.DomUtil.removeClass(this._actionsContainer,"leaflet-draw-actions-bottom"),this._map.fire(L.Draw.Event.TOOLBARCLOSED);}}),L.Draw=L.Draw||{},L.Draw.Tooltip=L.Class.extend({initialize:function(t){this._map=t,this._popupPane=t._panes.popupPane,this._visible=!1,this._container=t.options.drawControlTooltips?L.DomUtil.create("div","leaflet-draw-tooltip",this._popupPane):null,this._singleLineLabel=!1,this._map.on("mouseout",this._onMouseOut,this);},dispose:function(){this._map.off("mouseout",this._onMouseOut,this),this._container&&(this._popupPane.removeChild(this._container),this._container=null);},updateContent:function(t){return this._container?(t.subtext=t.subtext||"",0!==t.subtext.length||this._singleLineLabel?t.subtext.length>0&&this._singleLineLabel&&(L.DomUtil.removeClass(this._container,"leaflet-draw-tooltip-single"),this._singleLineLabel=!1):(L.DomUtil.addClass(this._container,"leaflet-draw-tooltip-single"),this._singleLineLabel=!0),this._container.innerHTML=(t.subtext.length>0?'<span class="leaflet-draw-tooltip-subtext">'+t.subtext+"</span><br />":"")+"<span>"+t.text+"</span>",t.text||t.subtext?(this._visible=!0,this._container.style.visibility="inherit"):(this._visible=!1,this._container.style.visibility="hidden"),this):this},updatePosition:function(t){var e=this._map.latLngToLayerPoint(t),i=this._container;return this._container&&(this._visible&&(i.style.visibility="inherit"),L.DomUtil.setPosition(i,e)),this},showAsError:function(){return this._container&&L.DomUtil.addClass(this._container,"leaflet-error-draw-tooltip"),this},removeError:function(){return this._container&&L.DomUtil.removeClass(this._container,"leaflet-error-draw-tooltip"),this},_onMouseOut:function(){this._container&&(this._container.style.visibility="hidden");}}),L.DrawToolbar=L.Toolbar.extend({statics:{TYPE:"draw"},options:{polyline:{},polygon:{},rectangle:{},circle:{},marker:{},circlemarker:{}},initialize:function(t){for(var e in this.options)this.options.hasOwnProperty(e)&&t[e]&&(t[e]=L.extend({},this.options[e],t[e]));this._toolbarClass="leaflet-draw-draw",L.Toolbar.prototype.initialize.call(this,t);},getModeHandlers:function(t){return [{enabled:this.options.polyline,handler:new L.Draw.Polyline(t,this.options.polyline),title:L.drawLocal.draw.toolbar.buttons.polyline},{enabled:this.options.polygon,handler:new L.Draw.Polygon(t,this.options.polygon),title:L.drawLocal.draw.toolbar.buttons.polygon},{enabled:this.options.rectangle,handler:new L.Draw.Rectangle(t,this.options.rectangle),title:L.drawLocal.draw.toolbar.buttons.rectangle},{enabled:this.options.circle,handler:new L.Draw.Circle(t,this.options.circle),title:L.drawLocal.draw.toolbar.buttons.circle},{enabled:this.options.marker,handler:new L.Draw.Marker(t,this.options.marker),title:L.drawLocal.draw.toolbar.buttons.marker},{enabled:this.options.circlemarker,handler:new L.Draw.CircleMarker(t,this.options.circlemarker),title:L.drawLocal.draw.toolbar.buttons.circlemarker}]},getActions:function(t){return [{enabled:t.completeShape,title:L.drawLocal.draw.toolbar.finish.title,text:L.drawLocal.draw.toolbar.finish.text,callback:t.completeShape,context:t},{enabled:t.deleteLastVertex,title:L.drawLocal.draw.toolbar.undo.title,text:L.drawLocal.draw.toolbar.undo.text,callback:t.deleteLastVertex,context:t},{title:L.drawLocal.draw.toolbar.actions.title,text:L.drawLocal.draw.toolbar.actions.text,callback:this.disable,context:this}]},setOptions:function(t){L.setOptions(this,t);for(var e in this._modes)this._modes.hasOwnProperty(e)&&t.hasOwnProperty(e)&&this._modes[e].handler.setOptions(t[e]);}}),L.EditToolbar=L.Toolbar.extend({statics:{TYPE:"edit"},options:{edit:{selectedPathOptions:{dashArray:"10, 10",fill:!0,fillColor:"#fe57a1",fillOpacity:.1,maintainColor:!1}},remove:{},poly:null,featureGroup:null},initialize:function(t){t.edit&&(void 0===t.edit.selectedPathOptions&&(t.edit.selectedPathOptions=this.options.edit.selectedPathOptions),t.edit.selectedPathOptions=L.extend({},this.options.edit.selectedPathOptions,t.edit.selectedPathOptions)),t.remove&&(t.remove=L.extend({},this.options.remove,t.remove)),t.poly&&(t.poly=L.extend({},this.options.poly,t.poly)),this._toolbarClass="leaflet-draw-edit",L.Toolbar.prototype.initialize.call(this,t),this._selectedFeatureCount=0;},getModeHandlers:function(t){var e=this.options.featureGroup;return [{enabled:this.options.edit,handler:new L.EditToolbar.Edit(t,{featureGroup:e,selectedPathOptions:this.options.edit.selectedPathOptions,poly:this.options.poly}),title:L.drawLocal.edit.toolbar.buttons.edit},{enabled:this.options.remove,handler:new L.EditToolbar.Delete(t,{featureGroup:e}),title:L.drawLocal.edit.toolbar.buttons.remove}]},getActions:function(t){var e=[{title:L.drawLocal.edit.toolbar.actions.save.title,text:L.drawLocal.edit.toolbar.actions.save.text,callback:this._save,context:this},{title:L.drawLocal.edit.toolbar.actions.cancel.title,text:L.drawLocal.edit.toolbar.actions.cancel.text,callback:this.disable,context:this}];return t.removeAllLayers&&e.push({title:L.drawLocal.edit.toolbar.actions.clearAll.title,text:L.drawLocal.edit.toolbar.actions.clearAll.text,callback:this._clearAllLayers,context:this}),e},addToolbar:function(t){var e=L.Toolbar.prototype.addToolbar.call(this,t);return this._checkDisabled(),this.options.featureGroup.on("layeradd layerremove",this._checkDisabled,this),e},removeToolbar:function(){this.options.featureGroup.off("layeradd layerremove",this._checkDisabled,this),L.Toolbar.prototype.removeToolbar.call(this);},disable:function(){this.enabled()&&(this._activeMode.handler.revertLayers(),L.Toolbar.prototype.disable.call(this));},_save:function(){this._activeMode.handler.save(),this._activeMode&&this._activeMode.handler.disable();},_clearAllLayers:function(){this._activeMode.handler.removeAllLayers(),this._activeMode&&this._activeMode.handler.disable();},_checkDisabled:function(){var t,e=this.options.featureGroup,i=0!==e.getLayers().length;this.options.edit&&(t=this._modes[L.EditToolbar.Edit.TYPE].button,i?L.DomUtil.removeClass(t,"leaflet-disabled"):L.DomUtil.addClass(t,"leaflet-disabled"),t.setAttribute("title",i?L.drawLocal.edit.toolbar.buttons.edit:L.drawLocal.edit.toolbar.buttons.editDisabled)),this.options.remove&&(t=this._modes[L.EditToolbar.Delete.TYPE].button,i?L.DomUtil.removeClass(t,"leaflet-disabled"):L.DomUtil.addClass(t,"leaflet-disabled"),t.setAttribute("title",i?L.drawLocal.edit.toolbar.buttons.remove:L.drawLocal.edit.toolbar.buttons.removeDisabled));}}),L.EditToolbar.Edit=L.Handler.extend({statics:{TYPE:"edit"},initialize:function(t,e){if(L.Handler.prototype.initialize.call(this,t),L.setOptions(this,e),this._featureGroup=e.featureGroup,!(this._featureGroup instanceof L.FeatureGroup))throw new Error("options.featureGroup must be a L.FeatureGroup");this._uneditedLayerProps={},this.type=L.EditToolbar.Edit.TYPE;var i=L.version.split(".");1===parseInt(i[0],10)&&parseInt(i[1],10)>=2?L.EditToolbar.Edit.include(L.Evented.prototype):L.EditToolbar.Edit.include(L.Mixin.Events);},enable:function(){!this._enabled&&this._hasAvailableLayers()&&(this.fire("enabled",{handler:this.type}),this._map.fire(L.Draw.Event.EDITSTART,{handler:this.type}),L.Handler.prototype.enable.call(this),this._featureGroup.on("layeradd",this._enableLayerEdit,this).on("layerremove",this._disableLayerEdit,this));},disable:function(){this._enabled&&(this._featureGroup.off("layeradd",this._enableLayerEdit,this).off("layerremove",this._disableLayerEdit,this),L.Handler.prototype.disable.call(this),this._map.fire(L.Draw.Event.EDITSTOP,{handler:this.type}),this.fire("disabled",{handler:this.type}));},addHooks:function(){var t=this._map;t&&(t.getContainer().focus(),this._featureGroup.eachLayer(this._enableLayerEdit,this),this._tooltip=new L.Draw.Tooltip(this._map),this._tooltip.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext}),t._editTooltip=this._tooltip,this._updateTooltip(),this._map.on("mousemove",this._onMouseMove,this).on("touchmove",this._onMouseMove,this).on("MSPointerMove",this._onMouseMove,this).on(L.Draw.Event.EDITVERTEX,this._updateTooltip,this));},removeHooks:function(){this._map&&(this._featureGroup.eachLayer(this._disableLayerEdit,this),this._uneditedLayerProps={},this._tooltip.dispose(),this._tooltip=null,this._map.off("mousemove",this._onMouseMove,this).off("touchmove",this._onMouseMove,this).off("MSPointerMove",this._onMouseMove,this).off(L.Draw.Event.EDITVERTEX,this._updateTooltip,this));},revertLayers:function(){this._featureGroup.eachLayer(function(t){this._revertLayer(t);},this);},save:function(){var t=new L.LayerGroup;this._featureGroup.eachLayer(function(e){e.edited&&(t.addLayer(e),e.edited=!1);}),this._map.fire(L.Draw.Event.EDITED,{layers:t});},_backupLayer:function(t){var e=L.Util.stamp(t);this._uneditedLayerProps[e]||(t instanceof L.Polyline||t instanceof L.Polygon||t instanceof L.Rectangle?this._uneditedLayerProps[e]={latlngs:L.LatLngUtil.cloneLatLngs(t.getLatLngs())}:t instanceof L.Circle?this._uneditedLayerProps[e]={latlng:L.LatLngUtil.cloneLatLng(t.getLatLng()),radius:t.getRadius()}:(t instanceof L.Marker||t instanceof L.CircleMarker)&&(this._uneditedLayerProps[e]={latlng:L.LatLngUtil.cloneLatLng(t.getLatLng())}));},_getTooltipText:function(){return {text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext}},_updateTooltip:function(){this._tooltip.updateContent(this._getTooltipText());},_revertLayer:function(t){var e=L.Util.stamp(t);t.edited=!1,this._uneditedLayerProps.hasOwnProperty(e)&&(t instanceof L.Polyline||t instanceof L.Polygon||t instanceof L.Rectangle?t.setLatLngs(this._uneditedLayerProps[e].latlngs):t instanceof L.Circle?(t.setLatLng(this._uneditedLayerProps[e].latlng),t.setRadius(this._uneditedLayerProps[e].radius)):(t instanceof L.Marker||t instanceof L.CircleMarker)&&t.setLatLng(this._uneditedLayerProps[e].latlng),t.fire("revert-edited",{layer:t}));},_enableLayerEdit:function(t){var e,i,o=t.layer||t.target||t;this._backupLayer(o),this.options.poly&&(i=L.Util.extend({},this.options.poly),o.options.poly=i),this.options.selectedPathOptions&&(e=L.Util.extend({},this.options.selectedPathOptions),e.maintainColor&&(e.color=o.options.color,e.fillColor=o.options.fillColor),o.options.original=L.extend({},o.options),o.options.editing=e),o instanceof L.Marker?(o.editing&&o.editing.enable(),o.dragging.enable(),o.on("dragend",this._onMarkerDragEnd).on("touchmove",this._onTouchMove,this).on("MSPointerMove",this._onTouchMove,this).on("touchend",this._onMarkerDragEnd,this).on("MSPointerUp",this._onMarkerDragEnd,this)):o.editing.enable();},_disableLayerEdit:function(t){var e=t.layer||t.target||t;e.edited=!1,e.editing&&e.editing.disable(),delete e.options.editing,delete e.options.original,this._selectedPathOptions&&(e instanceof L.Marker?this._toggleMarkerHighlight(e):(e.setStyle(e.options.previousOptions),
	delete e.options.previousOptions)),e instanceof L.Marker?(e.dragging.disable(),e.off("dragend",this._onMarkerDragEnd,this).off("touchmove",this._onTouchMove,this).off("MSPointerMove",this._onTouchMove,this).off("touchend",this._onMarkerDragEnd,this).off("MSPointerUp",this._onMarkerDragEnd,this)):e.editing.disable();},_onMouseMove:function(t){this._tooltip.updatePosition(t.latlng);},_onMarkerDragEnd:function(t){var e=t.target;e.edited=!0,this._map.fire(L.Draw.Event.EDITMOVE,{layer:e});},_onTouchMove:function(t){var e=t.originalEvent.changedTouches[0],i=this._map.mouseEventToLayerPoint(e),o=this._map.layerPointToLatLng(i);t.target.setLatLng(o);},_hasAvailableLayers:function(){return 0!==this._featureGroup.getLayers().length}}),L.EditToolbar.Delete=L.Handler.extend({statics:{TYPE:"remove"},initialize:function(t,e){if(L.Handler.prototype.initialize.call(this,t),L.Util.setOptions(this,e),this._deletableLayers=this.options.featureGroup,!(this._deletableLayers instanceof L.FeatureGroup))throw new Error("options.featureGroup must be a L.FeatureGroup");this.type=L.EditToolbar.Delete.TYPE;var i=L.version.split(".");1===parseInt(i[0],10)&&parseInt(i[1],10)>=2?L.EditToolbar.Delete.include(L.Evented.prototype):L.EditToolbar.Delete.include(L.Mixin.Events);},enable:function(){!this._enabled&&this._hasAvailableLayers()&&(this.fire("enabled",{handler:this.type}),this._map.fire(L.Draw.Event.DELETESTART,{handler:this.type}),L.Handler.prototype.enable.call(this),this._deletableLayers.on("layeradd",this._enableLayerDelete,this).on("layerremove",this._disableLayerDelete,this));},disable:function(){this._enabled&&(this._deletableLayers.off("layeradd",this._enableLayerDelete,this).off("layerremove",this._disableLayerDelete,this),L.Handler.prototype.disable.call(this),this._map.fire(L.Draw.Event.DELETESTOP,{handler:this.type}),this.fire("disabled",{handler:this.type}));},addHooks:function(){var t=this._map;t&&(t.getContainer().focus(),this._deletableLayers.eachLayer(this._enableLayerDelete,this),this._deletedLayers=new L.LayerGroup,this._tooltip=new L.Draw.Tooltip(this._map),this._tooltip.updateContent({text:L.drawLocal.edit.handlers.remove.tooltip.text}),this._map.on("mousemove",this._onMouseMove,this));},removeHooks:function(){this._map&&(this._deletableLayers.eachLayer(this._disableLayerDelete,this),this._deletedLayers=null,this._tooltip.dispose(),this._tooltip=null,this._map.off("mousemove",this._onMouseMove,this));},revertLayers:function(){this._deletedLayers.eachLayer(function(t){this._deletableLayers.addLayer(t),t.fire("revert-deleted",{layer:t});},this);},save:function(){this._map.fire(L.Draw.Event.DELETED,{layers:this._deletedLayers});},removeAllLayers:function(){this._deletableLayers.eachLayer(function(t){this._removeLayer({layer:t});},this),this.save();},_enableLayerDelete:function(t){(t.layer||t.target||t).on("click",this._removeLayer,this);},_disableLayerDelete:function(t){var e=t.layer||t.target||t;e.off("click",this._removeLayer,this),this._deletedLayers.removeLayer(e);},_removeLayer:function(t){var e=t.layer||t.target||t;this._deletableLayers.removeLayer(e),this._deletedLayers.addLayer(e),e.fire("deleted");},_onMouseMove:function(t){this._tooltip.updatePosition(t.latlng);},_hasAvailableLayers:function(){return 0!==this._deletableLayers.getLayers().length}});}(window,document);

	// Based on https://github.com/shramov/leaflet-plugins
	// GridLayer like https://avinmathew.com/leaflet-and-google-maps/ , but using MutationObserver instead of jQuery


	// 🍂class GridLayer.GoogleMutant
	// 🍂extends GridLayer
	L.GridLayer.GoogleMutant = L.GridLayer.extend({
		options: {
			minZoom: 0,
			maxZoom: 23,
			tileSize: 256,
			subdomains: 'abc',
			errorTileUrl: '',
			attribution: '',	// The mutant container will add its own attribution anyways.
			opacity: 1,
			continuousWorld: false,
			noWrap: false,
			// 🍂option type: String = 'roadmap'
			// Google's map type. Valid values are 'roadmap', 'satellite' or 'terrain'. 'hybrid' is not really supported.
			type: 'roadmap',
			maxNativeZoom: 21
		},

		initialize: function (options) {
			L.GridLayer.prototype.initialize.call(this, options);

			this._ready = !!window.google && !!window.google.maps && !!window.google.maps.Map;

			this._GAPIPromise = this._ready ? Promise.resolve(window.google) : new Promise(function (resolve, reject) {
				var checkCounter = 0;
				var intervalId = null;
				intervalId = setInterval(function () {
					if (checkCounter >= 10) {
						clearInterval(intervalId);
						return reject(new Error('window.google not found after 10 attempts'));
					}
					if (!!window.google && !!window.google.maps && !!window.google.maps.Map) {
						clearInterval(intervalId);
						return resolve(window.google);
					}
					checkCounter++;
				}, 500);
			});

			// Couple data structures indexed by tile key
			this._tileCallbacks = {};	// Callbacks for promises for tiles that are expected
			this._freshTiles = {};	// Tiles from the mutant which haven't been requested yet

			this._imagesPerTile = (this.options.type === 'hybrid') ? 2 : 1;

			this._boundOnMutatedImage = this._onMutatedImage.bind(this);
		},

		onAdd: function (map) {
			L.GridLayer.prototype.onAdd.call(this, map);
			this._initMutantContainer();

			this._GAPIPromise.then(function () {
				this._ready = true;
				this._map = map;

				this._initMutant();

				map.on('viewreset', this._reset, this);
				if (this.options.updateWhenIdle) {
					map.on('moveend', this._update, this);
				} else {
					map.on('move', this._update, this);
				}
				map.on('zoomend', this._handleZoomAnim, this);
				map.on('resize', this._resize, this);

				//handle layer being added to a map for which there are no Google tiles at the given zoom
				google.maps.event.addListenerOnce(this._mutant, 'idle', function () {
					this._checkZoomLevels();
					this._mutantIsReady = true;
				}.bind(this));

				//20px instead of 1em to avoid a slight overlap with google's attribution
				map._controlCorners.bottomright.style.marginBottom = '20px';
				map._controlCorners.bottomleft.style.marginBottom = '20px';

				this._reset();
				this._update();

				if (this._subLayers) {
					//restore previously added google layers
					for (var layerName in this._subLayers) {
						this._subLayers[layerName].setMap(this._mutant);
					}
				}
			}.bind(this));
		},

		onRemove: function (map) {
			L.GridLayer.prototype.onRemove.call(this, map);
			this._observer.disconnect();
			map._container.removeChild(this._mutantContainer);

			google.maps.event.clearListeners(map, 'idle');
			google.maps.event.clearListeners(this._mutant, 'idle');
			map.off('viewreset', this._reset, this);
			map.off('move', this._update, this);
			map.off('moveend', this._update, this);
			map.off('zoomend', this._handleZoomAnim, this);
			map.off('resize', this._resize, this);

			if (map._controlCorners) {
				map._controlCorners.bottomright.style.marginBottom = '0em';
				map._controlCorners.bottomleft.style.marginBottom = '0em';
			}
		},

		getAttribution: function () {
			return this.options.attribution;
		},

		setElementSize: function (e, size) {
			e.style.width = size.x + 'px';
			e.style.height = size.y + 'px';
		},


		addGoogleLayer: function (googleLayerName, options) {
			if (!this._subLayers) this._subLayers = {};
			return this._GAPIPromise.then(function () {
				var Constructor = google.maps[googleLayerName];
				var googleLayer = new Constructor(options);
				googleLayer.setMap(this._mutant);
				this._subLayers[googleLayerName] = googleLayer;
				return googleLayer;
			}.bind(this));
		},

		removeGoogleLayer: function (googleLayerName) {
			var googleLayer = this._subLayers && this._subLayers[googleLayerName];
			if (!googleLayer) return;

			googleLayer.setMap(null);
			delete this._subLayers[googleLayerName];
		},


		_initMutantContainer: function () {
			if (!this._mutantContainer) {
				this._mutantContainer = L.DomUtil.create('div', 'leaflet-google-mutant leaflet-top leaflet-left');
				this._mutantContainer.id = '_MutantContainer_' + L.Util.stamp(this._mutantContainer);
				this._mutantContainer.style.zIndex = '800'; //leaflet map pane at 400, controls at 1000
				this._mutantContainer.style.pointerEvents = 'none';
				
				L.DomEvent.off(this._mutantContainer);

			}
			this._map.getContainer().appendChild(this._mutantContainer);

			this.setOpacity(this.options.opacity);
			this.setElementSize(this._mutantContainer, this._map.getSize());

			this._attachObserver(this._mutantContainer);
		},

		_initMutant: function () {
			if (!this._ready || !this._mutantContainer) return;

			if (this._mutant) {
				// reuse old _mutant, just make sure it has the correct size
				this._resize();
				return;
			}

			this._mutantCenter = new google.maps.LatLng(0, 0);

			var map = new google.maps.Map(this._mutantContainer, {
				center: this._mutantCenter,
				zoom: 0,
				tilt: 0,
				mapTypeId: this.options.type,
				disableDefaultUI: true,
				keyboardShortcuts: false,
				draggable: false,
				disableDoubleClickZoom: true,
				scrollwheel: false,
				streetViewControl: false,
				styles: this.options.styles || {},
				backgroundColor: 'transparent'
			});

			this._mutant = map;

			google.maps.event.addListenerOnce(map, 'idle', function () {
				var nodes = this._mutantContainer.querySelectorAll('a');
				for (var i = 0; i < nodes.length; i++) {
					nodes[i].style.pointerEvents = 'auto';
				}
			}.bind(this));

			// 🍂event spawned
			// Fired when the mutant has been created.
			this.fire('spawned', {mapObject: map});
		},

		_attachObserver: function _attachObserver (node) {
	// 		console.log('Gonna observe', node);

			if (!this._observer)
				this._observer = new MutationObserver(this._onMutations.bind(this));

			// pass in the target node, as well as the observer options
			this._observer.observe(node, { childList: true, subtree: true });

			// if we are reusing an old _mutantContainer, we must manually detect
			// all existing tiles in it
			Array.prototype.forEach.call(
				node.querySelectorAll('img'),
				this._boundOnMutatedImage
			);
		},

		_onMutations: function _onMutations (mutations) {
			for (var i = 0; i < mutations.length; ++i) {
				var mutation = mutations[i];
				for (var j = 0; j < mutation.addedNodes.length; ++j) {
					var node = mutation.addedNodes[j];

					if (node instanceof HTMLImageElement) {
						this._onMutatedImage(node);
					} else if (node instanceof HTMLElement) {
						Array.prototype.forEach.call(
							node.querySelectorAll('img'),
							this._boundOnMutatedImage
						);

						// Check for, and remove, the "Google Maps can't load correctly" div.
						// You *are* loading correctly, you dumbwit.
						if (node.style.backgroundColor === 'white') {
							L.DomUtil.remove(node);
						}
	                    
						// Check for, and remove, the "For development purposes only" divs on the aerial/hybrid tiles.
						if (node.textContent.indexOf('For development purposes only') === 0) {
							L.DomUtil.remove(node);
						}
	                    
						// Check for, and remove, the "Sorry, we have no imagery here"
						// empty <div>s. The [style*="text-align: center"] selector
						// avoids matching the attribution notice.
						// This empty div doesn't have a reference to the tile
						// coordinates, so it's not possible to mark the tile as
						// failed.
						Array.prototype.forEach.call(
							node.querySelectorAll('div[draggable=false][style*="text-align: center"]'),
							L.DomUtil.remove
						);
					}
				}
			}
		},

		// Only images which 'src' attrib match this will be considered for moving around.
		// Looks like some kind of string-based protobuf, maybe??
		// Only the roads (and terrain, and vector-based stuff) match this pattern
		_roadRegexp: /!1i(\d+)!2i(\d+)!3i(\d+)!/,

		// On the other hand, raster imagery matches this other pattern
		_satRegexp: /x=(\d+)&y=(\d+)&z=(\d+)/,

		// On small viewports, when zooming in/out, a static image is requested
		// This will not be moved around, just removed from the DOM.
		_staticRegExp: /StaticMapService\.GetMapImage/,

		_onMutatedImage: function _onMutatedImage (imgNode) {
	// 		if (imgNode.src) {
	// 			console.log('caught mutated image: ', imgNode.src);
	// 		}

			var coords;
			var match = imgNode.src.match(this._roadRegexp);
			var sublayer = 0;

			if (match) {
				coords = {
					z: match[1],
					x: match[2],
					y: match[3]
				};
				if (this._imagesPerTile > 1) { 
					imgNode.style.zIndex = 1;
					sublayer = 1;
				}
			} else {
				match = imgNode.src.match(this._satRegexp);
				if (match) {
					coords = {
						x: match[1],
						y: match[2],
						z: match[3]
					};
				}
	// 			imgNode.style.zIndex = 0;
				sublayer = 0;
			}

			if (coords) {
				var tileKey = this._tileCoordsToKey(coords);
				imgNode.style.position = 'absolute';
				imgNode.style.visibility = 'hidden';

				var key = tileKey + '/' + sublayer;
				// console.log('mutation for tile', key)
				//store img so it can also be used in subsequent tile requests
				this._freshTiles[key] = imgNode;

				if (key in this._tileCallbacks && this._tileCallbacks[key]) {
	// console.log('Fullfilling callback ', key);
					//fullfill most recent tileCallback because there maybe callbacks that will never get a 
					//corresponding mutation (because map moved to quickly...)
					this._tileCallbacks[key].pop()(imgNode); 
					if (!this._tileCallbacks[key].length) { delete this._tileCallbacks[key]; }
				} else {
					if (this._tiles[tileKey]) {
						//we already have a tile in this position (mutation is probably a google layer being added)
						//replace it
						var c = this._tiles[tileKey].el;
						var oldImg = (sublayer === 0) ? c.firstChild : c.firstChild.nextSibling;
						var cloneImgNode = this._clone(imgNode);
						c.replaceChild(cloneImgNode, oldImg);
					}
				}
			} else if (imgNode.src.match(this._staticRegExp)) {
				imgNode.style.visibility = 'hidden';
			}
		},


		createTile: function (coords, done) {
			var key = this._tileCoordsToKey(coords);

			var tileContainer = L.DomUtil.create('div');
			tileContainer.dataset.pending = this._imagesPerTile;
			done = done.bind(this, null, tileContainer);

			for (var i = 0; i < this._imagesPerTile; i++) {
				var key2 = key + '/' + i;
				if (key2 in this._freshTiles) {
					var imgNode = this._freshTiles[key2];
					tileContainer.appendChild(this._clone(imgNode));
					tileContainer.dataset.pending--;
	// 				console.log('Got ', key2, ' from _freshTiles');
				} else {
					this._tileCallbacks[key2] = this._tileCallbacks[key2] || [];
					this._tileCallbacks[key2].push( (function (c/*, k2*/) {
						return function (imgNode) {
							c.appendChild(this._clone(imgNode));
							c.dataset.pending--;
							if (!parseInt(c.dataset.pending)) { done(); }
	// 						console.log('Sent ', k2, ' to _tileCallbacks, still ', c.dataset.pending, ' images to go');
						}.bind(this);
					}.bind(this))(tileContainer/*, key2*/) );
				}
			}

			if (!parseInt(tileContainer.dataset.pending)) {
				L.Util.requestAnimFrame(done);
			}
			return tileContainer;
		},

		_clone: function (imgNode) {
			var clonedImgNode = imgNode.cloneNode(true);
			clonedImgNode.style.visibility = 'visible';
			return clonedImgNode;
		},

		_checkZoomLevels: function () {
			//setting the zoom level on the Google map may result in a different zoom level than the one requested
			//(it won't go beyond the level for which they have data).
			var zoomLevel = this._map.getZoom();
			var gMapZoomLevel = this._mutant.getZoom();
			if (!zoomLevel || !gMapZoomLevel) return;


			if ((gMapZoomLevel !== zoomLevel) || //zoom levels are out of sync, Google doesn't have data
				(gMapZoomLevel > this.options.maxNativeZoom)) { //at current location, Google does have data (contrary to maxNativeZoom)
				//Update maxNativeZoom
				this._setMaxNativeZoom(gMapZoomLevel);
			}
		},

		_setMaxNativeZoom: function (zoomLevel) {
			if (zoomLevel != this.options.maxNativeZoom) {
				this.options.maxNativeZoom = zoomLevel;
				this._resetView();
			}
		},

		_reset: function () {
			this._initContainer();
		},

		_update: function () {
			// zoom level check needs to happen before super's implementation (tile addition/creation)
			// otherwise tiles may be missed if maxNativeZoom is not yet correctly determined
			if (this._mutant) {
				var center = this._map.getCenter();
				var _center = new google.maps.LatLng(center.lat, center.lng);

				this._mutant.setCenter(_center);
				var zoom = this._map.getZoom();
				var fractionalLevel = zoom !== Math.round(zoom);
				var mutantZoom = this._mutant.getZoom();

				//ignore fractional zoom levels
				if (!fractionalLevel && (zoom != mutantZoom)) {
					this._mutant.setZoom(zoom);
								
					if (this._mutantIsReady) this._checkZoomLevels();
					//else zoom level check will be done later by 'idle' handler
				}
			}

			L.GridLayer.prototype._update.call(this);
		},

		_resize: function () {
			var size = this._map.getSize();
			if (this._mutantContainer.style.width === size.x &&
				this._mutantContainer.style.height === size.y)
				return;
			this.setElementSize(this._mutantContainer, size);
			if (!this._mutant) return;
			google.maps.event.trigger(this._mutant, 'resize');
		},

		_handleZoomAnim: function () {
			if (!this._mutant) return;
			var center = this._map.getCenter();
			var _center = new google.maps.LatLng(center.lat, center.lng);

			this._mutant.setCenter(_center);
			this._mutant.setZoom(Math.round(this._map.getZoom()));
		},

		// Agressively prune _freshtiles when a tile with the same key is removed,
		// this prevents a problem where Leaflet keeps a loaded tile longer than
		// GMaps, so that GMaps makes two requests but Leaflet only consumes one,
		// polluting _freshTiles with stale data.
		_removeTile: function (key) {
			if (!this._mutant) return;

			//give time for animations to finish before checking it tile should be pruned
			setTimeout(this._pruneTile.bind(this, key), 1000);


			return L.GridLayer.prototype._removeTile.call(this, key);
		},

		_pruneTile: function (key) {
			var gZoom = this._mutant.getZoom();
			var tileZoom = key.split(':')[2];
			var googleBounds = this._mutant.getBounds();
			var sw = googleBounds.getSouthWest();
			var ne = googleBounds.getNorthEast();
			var gMapBounds = L.latLngBounds([[sw.lat(), sw.lng()], [ne.lat(), ne.lng()]]);

			for (var i=0; i<this._imagesPerTile; i++) {
				var key2 = key + '/' + i;
				if (key2 in this._freshTiles) { 
					var tileBounds = this._map && this._keyToBounds(key);
					var stillVisible = this._map && tileBounds.overlaps(gMapBounds) && (tileZoom == gZoom);

					if (!stillVisible) delete this._freshTiles[key2]; 
	//				console.log('Prunning of ', key, (!stillVisible))
				}
			}
		}
	});


	// 🍂factory gridLayer.googleMutant(options)
	// Returns a new `GridLayer.GoogleMutant` given its options
	L.gridLayer.googleMutant = function (options) {
		return new L.GridLayer.GoogleMutant(options);
	};

	let googleMapsScriptRequest;

	const defaultZoom = 15;
	// MapBox TileJSON format
	const maps = ( config && config.maps && config.maps.length > 0 ) ? config.maps : [ {
	    'name': 'streets',
	    'maxzoom': 24,
	    'tiles': [ 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png' ],
	    'attribution': '© <a href="http://openstreetmap.org">OpenStreetMap</a> | <a href="www.openstreetmap.org/copyright">Terms</a>'
	} ];
	let searchSource = 'https://maps.googleapis.com/maps/api/geocode/json?address={address}&sensor=true&key={api_key}';
	const iconSingle = leafletSrc.divIcon( {
	    iconSize: 24,
	    className: 'enketo-geopoint-marker'
	} );
	const iconMulti = leafletSrc.divIcon( {
	    iconSize: 16,
	    className: 'enketo-geopoint-circle-marker'
	} );
	const iconMultiActive = leafletSrc.divIcon( {
	    iconSize: 16,
	    className: 'enketo-geopoint-circle-marker-active'
	} );

	class Geopicker extends Widget {

	    static get selector() {
	        return '.question input[data-type-xml="geopoint"], .question input[data-type-xml="geotrace"], .question input[data-type-xml="geoshape"]';
	    }

	    static condition( element ) {
	        // Allow geopicker and ArcGIS geopicker to be used in same form
	        return !elementDataStore.has( element, 'ArcGisGeopicker' );
	    }

	    _init() {
	        const loadedVal = this.originalInputValue;
	        const that = this;

	        this.$form = jquery( this.element ).closest( 'form.or' );
	        this.$question = jquery( this.element ).closest( '.question' );

	        this.mapId = Math.round( Math.random() * 10000000 );

	        this._addDomElements();
	        this.currentIndex = 0;
	        this.points = [];

	        // load default value
	        if ( loadedVal ) {
	            this.value = loadedVal;
	        }

	        // handle point input changes
	        this.$widget.find( '[name="lat"], [name="long"], [name="alt"], [name="acc"]' ).on( 'change change.bymap change.bysearch', event => {
	            const lat = that.$lat.val() ? Number( that.$lat.val() ) : '';
	            const lng = that.$lng.val() ? Number( that.$lng.val() ) : '';
	            // we need to avoid a missing alt in case acc is not empty!
	            const alt = that.$alt.val() ? Number( that.$alt.val() ) : '';
	            const acc = that.$acc.val() ? Number( that.$acc.val() ) : '';
	            const latLng = {
	                lat,
	                lng
	            };

	            event.stopImmediatePropagation();

	            // if the points array contains empty points, skip the intersection check, it will be done before closing the polygon
	            if ( event.namespace !== 'bymap' && event.namespace !== 'bysearch' && that.polyline && that.props.type === 'geoshape' && !that.containsEmptyPoints( that.points, that.currentIndex ) && that.updatedPolylineWouldIntersect( latLng, that.currentIndex ) ) {
	                that._showIntersectError();
	                that._updateInputs( that.points[ that.currentIndex ], 'nochange' );
	            } else {
	                that._editPoint( [ lat, lng, alt, acc ] );

	                if ( event.namespace !== 'bysearch' && that.$search ) {
	                    that.$search.val( '' );
	                }
	            }
	        } );

	        // handle KML input changes
	        this.$kmlInput.on( 'change', function( event ) {
	            const $addPointBtn = that.$points.find( '.addpoint' );
	            const $progress = jquery( this ).prev( '.paste-progress' ).removeClass( 'hide' );
	            const value = event.target.value;
	            const coords = that._convertKmlCoordinatesToLeafletCoordinates( value );

	            // reset textarea 
	            event.target.value = '';

	            setTimeout( () => {
	                // mimic manual input point-by-point
	                coords.forEach( ( latLng, index ) => {
	                    that._updateInputs( latLng );
	                    if ( index < coords.length - 1 ) {
	                        $addPointBtn.click();
	                    }
	                } );
	                // remove progress bar;
	                $progress.remove();
	                // switch to points input mode
	                that._switchInputType( 'points' );
	            }, 10 );
	        } );

	        // handle input switcher
	        this.$widget.find( '.toggle-input-type-btn' ).on( 'click', () => {
	            const type = that.$inputGroup.hasClass( 'kml-input-mode' ) ? 'points' : 'kml';
	            that._switchInputType( type );
	            return false;
	        } );

	        // handle original input changes
	        jquery( this.element )
	            .on( 'change', function() {
	                that.$kmlInput.prop( 'disabled', !!this.value );
	            } )
	            .on( 'applyfocus', () => {
	                that.$widget[ 0 ].querySelector( 'input' ).focus();
	            } );

	        // handle point switcher
	        this.$points.on( 'click', '.point', function() {
	            that._setCurrent( that.$points.find( '.point' ).index( jquery( this ) ) );
	            that._switchInputType( 'points' );
	            return false;
	        } );

	        // handle addpoint button click
	        this.$points.find( '.addpoint' ).on( 'click', () => {
	            that._addPoint();
	            return false;
	        } );

	        // handle polygon close button click
	        this.$widget.find( '.close-chain-btn' ).on( 'click', () => {
	            that._closePolygon();
	            return false;
	        } );

	        // handle point remove click
	        this.$widget.find( '.btn-remove' ).on( 'click', () => {
	            if ( that.points.length < 2 ) {
	                that._updateInputs( [] );
	            } else {
	                dialog.confirm( t( 'geopicker.removePoint' ) )
	                    .then( confirmed => {
	                        if ( confirmed ) {
	                            that._removePoint();
	                        }
	                    } )
	                    .catch( () => {} );
	            }
	        } );

	        // handle fullscreen map button click
	        this.$map.find( '.show-map-btn' ).on( 'click', () => {
	            that.$widget.find( '.search-bar' ).removeClass( 'hide-search' );
	            that.$widget.addClass( 'full-screen' );
	            that._updateMap();
	            return false;
	        } );

	        // ensure all tiles are displayed when revealing page, https://github.com/kobotoolbox/enketo-express/issues/188
	        // remove handler once it has been used
	        this.$form.on( `pageflip.map${this.mapId}`, event => {
	            if ( that.map && jquery.contains( event.target, that.element ) ) {
	                that.map.invalidateSize();
	                that.$form.off( `pageflip.map${that.mapId}` );
	            }
	        } );

	        // add wide class if question is wide
	        if ( this.props.wide ) {

	            this.$widget.addClass( 'wide' );
	        }

	        // copy hide-input class from question to widget and add show/hide input controller
	        this.$widget
	            .toggleClass( 'hide-input', this.$question.hasClass( 'or-appearance-hide-input' ) )
	            .find( '.toggle-input-visibility-btn' ).on( 'click', function() {
	                that.$widget.toggleClass( 'hide-input' );
	                jquery( this ).toggleClass( 'open', that.$widget.hasClass( 'hide-input' ) );
	                if ( that.map ) {
	                    that.map.invalidateSize( false );
	                }
	            } ).toggleClass( 'open', that.$widget.hasClass( 'hide-input' ) );

	        // hide map controller
	        this.$widget.find( '.hide-map-btn' ).on( 'click', () => {
	            that.$widget.find( '.search-bar' ).addClass( 'hide-search' );
	            that.$widget.removeClass( 'full-screen' ).find( '.map-canvas' ).removeClass( 'leaflet-container' )
	                .find( '.leaflet-google-layer' ).remove();
	            if ( that.map ) {
	                that.map.remove();
	                that.map = null;
	                that.polygon = null;
	                that.polyline = null;
	            }
	            return false;
	        } );

	        // enable search
	        if ( this.props.search ) {
	            this._enableSearch();
	        }

	        // enable detection
	        if ( this.props.detect ) {
	            this._enableDetection();
	        }

	        if ( this.props.readonly ) {
	            this.disable();
	        }

	        // create "point buttons"
	        if ( loadedVal ) {
	            this.points.forEach( () => {
	                that._addPointBtn();
	            } );
	        } else {
	            this._addPoint();
	        }

	        // set map location on load
	        if ( !loadedVal ) {
	            // set worldview in case permissions take too long (e.g. in FF);
	            this._updateMap( [ 0, 0 ], 1 );
	            if ( this.props.detect ) {
	                navigator.geolocation.getCurrentPosition( position => {
	                    that._updateMap( [ position.coords.latitude, position.coords.longitude ], defaultZoom );
	                } );
	            }
	        } else {
	            // center map around first loaded geopoint value
	            //this._updateMap( L.latLng( this.points[ 0 ][ 0 ], this.points[ 0 ][ 1 ] ) );
	            this._updateMap();
	            this._setCurrent( this.currentIndex );
	        }
	    }

	    _switchInputType( type ) {
	        if ( type === 'kml' ) {
	            this.$inputGroup.addClass( 'kml-input-mode' );
	        } else if ( type === 'points' ) {
	            this.$inputGroup.removeClass( 'kml-input-mode' );
	        }
	    }

	    /**
	     * Adds a point button in the point navigation bar
	     */
	    _addPointBtn() {
	        this.$points.find( '.addpoint' ).before( '<a href="#" class="point" aria-label="point"> </a>' );
	    }

	    /**
	     * Adds the DOM elements
	     */
	    _addDomElements() {
	        const map = `<div class="map-canvas-wrapper"><div class=map-canvas id="map${this.mapId}"></div></div>`;
	        const points = '<div class="points"><button type="button" class="addpoint">+</button></div>';
	        const kmlPstTxt = t( 'geopicker.kmlpaste' );
	        const kmlCrdsTxt = t( 'geopicker.kmlcoords' );
	        const pntsTxt = t( 'geopicker.points' );
	        const kml = `<a href="#" class="toggle-input-type-btn"><span class="kml-input">KML</span><span class="points-input">${pntsTxt}</span></a><label class="geo kml">${kmlCrdsTxt}<progress class="paste-progress hide"></progress><textarea class="ignore" name="kml" placeholder="${kmlPstTxt}"></textarea><span class="disabled-msg">remove all points to enable</span></label>`;
	        const closePlgnTxt = t( 'geopicker.closepolygon' );
	        const close = `<button type="button" class="close-chain-btn btn btn-default btn-xs">${closePlgnTxt}</button>`;
	        const mapBtn = '<button type="button" class="show-map-btn btn btn-default">Map</button>';
	        const latTxt = t( 'geopicker.latitude' );
	        const lngTxt = t( 'geopicker.longitude' );
	        const altTxt = t( 'geopicker.altitude' );
	        const accTxt = t( 'geopicker.accuracy' );
	        const srchTxt = t( 'geopicker.searchPlaceholder' );

	        this.$widget = jquery(
	            `<div class="geopicker widget"><div class="search-bar hide-search no-map no-detect"><button type="button" class="hide-map-btn btn btn-default"><span class="icon icon-arrow-left"> </span></button><button name="geodetect" type="button" class="btn btn-default" title="detect current location" data-placement="top"><span class="icon icon-crosshairs"> </span></button><div class="input-group"><input class="geo ignore" name="search" type="text" placeholder="${srchTxt}" disabled="disabled"/><button type="button" class="btn btn-default search-btn"><i class="icon icon-search"> </i></button></div></div><div class="geo-inputs"><label class="geo lat">${latTxt}<input class="ignore" name="lat" type="number" step="0.000001" min="-90" max="90"/></label><label class="geo long">${lngTxt}<input class="ignore" name="long" type="number" step="0.000001" min="-180" max="180"/></label><label class="geo alt">${altTxt}<input class="ignore" name="alt" type="number" step="0.1" /></label><label class="geo acc">${accTxt}<input class="ignore" name="acc" type="number" step="0.1" /></label><button type="button" class="btn-icon-only btn-remove" aria-label="remove"><span class="icon icon-trash"> </span></button></div></div>`
	        );

	        // add the detection button
	        if ( this.props.detect ) {
	            this.$widget.find( '.search-bar' ).removeClass( 'no-detect' );
	            this.$detect = this.$widget.find( 'button[name="geodetect"]' );
	        }

	        this.$search = this.$widget.find( '[name="search"]' );
	        this.$inputGroup = this.$widget.find( '.geo-inputs' );

	        // add the map canvas
	        if ( this.props.map ) {
	            this.$widget.find( '.search-bar' ).removeClass( 'no-map' ).after( map );
	            this.$map = this.$widget.find( '.map-canvas' );
	            // add the hide/show inputs button
	            this.$map.parent().append( '<button type="button" class="toggle-input-visibility-btn" aria-label="toggle input"> </button>' );
	        } else {
	            this.$map = jquery();
	        }

	        // touchscreen maps
	        if ( this.props.touch && this.props.map ) {
	            this.$map.append( mapBtn );
	        }

	        // unhide search bar 
	        // TODO: can be done in CSS?
	        if ( !this.props.touch ) {
	            this.$widget.find( '.search-bar' ).removeClass( 'hide-search' );
	        }

	        // if geoshape or geotrace
	        if ( this.props.type !== 'geopoint' ) {
	            // add points bar
	            this.$points = jquery( points );
	            this.$widget.prepend( this.$points );
	            // add polygon 'close' button
	            if ( this.props.type === 'geoshape' ) {
	                this.$inputGroup.append( close );
	            }
	            // add KML paste textarea;
	            const $kml = jquery( kml );
	            this.$kmlInput = $kml.find( '[name="kml"]' );
	            this.$inputGroup.prepend( $kml );
	        } else {
	            this.$points = jquery();
	            this.$kmlInput = jquery();
	        }

	        this.$lat = this.$widget.find( '[name="lat"]' );
	        this.$lng = this.$widget.find( '[name="long"]' );
	        this.$alt = this.$widget.find( '[name="alt"]' );
	        this.$acc = this.$widget.find( '[name="acc"]' );


	        jquery( this.element ).hide().after( this.$widget ).parent().addClass( 'clearfix' );
	    }

	    /**
	     * Updates the value in the original input element.
	     *
	     * @return {Boolean} Whether the value was changed.
	     */
	    _updateValue() {
	        this._markAsValid();
	        const oldValue = this.originalInputValue;
	        const newValue = this.value;

	        // console.log( 'updating value by joining', this.points, 'old value', oldValue, 'new value', newValue );

	        if ( oldValue !== newValue ) {
	            this.originalInputValue = newValue;
	            return true;
	        } else {
	            return false;
	        }
	    }

	    /**
	     * Checks an Openrosa geopoint for validity. This function is used to provide more detailed
	     * error feedback than provided by the form controller. This can be used to pinpoint the exact
	     * invalid geopoints in a list of geopoints (the form controller only validates the total list).
	     *
	     * @param  {string}  geopoint [description]
	     * @return {Boolean}          [description]
	     */
	    _isValidGeopoint( geopoint ) {
	        return geopoint ? types.geopoint.validate( geopoint ) : false;
	    }

	    /**
	     * Validates a list of latLng Arrays or Objects
	     * @param  {Array.((Array.<number|string>|{lat: number, long:number}))}  latLngs Array of latLng objects or arrays
	     * @return {Boolean}         Whether list is valid or not
	     */
	    _isValidLatLngList( latLngs ) {
	        const that = this;

	        return latLngs.every( ( latLng, index, array ) => that._isValidLatLng( latLng ) || ( latLng.join() === '' && index === array.length - 1 ) );
	    }

	    _cleanLatLng( latLng ) {
	        if ( Array.isArray( latLng ) ) {
	            return [ latLng[ 0 ], latLng[ 1 ] ];
	        }
	        return latLng;
	    }

	    /**
	     * Validates an individual latlng Array or Object
	     * @param  {(Array.<number|string>|{lat: number, long:number})}  latLng latLng object or array
	     * @return {Boolean}        Whether latLng is valid or not
	     */
	    _isValidLatLng( latLng ) {
	        const lat = ( typeof latLng[ 0 ] === 'number' ) ? latLng[ 0 ] : ( typeof latLng.lat === 'number' ) ? latLng.lat : null;
	        const lng = ( typeof latLng[ 1 ] === 'number' ) ? latLng[ 1 ] : ( typeof latLng.lng === 'number' ) ? latLng.lng : null;

	        // This conversion seems backwards, but it is helpful to have only one place where geopoints are validated.
	        return types.geopoint.validate( [ lat, lng ].join( ' ' ) );
	    }

	    /**
	     * Marks a point as invalid in the points navigation bar
	     * @param  {number} index Index of point
	     */
	    _markAsInvalid( index ) {
	        this.$points.find( '.point' ).eq( index ).addClass( 'has-error' );
	    }

	    /**
	     * Marks all points as valid in the points navigation bar
	     */
	    _markAsValid() {
	        this.$points.find( '.point' ).removeClass( 'has-error' );
	    }

	    /**
	     * Changes the current point in the list of points
	     */
	    _setCurrent( index ) {
	        this.currentIndex = index;
	        this.$points.find( '.point' ).removeClass( 'active' ).eq( index ).addClass( 'active' );
	        this._updateInputs( this.points[ index ], '' );
	        // make sure that the current marker is marked as active
	        if ( this.map && ( !this.props.touch || this._inFullScreenMode() ) ) {
	            this._updateMarkers();
	        }
	        // console.debug( 'set current index to ', this.currentIndex );
	    }

	    /**
	     * Enables geo detection using the built-in browser geoLocation functionality
	     */
	    _enableDetection() {
	        const that = this;
	        const options = {
	            enableHighAccuracy: true,
	            maximumAge: 0
	        };
	        this.$detect.click( event => {
	            event.preventDefault();
	            navigator.geolocation.getCurrentPosition( position => {
	                const latLng = {
	                    lat: Math.round( position.coords.latitude * 1000000 ) / 1000000,
	                    lng: Math.round( position.coords.longitude * 1000000 ) / 1000000
	                };

	                if ( that.polyline && that.props.type === 'geoshape' && that.updatedPolylineWouldIntersect( latLng, that.currentIndex ) ) {
	                    that._showIntersectError();
	                } else {
	                    //that.points[that.currentIndex] = [ position.coords.latitude, position.coords.longitude ];
	                    //that._updateMap( );
	                    that._updateInputs( [ latLng.lat, latLng.lng, position.coords.altitude, position.coords.accuracy ] );
	                    // if current index is last of points, automatically create next point
	                    if ( that.currentIndex === that.points.length - 1 && that.props.type !== 'geopoint' ) {
	                        that._addPoint();
	                    }
	                }
	            }, () => {
	                console.error( 'error occurred trying to obtain position' );
	            }, options );
	            return false;
	        } );
	    }

	    /**
	     * Enables search functionality using the Google Maps API v3
	     * This only changes the map view. It does not record geopoints.
	     */
	    _enableSearch() {
	        const that = this;

	        {
	            searchSource = searchSource.replace( '&key={api_key}', '' );
	        }

	        this.$search
	            .prop( 'disabled', false )
	            .on( 'change', function( event ) {
	                let address = jquery( this ).val();
	                event.stopImmediatePropagation();

	                if ( address ) {
	                    address = address.split( /\s+/ ).join( '+' );
	                    jquery
	                        .get( searchSource.replace( '{address}', address ), response => {
	                            let latLng;
	                            if ( response.results && response.results.length > 0 && response.results[ 0 ].geometry && response.results[ 0 ].geometry.location ) {
	                                latLng = response.results[ 0 ].geometry.location;
	                                that._updateMap( [ latLng.lat, latLng.lng ], defaultZoom );
	                                that.$search.closest( '.input-group' ).removeClass( 'has-error' );
	                            } else {
	                                //TODO: add error message
	                                that.$search.closest( '.input-group' ).addClass( 'has-error' );
	                                console.log( `Location "${address}" not found` );
	                            }
	                        }, 'json' )
	                        .fail( () => {
	                            //TODO: add error message
	                            that.$search.closest( '.input-group' ).addClass( 'has-error' );
	                            console.log( 'Error. Geocoding service may not be available or app is offline' );
	                        } )
	                        .always( () => {

	                        } );
	                }
	            } );
	    }

	    /**
	     * Determines whether map is available for manipulation.
	     */
	    _dynamicMapAvailable() {
	        return !!this.map;
	    }

	    _inFullScreenMode() {
	        return this.$widget.hasClass( 'full-screen' );
	    }

	    /**
	     * Updates the map to either show the provided coordinates (in the center), with the provided zoom level
	     * or update any markers, polylines, or polygons.
	     *
	     * @param  @param  {Array.<number>|{lat: number, lng: number}} latLng  latitude and longitude coordinates
	     * @param  {number=} zoom zoom level
	     * @return {Function} Returns call to function
	     */
	    _updateMap( latLng, zoom ) {
	        const that = this;

	        // check if the widget is supposed to have a map
	        if ( !this.props.map ) {
	            return;
	        }

	        // determine zoom level
	        if ( !zoom ) {
	            if ( this.map ) {
	                // note: there are conditions where getZoom returns undefined!
	                zoom = this.map.getZoom() || defaultZoom;
	            } else {
	                zoom = defaultZoom;
	            }
	        }

	        // update last requested map coordinates to be used to initialize map in mobile fullscreen view
	        if ( latLng ) {
	            this.lastLatLng = latLng;
	            this.lastZoom = zoom;
	        }

	        // update the map if it is visible
	        if ( !this.props.touch || this._inFullScreenMode() ) {
	            if ( !this.map ) {
	                this._addDynamicMap()
	                    .then( () => {
	                        that._updateDynamicMapView( latLng, zoom );
	                    } );
	            } else {
	                that._updateDynamicMapView( latLng, zoom );
	            }
	        }
	    }

	    _addDynamicMap() {
	        const that = this;

	        return this._getLayers()
	            .then( layers => {
	                const options = {
	                    layers: that._getDefaultLayer( layers )
	                };

	                that.map = leafletSrc.map( `map${that.mapId}`, options )
	                    .on( 'click', e => {
	                        let latLng;
	                        let indexToPlacePoint;

	                        if ( that.props.readonly ) {
	                            return false;
	                        }

	                        latLng = e.latlng;
	                        indexToPlacePoint = ( that.$lat.val() && that.$lng.val() ) ? that.points.length : that.currentIndex;

	                        // reduce precision to 6 decimals
	                        latLng.lat = Math.round( latLng.lat * 1000000 ) / 1000000;
	                        latLng.lng = Math.round( latLng.lng * 1000000 ) / 1000000;

	                        // Skip intersection check if points contain empties. It will be done later, before the polygon is closed.
	                        if ( that.props.type === 'geoshape' && !that.containsEmptyPoints( that.points, indexToPlacePoint ) && that.updatedPolylineWouldIntersect( latLng, indexToPlacePoint ) ) {
	                            that._showIntersectError();
	                        } else {
	                            if ( !that.$lat.val() || !that.$lng.val() || that.props.type === 'geopoint' ) {
	                                that._updateInputs( latLng, 'change.bymap' );
	                            } else if ( that.$lat.val() && that.$lng.val() ) {
	                                that._addPoint();
	                                that._updateInputs( latLng, 'change.bymap' );
	                            }
	                        }
	                    } );

	                // watch out, default "Leaflet" link clicks away from page, loosing all data
	                that.map.attributionControl.setPrefix( '' );

	                // add layer control
	                if ( layers.length > 1 ) {
	                    leafletSrc.control.layers( that._getBaseLayers( layers ), null ).addTo( that.map );
	                }

	                // change default leaflet layer control button
	                that.$widget.find( '.leaflet-control-layers-toggle' ).append( '<span class="icon icon-globe"></span>' );

	                // Add ignore and option-label class to Leaflet-added input elements and their labels
	                // something weird seems to happen. It seems the layercontrol is added twice (second replacing first) 
	                // which means the classes are not present in the final control. 
	                // Using the baselayerchange event handler is a trick that seems to work.
	                that.map.on( 'baselayerchange', () => {
	                    that.$widget.find( '.leaflet-control-container input' ).addClass( 'ignore no-unselect' ).next( 'span' ).addClass( 'option-label' );
	                } );
	            } );
	    }

	    _updateDynamicMapView( latLng, zoom ) {

	        if ( !latLng ) {
	            this._updatePolyline();
	            this._updateMarkers();
	            if ( this.points.length === 1 && this.points[ 0 ].toString() === '' ) {
	                if ( this.lastLatLng ) {
	                    this.map.setView( this.lastLatLng, this.lastZoom || defaultZoom );
	                } else {
	                    this.map.setView( leafletSrc.latLng( 0, 0 ), zoom || defaultZoom );
	                }
	            }
	        } else {
	            this.map.setView( latLng, zoom || defaultZoom );
	        }
	    }

	    _showIntersectError() {
	        dialog.alert( 'Borders cannot intersect!' );
	    }

	    /**
	     * Obtains the tile layers according to the definition in the app configuration.
	     *
	     * @return {Promise} [description]
	     */
	    _getLayers() {
	        const that = this;
	        const tasks = [];

	        maps.forEach( ( map, index ) => {
	            if ( typeof map.tiles === 'string' && /^GOOGLE_(SATELLITE|ROADMAP|HYBRID|TERRAIN)/.test( map.tiles ) ) {
	                tasks.push( that._getGoogleTileLayer( map, index ) );
	            } else
	            if ( map.tiles ) {
	                tasks.push( that._getLeafletTileLayer( map, index ) );
	            } else {
	                console.error( 'Configuration error for map tiles. Not a valid tile layer: ', map );
	            }
	        } );

	        return Promise.all( tasks );
	    }

	    /**
	     * Asynchronously (fake) obtains a Leaflet/Mapbox tilelayer
	     *
	     * @param  {{}}     map   map layer as defined in the apps configuration
	     * @param  {number} index the index of the layer
	     * @return {Promise}
	     */
	    _getLeafletTileLayer( map, index ) {
	        let url;
	        const options = this._getTileOptions( map, index );

	        // randomly pick a tile source from the array and store it in the maps config
	        // so it will be re-used when the form is reset or multiple geo widgets are created
	        map.tileIndex = ( map.tileIndex === undefined ) ? Math.round( Math.random() * 100 ) % map.tiles.length : map.tileIndex;
	        url = map.tiles[ map.tileIndex ];
	        return Promise.resolve( leafletSrc.tileLayer( url, options ) );
	    }

	    /**
	     * Asynchronously obtains a Google Maps tilelayer
	     *
	     * @param  {{}}     map   map layer as defined in the apps configuration
	     * @param  {number} index the index of the layer
	     * @return {Promise}
	     */
	    _getGoogleTileLayer( map, index ) {
	        const options = this._getTileOptions( map, index );
	        // valid values for type are 'roadmap', 'satellite', 'terrain' and 'hybrid'
	        options.type = map.tiles.substring( 7 ).toLowerCase();

	        return this._loadGoogleMapsScript()
	            .then( () => leafletSrc.gridLayer.googleMutant( options ) );
	    }

	    /**
	     * Creates the tile layer options object from the maps configuration and defaults.
	     *
	     * @param  {{}}     map   map layer as defined in the apps configuration
	     * @param  {[type]} index the index of the layer
	     * @return {{id: string, maxZoom: number, minZoom: number, name: string, attribution: string}}   Tilelayer options object
	     */
	    _getTileOptions( map, index ) {
	        const name = map.name || `map-${index + 1}`;

	        return {
	            id: map.id || name,
	            maxZoom: map.maxzoom || 18,
	            minZoom: map.minzoom || 0,
	            name,
	            attribution: map.attribution || ''
	        };
	    }

	    /**
	     * Loader for the Google Maps script that can be called multiple times, but will ensure the
	     * script is only requested once.
	     *
	     * @return {Promise} [description]
	     */
	    _loadGoogleMapsScript() {
	        // request Google maps script only once, using a variable outside of the scope of the current widget
	        // in case multiple widgets exist in the same form
	        if ( !googleMapsScriptRequest ) {
	            // create deferred object, also outside of the scope of the current widget
	            googleMapsScriptRequest = new Promise( resolve => {
	                let apiKeyQueryParam, loadUrl;

	                // create a global callback to be called by the Google Maps script once this has loaded
	                window.gmapsLoaded = () => {
	                    // clean up the global function
	                    delete window.gmapsLoaded;
	                    // resolve the deferred object
	                    resolve();
	                };
	                // make the request for the Google Maps script asynchronously
	                apiKeyQueryParam = '';
	                loadUrl = `https://maps.google.com/maps/api/js?v=3.exp${apiKeyQueryParam}&libraries=places&callback=gmapsLoaded`;
	                jquery.getScript( loadUrl );
	            } );
	        }

	        // return the promise of the deferred object outside of the scope of the current widget
	        return googleMapsScriptRequest;
	    }

	    _getDefaultLayer( layers ) {
	        let defaultLayer;
	        const that = this;

	        layers.reverse().some( layer => {
	            defaultLayer = layer;
	            return that.props.appearances.some( appearance => appearance === layer.options.name );
	        } );

	        return defaultLayer;
	    }

	    _getBaseLayers( layers ) {
	        const baseLayers = {};

	        layers.forEach( layer => {
	            baseLayers[ layer.options.name ] = layer;
	        } );

	        return baseLayers;
	    }

	    /**
	     * Updates the markers on the dynamic map from the current list of points.
	     */
	    _updateMarkers() {
	        const coords = [];
	        const markers = [];
	        const that = this;

	        // console.debug( 'updating markers', this.points );

	        if ( this.markerLayer ) {
	            this.markerLayer.clearLayers();
	        }

	        if ( this.points.length < 2 && this.points[ 0 ].join() === '' ) {
	            return;
	        }

	        this.points.forEach( ( latLng, index ) => {
	            const icon = that.props.type === 'geopoint' ? iconSingle : ( index === that.currentIndex ? iconMultiActive : iconMulti );
	            if ( that._isValidLatLng( latLng ) ) {
	                coords.push( that._cleanLatLng( latLng ) );
	                markers.push( leafletSrc.marker( that._cleanLatLng( latLng ), {
	                    icon,
	                    clickable: !that.props.readonly,
	                    draggable: !that.props.readonly,
	                    alt: index,
	                    opacity: 0.9
	                } ).on( 'click', e => {
	                    if ( e.target.options.alt === 0 && that.props.type === 'geoshape' ) {
	                        that._closePolygon();
	                    } else {
	                        that._setCurrent( e.target.options.alt );
	                    }
	                } ).on( 'dragend', e => {
	                    const latLng = e.target.getLatLng(),
	                        index = e.target.options.alt;

	                    // reduce precision to 6 decimals
	                    latLng.lat = Math.round( latLng.lat * 1000000 ) / 1000000;
	                    latLng.lng = Math.round( latLng.lng * 1000000 ) / 1000000;

	                    if ( that.polyline && that.props.type === 'geoshape' && that.updatedPolylineWouldIntersect( latLng, index ) ) {
	                        that._showIntersectError();
	                        that._updateMarkers();
	                    } else {
	                        // first set the current index the point dragged
	                        that._setCurrent( index );
	                        that._updateInputs( latLng, 'change.bymap' );
	                        that._updateMap();
	                    }
	                } ) );
	            } else {
	                console.debug( 'this latLng was not considered valid', latLng );
	            }
	        } );

	        // console.log( 'markers to update', markers );

	        if ( markers.length > 0 ) {
	            this.markerLayer = leafletSrc.layerGroup( markers ).addTo( this.map );
	            // change the view to fit all the markers
	            // don't use this for multiple markers, it messed up map clicks to place points
	            if ( this.points.length === 1 || !this._isValidLatLngList( this.points ) ) {
	                // center the map, keep zoom level unchanged
	                this.map.setView( coords[ 0 ], this.lastZoom || defaultZoom );
	            }
	        }
	    }

	    /**
	     * Updates the polyline on the dynamic map from the current list of points
	     */
	    _updatePolyline() {
	        let polylinePoints;
	        const that = this;

	        if ( this.props.type === 'geopoint' ) {
	            return;
	        }

	        // console.log( 'updating polyline' );
	        if ( this.points.length < 2 || !this._isValidLatLngList( this.points ) ) {
	            // remove quirky line remainder
	            if ( this.map ) {
	                if ( this.polyline ) {
	                    this.map.removeLayer( this.polyline );
	                }
	                if ( this.polygon ) {
	                    this.map.removeLayer( this.polygon );
	                }
	            }
	            this.polyline = null;
	            this.polygon = null;
	            // console.log( 'list of points invalid' );
	            return;
	        }

	        if ( this.props.type === 'geoshape' ) {
	            this._updatePolygon();
	        }

	        polylinePoints = ( this.points[ this.points.length - 1 ].join( '' ) !== '' ) ? this.points : this.points.slice( 0, this.points.length - 1 );

	        polylinePoints = polylinePoints.map( point => that._cleanLatLng( point ) );

	        if ( !this.polyline ) {
	            this.polyline = leafletSrc.polyline( polylinePoints, {
	                color: 'red'
	            } );
	            this.map.addLayer( this.polyline );
	        } else {
	            this.polyline.setLatLngs( polylinePoints );
	        }

	        // possible bug in Leaflet, using timeout to work around
	        setTimeout( () => {
	            that.map.fitBounds( that.polyline.getBounds() );
	        }, 0 );
	    }

	    /**
	     * Updates the polygon on the dynamic map from the current list of points.
	     * A polygon is a type of polyline. This function is ALWAYS called by _updatePolyline.
	     */
	    _updatePolygon() {
	        let polygonPoints;
	        const that = this;

	        if ( this.props.type === 'geopoint' || this.props.type === 'geotrace' ) {
	            return;
	        }

	        // console.log( 'updating polygon' );
	        polygonPoints = ( this.points[ this.points.length - 1 ].join( '' ) !== '' ) ? this.points : this.points.slice( 0, this.points.length - 1 );

	        polygonPoints = polygonPoints.map( point => that._cleanLatLng( point ) );

	        if ( !this.polygon ) {
	            // console.log( 'creating new polygon' );
	            this.polygon = leafletSrc.polygon( polygonPoints, {
	                color: 'red',
	                stroke: false
	            } );
	            this.map.addLayer( this.polygon );
	        } else {
	            // console.log( 'updating existing polygon', this.points );
	            this.polygon.setLatLngs( polygonPoints );
	        }

	        this._updateArea( polygonPoints );
	    }

	    /**
	     * Updates the area in m2 shown inside a polygon.
	     * @type {[type]}
	     */
	    _updateArea( points ) {
	        let area;
	        let readableArea;

	        if ( points.length > 2 ) {
	            const latLngs = points.map( point => ( {
	                lat: point[ 0 ],
	                lng: point[ 1 ]
	            } ) );
	            area = leafletSrc.GeometryUtil.geodesicArea( latLngs );
	            readableArea = leafletSrc.GeometryUtil.readableArea( area, true );

	            leafletSrc
	                .popup( {
	                    className: 'enketo-area-popup'
	                } )
	                .setLatLng( this.polygon.getBounds().getCenter() )
	                .setContent( readableArea )
	                .openOn( this.map );
	        } else {
	            this.map.closePopup();
	        }

	    }

	    _addPoint() {
	        this._addPointBtn();
	        this.points.push( [] );
	        this._setCurrent( this.points.length - 1 );
	        this._updateValue();
	    }

	    /**
	     * Edits a point in the list of points
	     * @param  {Array.<number>|{lat: number, lng: number, alt: number, acc: number}} latLng LatLng object or array
	     * @return {Boolean]}        Whether point changed.
	     */
	    _editPoint( latLng ) {
	        let changed;

	        this.points[ this.currentIndex ] = latLng;

	        changed = this._updateValue();

	        if ( changed ) {
	            this._updateMap();
	        }

	        return changed;
	    }

	    /**
	     * Removes the current point
	     */
	    _removePoint() {
	        let newIndex = this.currentIndex;
	        this.points.splice( this.currentIndex, 1 );
	        this._updateValue();
	        this.$points.find( '.point' ).eq( this.currentIndex ).remove();
	        if ( typeof this.points[ this.currentIndex ] === 'undefined' ) {
	            newIndex = this.currentIndex - 1;
	        }
	        this._setCurrent( newIndex );
	        // this will call updateMarkers for the second time which is not so efficient
	        this._updateMap();
	    }

	    _closePolygon() {
	        const lastPoint = this.points[ this.points.length - 1 ];
	        // console.debug( 'closing polygon' );

	        // check if chain can be closed
	        if ( this.points.length < 3 || ( this.points.length === 3 && !this._isValidLatLng( this.points[ 2 ] ) ) || ( JSON.stringify( this.points[ 0 ] ) === JSON.stringify( lastPoint ) ) ) {
	            return;
	        }

	        // determine which point the make the closing point
	        // if the last point is not a valid point, assume the user wants to use this to close
	        // otherwise create a new point.
	        if ( !this._isValidLatLng( lastPoint ) ) {
	            console.log( 'current last point is not a valid point, so will use this as closing point' );
	            this.currentIndex = this.points.length - 1;
	        } else {
	            console.log( 'current last point is valid, so will create a new one to use to close' );
	            this._addPoint();
	        }

	        // final check to see if there are intersections
	        if ( this.polyline && !this.containsEmptyPoints( this.points, this.points.length ) && this.updatedPolylineWouldIntersect( this.points[ 0 ], this.currentIndex ) ) {
	            return this._showIntersectError();
	        }

	        this._updateInputs( this.points[ 0 ] );
	    }

	    /**
	     * Updates the (fake) input element for latitude, longitude, altitude and accuracy
	     *
	     * @param  @param  {Array.<number>|{lat: number, lng: number, alt: number, acc: number}} coords latitude, longitude, altitude and accuracy
	     * @param  {string=} ev  [description]
	     */
	    _updateInputs( coords, ev ) {
	        const lat = coords[ 0 ] || coords.lat || '';
	        const lng = coords[ 1 ] || coords.lng || '';
	        const alt = coords[ 2 ] || coords.alt || '';
	        const acc = coords[ 3 ] || coords.acc || '';

	        ev = ( typeof ev !== 'undefined' ) ? ev : 'change';

	        this.$lat.val( lat || '' );
	        this.$lng.val( lng || '' );
	        this.$alt.val( alt || '' );
	        this.$acc.val( acc || '' ).trigger( ev );
	    }

	    /** 
	     * Converts the contents of a single KML <coordinates> element (may inlude the coordinates tags as well) to an array
	     * of geopoint coordinates used in the ODK XForm format. Note that the KML format does not allow spaces within a tuple of coordinates
	     * only between. Separator between KML tuples can be newline, space or a combination.
	     * It only extracts the value of the first <coordinates> element or, if <coordinates> are not included from the whole string.
	     *
	     * @param  {string} kmlCoordinates [description]
	     * @return {Array.<Array<Number>>} Array of geopoint coordinates
	     */
	    _convertKmlCoordinatesToLeafletCoordinates( kmlCoordinates ) {
	        const coordinates = [];
	        const reg = /<\s?coordinates>(([^<]|\n)*)<\/\s?coordinates\s?>/;
	        const tags = reg.test( kmlCoordinates );

	        kmlCoordinates = ( tags ) ? kmlCoordinates.match( reg )[ 1 ] : kmlCoordinates;
	        kmlCoordinates.trim().split( /\s+/ ).forEach( item => {
	            const coordinate = [];

	            item.split( ',' ).forEach( ( c, index ) => {
	                const value = Number( c );
	                if ( index === 0 ) {
	                    coordinate[ 1 ] = value;
	                } else if ( index === 1 ) {
	                    coordinate[ 0 ] = value;
	                } else if ( index === 2 ) {
	                    coordinate[ 2 ] = value;
	                }
	            } );

	            coordinates.push( coordinate );
	        } );

	        return coordinates;
	    }

	    /**
	     * Check if a polyline created from the current collection of points
	     * where one point is added or edited would have intersections.
	     * @param  {[type]} latLng [description]
	     * @param  {[type]} index  [description]
	     * @return {[type]} [description]
	     */
	    updatedPolylineWouldIntersect( latLng, index ) {
	        const pointsToTest = [];
	        let polylinePoints;
	        let polylineToTest;
	        let intersects;
	        const that = this;

	        if ( this.points < 3 ) {
	            return false;
	        }

	        // create a deep copy of the current points
	        jquery.extend( true, pointsToTest, this.points );

	        // edit/add one point
	        pointsToTest[ index ] = [ latLng[ 0 ] || latLng.lat, latLng[ 1 ] || latLng.lng ];

	        // check whether last point is empty and remove it if so
	        polylinePoints = ( pointsToTest[ pointsToTest.length - 1 ].join( '' ) !== '' ) ? pointsToTest : pointsToTest.slice( 0, pointsToTest.length - 1 );

	        // remove last one if closed
	        // This introduces a bug as it enables creating a spiral that is closed
	        // with an intersection.
	        if ( polylinePoints[ 0 ][ 0 ] === polylinePoints[ polylinePoints.length - 1 ][ 0 ] &&
	            polylinePoints[ 0 ][ 1 ] === polylinePoints[ polylinePoints.length - 1 ][ 1 ] ) {
	            polylinePoints = polylinePoints.slice( 0, polylinePoints.length - 1 );
	        }

	        polylinePoints = polylinePoints.map( point => that._cleanLatLng( point ) );

	        // create polyline
	        polylineToTest = leafletSrc.polyline( polylinePoints, {
	            color: 'white'
	        } );

	        // add to map because the Polyline draw extension expects this
	        this.map.addLayer( polylineToTest );

	        // check for intersection
	        intersects = polylineToTest.intersects();

	        // clean up
	        this.map.removeLayer( polylineToTest );

	        return intersects;
	    }

	    /**
	     * Checks whether the array of points contains empty ones.
	     *
	     * @allowedIndex {number=} The index in which an empty value is allowed
	     * @return {[type]} [description]
	     */
	    containsEmptyPoints( points, allowedIndex ) {
	        return points.some( ( point, index ) => index !== allowedIndex && ( !point[ 0 ] || !point[ 1 ] ) );
	    }

	    /**
	     * Gets the widget properties and features.
	     *
	     * @return {{search: boolean, detect: boolean, map: boolean, updateMapFn: string, type: string}} The widget properties object
	     */
	    get props() {
	        const props = this._props;

	        props.detect = !!navigator.geolocation;
	        props.map = !support.touch || props.appearances.includes( 'maps' ) || props.appearances.includes( 'placement-map' );
	        props.search = props.map;
	        props.touch = support.touch;
	        props.wide = this.question.clientWidth / this.element.closest( 'form.or' ).clientWidth > 0.8;

	        return props;
	    }

	    get value() {
	        let newValue = '';
	        // all points should be valid geopoints and only the last item may be empty
	        this.points.forEach( ( point, index, array ) => {
	            let geopoint;
	            const lat = typeof point[ 0 ] === 'number' ? point[ 0 ] : ( typeof point.lat === 'number' ? point.lat : null );
	            const lng = typeof point[ 1 ] === 'number' ? point[ 1 ] : ( typeof point.lng === 'number' ? point.lng : null );
	            const alt = typeof point[ 2 ] === 'number' ? point[ 2 ] : 0.0;
	            const acc = typeof point[ 3 ] === 'number' ? point[ 3 ] : 0.0;

	            geopoint = ( lat && lng ) ? `${lat} ${lng} ${alt} ${acc}` : '';

	            // only last item may be empty
	            // TODO: it is not great to have markAsInvalid functionality in the value getter.
	            if ( !this._isValidGeopoint( geopoint ) && !( geopoint === '' && index === array.length - 1 ) ) {
	                this._markAsInvalid( index );
	            }
	            // newGeoTraceValue += geopoint;
	            if ( !( geopoint === '' && index === array.length - 1 ) ) {
	                newValue += geopoint;
	                if ( index !== array.length - 1 ) {
	                    newValue += ';';
	                }
	            } else {
	                // remove trailing semi-colon
	                newValue = newValue.substring( 0, newValue.lastIndexOf( ';' ) );
	            }
	        } );
	        return newValue;
	    }

	    set value( value ) {
	        value.trim().split( ';' ).forEach( ( el, i ) => {
	            // console.debug( 'adding loaded point', el.trim().split( ' ' ) );
	            this.points[ i ] = el.trim().split( ' ' );
	            this.points[ i ].forEach( ( str, i, arr ) => {
	                arr[ i ] = Number( str );
	            } );
	        } );
	    }

	    /**
	     * Enables a disabled widget
	     */
	    enable() {
	        jquery( this.element )
	            .next( '.widget' )
	            .removeClass( 'readonly' )
	            .find( 'input, select, textarea' ).prop( 'disabled', false )
	            .end()
	            .find( '.btn:not(.show-map-btn):not(.hide-map-btn), .btn-icon-only, .addpoint' ).prop( 'disabled', false );

	        // ensure all tiles are displayed, https://github.com/kobotoolbox/enketo-express/issues/188
	        if ( this.map ) {
	            this.map.invalidateSize();
	        }
	    }

	    /**
	     * Disables the widget
	     */
	    disable() {
	        jquery( this.element )
	            .next( '.widget' )
	            .addClass( 'readonly' )
	            .find( 'input, select, textarea' ).prop( 'disabled', true )
	            .end()
	            .find( '.btn:not(.show-map-btn):not(.hide-map-btn), .btn-icon-only, .addpoint' ).prop( 'disabled', true );
	    }

	    /**
	     * Updates the widget if the value has updated programmatically (e.g. due to a calculation)
	     */
	    update() {
	        /**
	         * It is somewhat complex to properly update, especially when the widget is currently
	         * showing a list of geotrace/geoshape points. Hence we use the inefficient but robust
	         * method to re-initialize instead.
	         */
	        const widget = this.element.parentElement.querySelector( '.widget' );
	        if ( widget ) {
	            widget.remove();
	            this.map = undefined;
	            this.polyline = undefined;
	            this.polygon = undefined;
	            this._init();
	        }
	    }
	}

	/**
	 * Auto-resizes textarea elements.
	 */
	class TextareaWidget extends Widget {

	    static get selector() {
	        return 'form';
	    }

	    _init() {
	        const textarea = this.element.querySelector( 'textarea' );
	        const defaultHeight = textarea ? textarea.clientHeight : 20;
	        this.element.addEventListener( 'input', event => {
	            const el = event.target;
	            if ( el.nodeName.toLowerCase() === 'textarea' ) {
	                if ( el.scrollHeight > el.clientHeight && el.scrollHeight > defaultHeight ) {
	                    // setting min-height instead of height, as height doesn't work in Grid Theme.
	                    el.style[ 'min-height' ] = `${el.scrollHeight}px`;
	                }
	            }
	        } );
	    }
	}

	// Since this class has no static selector getter, there will be no attempt to instantiate it.
	class TableWidget {}

	/**
	 * Enhances radio buttons
	 */
	class Radiopicker extends Widget {

	    static get selector() {
	        return 'form';
	    }

	    _init() {
	        const $form = jquery( this.element );
	        const that = this;

	        $form
	            // Applies a data-checked attribute to the parent label of a checked radiobutton.
	            .on( 'click', 'input[type="radio"]:not([readonly]):checked', function() {
	                jquery( this ).parent( 'label' ).siblings().removeAttr( 'data-checked' ).end().attr( 'data-checked', 'true' );
	            } )
	            // Same for checkbox.
	            .on( 'click', 'input[type="checkbox"]:not([readonly])', function() {
	                that._updateDataChecked( this );
	            } )
	            // Detect programmatic changes to update data-checked attribute.
	            .on( event.InputUpdate().type, 'input[type="radio"], input[type="checkbox"]', function() {
	                this.closest( '.option-wrapper' )
	                    .querySelectorAll( 'input[type="radio"],input[type="checkbox"]' )
	                    .forEach( input => that._updateDataChecked( input ) );
	            } )
	            // Readonly buttons/checkboxes will not respond to clicks.
	            .on( 'click', 'input[type="checkbox"][readonly],input[type="radio"][readonly]', event => {
	                event.stopImmediatePropagation();
	                return false;
	            } )
	            /*
	             * In Safari a click on a readonly checkbox/radio button sets `checked` to true, **before** the click event fires.
	             * This causes the model to update. The above clickhandler will set the checked back to false, but there is
	             * no way to propagate that reversion back to the model.
	             * 
	             * Disabling change handling on readonly checkboxes/radiobuttons is not an option, because of the scenario
	             * described in Form.js in the comment above the change handler.
	             * 
	             * The solution is to detect here whether the change event was triggered by a human, by checking if the 
	             * originalEvent property is defined.
	             * 
	             * See more at https://github.com/enketo/enketo-core/issues/516
	             */
	            .on( event.Change().type, 'input[type="checkbox"][readonly],input[type="radio"][readonly]', function( event ) {
	                const byProgram = typeof event.originalEvent === 'undefined';
	                if ( !byProgram ) {
	                    event.stopImmediatePropagation();
	                    /*               
	                     * For radiobuttons, this is ugly and relies on the data-checked attribute.
	                     * Without this, is it still possible to check a readonly radio button (although it won't propagate to the model).
	                     * I think this is the only remnant of the usage of data-checked in Enketo. However, it is
	                     * also still relied upon by Esri/Survey123.
	                     */
	                    if ( this.checked && this.parentNode.dataset.checked !== 'true' ) {
	                        this.checked = false;
	                    }
	                }
	                return byProgram;
	            } )
	            // Add unselect radio button functionality.
	            .on( 'click', '[data-checked]>input[type="radio"]:not(.no-unselect)', function() {
	                jquery( this ).prop( 'checked', false ).trigger( 'change' ).parent().removeAttr( 'data-checked' );
	            } );

	        // Defaults
	        this.element
	            .querySelectorAll( 'input[type="radio"]:checked, input[type="checkbox"]:checked' )
	            .forEach( input => this._updateDataChecked( input ) );

	    }

	    _updateDataChecked( el ) {
	        if ( el.checked ) {
	            el.parentNode.dataset.checked = true;
	        } else {
	            delete el.parentNode.dataset.checked;
	        }
	    }
	}

	var bootstrapDatepicker = createCommonjsModule(function (module, exports) {
	/*!
	 * Datepicker for Bootstrap v1.8.0 (https://github.com/uxsolutions/bootstrap-datepicker)
	 *
	 * Licensed under the Apache License v2.0 (http://www.apache.org/licenses/LICENSE-2.0)
	 */

	(function(factory){
	    {
	        factory(jquery);
	    }
	}(function($, undefined$1){
		function UTCDate(){
			return new Date(Date.UTC.apply(Date, arguments));
		}
		function UTCToday(){
			var today = new Date();
			return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
		}
		function isUTCEquals(date1, date2) {
			return (
				date1.getUTCFullYear() === date2.getUTCFullYear() &&
				date1.getUTCMonth() === date2.getUTCMonth() &&
				date1.getUTCDate() === date2.getUTCDate()
			);
		}
		function alias(method, deprecationMsg){
			return function(){
				if (deprecationMsg !== undefined$1) {
					$.fn.datepicker.deprecated(deprecationMsg);
				}

				return this[method].apply(this, arguments);
			};
		}
		function isValidDate(d) {
			return d && !isNaN(d.getTime());
		}

		var DateArray = (function(){
			var extras = {
				get: function(i){
					return this.slice(i)[0];
				},
				contains: function(d){
					// Array.indexOf is not cross-browser;
					// $.inArray doesn't work with Dates
					var val = d && d.valueOf();
					for (var i=0, l=this.length; i < l; i++)
	          // Use date arithmetic to allow dates with different times to match
	          if (0 <= this[i].valueOf() - val && this[i].valueOf() - val < 1000*60*60*24)
							return i;
					return -1;
				},
				remove: function(i){
					this.splice(i,1);
				},
				replace: function(new_array){
					if (!new_array)
						return;
					if (!$.isArray(new_array))
						new_array = [new_array];
					this.clear();
					this.push.apply(this, new_array);
				},
				clear: function(){
					this.length = 0;
				},
				copy: function(){
					var a = new DateArray();
					a.replace(this);
					return a;
				}
			};

			return function(){
				var a = [];
				a.push.apply(a, arguments);
				$.extend(a, extras);
				return a;
			};
		})();


		// Picker object

		var Datepicker = function(element, options){
			$.data(element, 'datepicker', this);
			this._process_options(options);

			this.dates = new DateArray();
			this.viewDate = this.o.defaultViewDate;
			this.focusDate = null;

			this.element = $(element);
			this.isInput = this.element.is('input');
			this.inputField = this.isInput ? this.element : this.element.find('input');
			this.component = this.element.hasClass('date') ? this.element.find('.add-on, .input-group-addon, .btn') : false;
			if (this.component && this.component.length === 0)
				this.component = false;
			this.isInline = !this.component && this.element.is('div');

			this.picker = $(DPGlobal.template);

			// Checking templates and inserting
			if (this._check_template(this.o.templates.leftArrow)) {
				this.picker.find('.prev').html(this.o.templates.leftArrow);
			}

			if (this._check_template(this.o.templates.rightArrow)) {
				this.picker.find('.next').html(this.o.templates.rightArrow);
			}

			this._buildEvents();
			this._attachEvents();

			if (this.isInline){
				this.picker.addClass('datepicker-inline').appendTo(this.element);
			}
			else {
				this.picker.addClass('datepicker-dropdown dropdown-menu');
			}

			if (this.o.rtl){
				this.picker.addClass('datepicker-rtl');
			}

			if (this.o.calendarWeeks) {
				this.picker.find('.datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear')
					.attr('colspan', function(i, val){
						return Number(val) + 1;
					});
			}

			this._process_options({
				startDate: this._o.startDate,
				endDate: this._o.endDate,
				daysOfWeekDisabled: this.o.daysOfWeekDisabled,
				daysOfWeekHighlighted: this.o.daysOfWeekHighlighted,
				datesDisabled: this.o.datesDisabled
			});

			this._allow_update = false;
			this.setViewMode(this.o.startView);
			this._allow_update = true;

			this.fillDow();
			this.fillMonths();

			this.update();

			if (this.isInline){
				this.show();
			}
		};

		Datepicker.prototype = {
			constructor: Datepicker,

			_resolveViewName: function(view){
				$.each(DPGlobal.viewModes, function(i, viewMode){
					if (view === i || $.inArray(view, viewMode.names) !== -1){
						view = i;
						return false;
					}
				});

				return view;
			},

			_resolveDaysOfWeek: function(daysOfWeek){
				if (!$.isArray(daysOfWeek))
					daysOfWeek = daysOfWeek.split(/[,\s]*/);
				return $.map(daysOfWeek, Number);
			},

			_check_template: function(tmp){
				try {
					// If empty
					if (tmp === undefined$1 || tmp === "") {
						return false;
					}
					// If no html, everything ok
					if ((tmp.match(/[<>]/g) || []).length <= 0) {
						return true;
					}
					// Checking if html is fine
					var jDom = $(tmp);
					return jDom.length > 0;
				}
				catch (ex) {
					return false;
				}
			},

			_process_options: function(opts){
				// Store raw options for reference
				this._o = $.extend({}, this._o, opts);
				// Processed options
				var o = this.o = $.extend({}, this._o);

				// Check if "de-DE" style date is available, if not language should
				// fallback to 2 letter code eg "de"
				var lang = o.language;
				if (!dates[lang]){
					lang = lang.split('-')[0];
					if (!dates[lang])
						lang = defaults.language;
				}
				o.language = lang;

				// Retrieve view index from any aliases
				o.startView = this._resolveViewName(o.startView);
				o.minViewMode = this._resolveViewName(o.minViewMode);
				o.maxViewMode = this._resolveViewName(o.maxViewMode);

				// Check view is between min and max
				o.startView = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, o.startView));

				// true, false, or Number > 0
				if (o.multidate !== true){
					o.multidate = Number(o.multidate) || false;
					if (o.multidate !== false)
						o.multidate = Math.max(0, o.multidate);
				}
				o.multidateSeparator = String(o.multidateSeparator);

				o.weekStart %= 7;
				o.weekEnd = (o.weekStart + 6) % 7;

				var format = DPGlobal.parseFormat(o.format);
				if (o.startDate !== -Infinity){
					if (!!o.startDate){
						if (o.startDate instanceof Date)
							o.startDate = this._local_to_utc(this._zero_time(o.startDate));
						else
							o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear);
					}
					else {
						o.startDate = -Infinity;
					}
				}
				if (o.endDate !== Infinity){
					if (!!o.endDate){
						if (o.endDate instanceof Date)
							o.endDate = this._local_to_utc(this._zero_time(o.endDate));
						else
							o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear);
					}
					else {
						o.endDate = Infinity;
					}
				}

				o.daysOfWeekDisabled = this._resolveDaysOfWeek(o.daysOfWeekDisabled||[]);
				o.daysOfWeekHighlighted = this._resolveDaysOfWeek(o.daysOfWeekHighlighted||[]);

				o.datesDisabled = o.datesDisabled||[];
				if (!$.isArray(o.datesDisabled)) {
					o.datesDisabled = o.datesDisabled.split(',');
				}
				o.datesDisabled = $.map(o.datesDisabled, function(d){
					return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear);
				});

				var plc = String(o.orientation).toLowerCase().split(/\s+/g),
					_plc = o.orientation.toLowerCase();
				plc = $.grep(plc, function(word){
					return /^auto|left|right|top|bottom$/.test(word);
				});
				o.orientation = {x: 'auto', y: 'auto'};
				if (!_plc || _plc === 'auto')
					; // no action
				else if (plc.length === 1){
					switch (plc[0]){
						case 'top':
						case 'bottom':
							o.orientation.y = plc[0];
							break;
						case 'left':
						case 'right':
							o.orientation.x = plc[0];
							break;
					}
				}
				else {
					_plc = $.grep(plc, function(word){
						return /^left|right$/.test(word);
					});
					o.orientation.x = _plc[0] || 'auto';

					_plc = $.grep(plc, function(word){
						return /^top|bottom$/.test(word);
					});
					o.orientation.y = _plc[0] || 'auto';
				}
				if (o.defaultViewDate instanceof Date || typeof o.defaultViewDate === 'string') {
					o.defaultViewDate = DPGlobal.parseDate(o.defaultViewDate, format, o.language, o.assumeNearbyYear);
				} else if (o.defaultViewDate) {
					var year = o.defaultViewDate.year || new Date().getFullYear();
					var month = o.defaultViewDate.month || 0;
					var day = o.defaultViewDate.day || 1;
					o.defaultViewDate = UTCDate(year, month, day);
				} else {
					o.defaultViewDate = UTCToday();
				}
			},
			_events: [],
			_secondaryEvents: [],
			_applyEvents: function(evs){
				for (var i=0, el, ch, ev; i < evs.length; i++){
					el = evs[i][0];
					if (evs[i].length === 2){
						ch = undefined$1;
						ev = evs[i][1];
					} else if (evs[i].length === 3){
						ch = evs[i][1];
						ev = evs[i][2];
					}
					el.on(ev, ch);
				}
			},
			_unapplyEvents: function(evs){
				for (var i=0, el, ev, ch; i < evs.length; i++){
					el = evs[i][0];
					if (evs[i].length === 2){
						ch = undefined$1;
						ev = evs[i][1];
					} else if (evs[i].length === 3){
						ch = evs[i][1];
						ev = evs[i][2];
					}
					el.off(ev, ch);
				}
			},
			_buildEvents: function(){
	            var events = {
	                keyup: $.proxy(function(e){
	                    if ($.inArray(e.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1)
	                        this.update();
	                }, this),
	                keydown: $.proxy(this.keydown, this),
	                paste: $.proxy(this.paste, this)
	            };

	            if (this.o.showOnFocus === true) {
	                events.focus = $.proxy(this.show, this);
	            }

	            if (this.isInput) { // single input
	                this._events = [
	                    [this.element, events]
	                ];
	            }
	            // component: input + button
	            else if (this.component && this.inputField.length) {
	                this._events = [
	                    // For components that are not readonly, allow keyboard nav
	                    [this.inputField, events],
	                    [this.component, {
	                        click: $.proxy(this.show, this)
	                    }]
	                ];
	            }
				else {
					this._events = [
						[this.element, {
							click: $.proxy(this.show, this),
							keydown: $.proxy(this.keydown, this)
						}]
					];
				}
				this._events.push(
					// Component: listen for blur on element descendants
					[this.element, '*', {
						blur: $.proxy(function(e){
							this._focused_from = e.target;
						}, this)
					}],
					// Input: listen for blur on element
					[this.element, {
						blur: $.proxy(function(e){
							this._focused_from = e.target;
						}, this)
					}]
				);

				if (this.o.immediateUpdates) {
					// Trigger input updates immediately on changed year/month
					this._events.push([this.element, {
						'changeYear changeMonth': $.proxy(function(e){
							this.update(e.date);
						}, this)
					}]);
				}

				this._secondaryEvents = [
					[this.picker, {
						click: $.proxy(this.click, this)
					}],
					[this.picker, '.prev, .next', {
						click: $.proxy(this.navArrowsClick, this)
					}],
					[this.picker, '.day:not(.disabled)', {
						click: $.proxy(this.dayCellClick, this)
					}],
					[$(window), {
						resize: $.proxy(this.place, this)
					}],
					[$(document), {
						'mousedown touchstart': $.proxy(function(e){
							// Clicked outside the datepicker, hide it
							if (!(
								this.element.is(e.target) ||
								this.element.find(e.target).length ||
								this.picker.is(e.target) ||
								this.picker.find(e.target).length ||
								this.isInline
							)){
								this.hide();
							}
						}, this)
					}]
				];
			},
			_attachEvents: function(){
				this._detachEvents();
				this._applyEvents(this._events);
			},
			_detachEvents: function(){
				this._unapplyEvents(this._events);
			},
			_attachSecondaryEvents: function(){
				this._detachSecondaryEvents();
				this._applyEvents(this._secondaryEvents);
			},
			_detachSecondaryEvents: function(){
				this._unapplyEvents(this._secondaryEvents);
			},
			_trigger: function(event, altdate){
				var date = altdate || this.dates.get(-1),
					local_date = this._utc_to_local(date);

				this.element.trigger({
					type: event,
					date: local_date,
					viewMode: this.viewMode,
					dates: $.map(this.dates, this._utc_to_local),
					format: $.proxy(function(ix, format){
						if (arguments.length === 0){
							ix = this.dates.length - 1;
							format = this.o.format;
						} else if (typeof ix === 'string'){
							format = ix;
							ix = this.dates.length - 1;
						}
						format = format || this.o.format;
						var date = this.dates.get(ix);
						return DPGlobal.formatDate(date, format, this.o.language);
					}, this)
				});
			},

			show: function(){
				if (this.inputField.prop('disabled') || (this.inputField.prop('readonly') && this.o.enableOnReadonly === false))
					return;
				if (!this.isInline)
					this.picker.appendTo(this.o.container);
				this.place();
				this.picker.show();
				this._attachSecondaryEvents();
				this._trigger('show');
				if ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && this.o.disableTouchKeyboard) {
					$(this.element).blur();
				}
				return this;
			},

			hide: function(){
				if (this.isInline || !this.picker.is(':visible'))
					return this;
				this.focusDate = null;
				this.picker.hide().detach();
				this._detachSecondaryEvents();
				this.setViewMode(this.o.startView);

				if (this.o.forceParse && this.inputField.val())
					this.setValue();
				this._trigger('hide');
				return this;
			},

			destroy: function(){
				this.hide();
				this._detachEvents();
				this._detachSecondaryEvents();
				this.picker.remove();
				delete this.element.data().datepicker;
				if (!this.isInput){
					delete this.element.data().date;
				}
				return this;
			},

			paste: function(e){
				var dateString;
				if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.types
					&& $.inArray('text/plain', e.originalEvent.clipboardData.types) !== -1) {
					dateString = e.originalEvent.clipboardData.getData('text/plain');
				} else if (window.clipboardData) {
					dateString = window.clipboardData.getData('Text');
				} else {
					return;
				}
				this.setDate(dateString);
				this.update();
				e.preventDefault();
			},

			_utc_to_local: function(utc){
				if (!utc) {
					return utc;
				}

				var local = new Date(utc.getTime() + (utc.getTimezoneOffset() * 60000));

				if (local.getTimezoneOffset() !== utc.getTimezoneOffset()) {
					local = new Date(utc.getTime() + (local.getTimezoneOffset() * 60000));
				}

				return local;
			},
			_local_to_utc: function(local){
				return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
			},
			_zero_time: function(local){
				return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
			},
			_zero_utc_time: function(utc){
				return utc && UTCDate(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate());
			},

			getDates: function(){
				return $.map(this.dates, this._utc_to_local);
			},

			getUTCDates: function(){
				return $.map(this.dates, function(d){
					return new Date(d);
				});
			},

			getDate: function(){
				return this._utc_to_local(this.getUTCDate());
			},

			getUTCDate: function(){
				var selected_date = this.dates.get(-1);
				if (selected_date !== undefined$1) {
					return new Date(selected_date);
				} else {
					return null;
				}
			},

			clearDates: function(){
				this.inputField.val('');
				this.update();
				this._trigger('changeDate');

				if (this.o.autoclose) {
					this.hide();
				}
			},

			setDates: function(){
				var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
				this.update.apply(this, args);
				this._trigger('changeDate');
				this.setValue();
				return this;
			},

			setUTCDates: function(){
				var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
				this.setDates.apply(this, $.map(args, this._utc_to_local));
				return this;
			},

			setDate: alias('setDates'),
			setUTCDate: alias('setUTCDates'),
			remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead'),

			setValue: function(){
				var formatted = this.getFormattedDate();
				this.inputField.val(formatted);
				return this;
			},

			getFormattedDate: function(format){
				if (format === undefined$1)
					format = this.o.format;

				var lang = this.o.language;
				return $.map(this.dates, function(d){
					return DPGlobal.formatDate(d, format, lang);
				}).join(this.o.multidateSeparator);
			},

			getStartDate: function(){
				return this.o.startDate;
			},

			setStartDate: function(startDate){
				this._process_options({startDate: startDate});
				this.update();
				this.updateNavArrows();
				return this;
			},

			getEndDate: function(){
				return this.o.endDate;
			},

			setEndDate: function(endDate){
				this._process_options({endDate: endDate});
				this.update();
				this.updateNavArrows();
				return this;
			},

			setDaysOfWeekDisabled: function(daysOfWeekDisabled){
				this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
				this.update();
				return this;
			},

			setDaysOfWeekHighlighted: function(daysOfWeekHighlighted){
				this._process_options({daysOfWeekHighlighted: daysOfWeekHighlighted});
				this.update();
				return this;
			},

			setDatesDisabled: function(datesDisabled){
				this._process_options({datesDisabled: datesDisabled});
				this.update();
				return this;
			},

			place: function(){
				if (this.isInline)
					return this;
				var calendarWidth = this.picker.outerWidth(),
					calendarHeight = this.picker.outerHeight(),
					visualPadding = 10,
					container = $(this.o.container),
					windowWidth = container.width(),
					scrollTop = this.o.container === 'body' ? $(document).scrollTop() : container.scrollTop(),
					appendOffset = container.offset();

				var parentsZindex = [0];
				this.element.parents().each(function(){
					var itemZIndex = $(this).css('z-index');
					if (itemZIndex !== 'auto' && Number(itemZIndex) !== 0) parentsZindex.push(Number(itemZIndex));
				});
				var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset;
				var offset = this.component ? this.component.parent().offset() : this.element.offset();
				var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
				var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
				var left = offset.left - appendOffset.left;
				var top = offset.top - appendOffset.top;

				if (this.o.container !== 'body') {
					top += scrollTop;
				}

				this.picker.removeClass(
					'datepicker-orient-top datepicker-orient-bottom '+
					'datepicker-orient-right datepicker-orient-left'
				);

				if (this.o.orientation.x !== 'auto'){
					this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
					if (this.o.orientation.x === 'right')
						left -= calendarWidth - width;
				}
				// auto x orientation is best-placement: if it crosses a window
				// edge, fudge it sideways
				else {
					if (offset.left < 0) {
						// component is outside the window on the left side. Move it into visible range
						this.picker.addClass('datepicker-orient-left');
						left -= offset.left - visualPadding;
					} else if (left + calendarWidth > windowWidth) {
						// the calendar passes the widow right edge. Align it to component right side
						this.picker.addClass('datepicker-orient-right');
						left += width - calendarWidth;
					} else {
						if (this.o.rtl) {
							// Default to right
							this.picker.addClass('datepicker-orient-right');
						} else {
							// Default to left
							this.picker.addClass('datepicker-orient-left');
						}
					}
				}

				// auto y orientation is best-situation: top or bottom, no fudging,
				// decision based on which shows more of the calendar
				var yorient = this.o.orientation.y,
					top_overflow;
				if (yorient === 'auto'){
					top_overflow = -scrollTop + top - calendarHeight;
					yorient = top_overflow < 0 ? 'bottom' : 'top';
				}

				this.picker.addClass('datepicker-orient-' + yorient);
				if (yorient === 'top')
					top -= calendarHeight + parseInt(this.picker.css('padding-top'));
				else
					top += height;

				if (this.o.rtl) {
					var right = windowWidth - (left + width);
					this.picker.css({
						top: top,
						right: right,
						zIndex: zIndex
					});
				} else {
					this.picker.css({
						top: top,
						left: left,
						zIndex: zIndex
					});
				}
				return this;
			},

			_allow_update: true,
			update: function(){
				if (!this._allow_update)
					return this;

				var oldDates = this.dates.copy(),
					dates = [],
					fromArgs = false;
				if (arguments.length){
					$.each(arguments, $.proxy(function(i, date){
						if (date instanceof Date)
							date = this._local_to_utc(date);
						dates.push(date);
					}, this));
					fromArgs = true;
				} else {
					dates = this.isInput
							? this.element.val()
							: this.element.data('date') || this.inputField.val();
					if (dates && this.o.multidate)
						dates = dates.split(this.o.multidateSeparator);
					else
						dates = [dates];
					delete this.element.data().date;
				}

				dates = $.map(dates, $.proxy(function(date){
					return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear);
				}, this));
				dates = $.grep(dates, $.proxy(function(date){
					return (
						!this.dateWithinRange(date) ||
						!date
					);
				}, this), true);
				this.dates.replace(dates);

				if (this.o.updateViewDate) {
					if (this.dates.length)
						this.viewDate = new Date(this.dates.get(-1));
					else if (this.viewDate < this.o.startDate)
						this.viewDate = new Date(this.o.startDate);
					else if (this.viewDate > this.o.endDate)
						this.viewDate = new Date(this.o.endDate);
					else
						this.viewDate = this.o.defaultViewDate;
				}

				if (fromArgs){
					// setting date by clicking
					this.setValue();
					this.element.change();
				}
				else if (this.dates.length){
					// setting date by typing
					if (String(oldDates) !== String(this.dates) && fromArgs) {
						this._trigger('changeDate');
						this.element.change();
					}
				}
				if (!this.dates.length && oldDates.length) {
					this._trigger('clearDate');
					this.element.change();
				}

				this.fill();
				return this;
			},

			fillDow: function(){
	      if (this.o.showWeekDays) {
				var dowCnt = this.o.weekStart,
					html = '<tr>';
				if (this.o.calendarWeeks){
					html += '<th class="cw">&#160;</th>';
				}
				while (dowCnt < this.o.weekStart + 7){
					html += '<th class="dow';
	        if ($.inArray(dowCnt, this.o.daysOfWeekDisabled) !== -1)
	          html += ' disabled';
	        html += '">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
				}
				html += '</tr>';
				this.picker.find('.datepicker-days thead').append(html);
	      }
			},

			fillMonths: function(){
	      var localDate = this._utc_to_local(this.viewDate);
				var html = '';
				var focused;
				for (var i = 0; i < 12; i++){
					focused = localDate && localDate.getMonth() === i ? ' focused' : '';
					html += '<span class="month' + focused + '">' + dates[this.o.language].monthsShort[i] + '</span>';
				}
				this.picker.find('.datepicker-months td').html(html);
			},

			setRange: function(range){
				if (!range || !range.length)
					delete this.range;
				else
					this.range = $.map(range, function(d){
						return d.valueOf();
					});
				this.fill();
			},

			getClassNames: function(date){
				var cls = [],
					year = this.viewDate.getUTCFullYear(),
					month = this.viewDate.getUTCMonth(),
					today = UTCToday();
				if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
					cls.push('old');
				} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
					cls.push('new');
				}
				if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
					cls.push('focused');
				// Compare internal UTC date with UTC today, not local today
				if (this.o.todayHighlight && isUTCEquals(date, today)) {
					cls.push('today');
				}
				if (this.dates.contains(date) !== -1)
					cls.push('active');
				if (!this.dateWithinRange(date)){
					cls.push('disabled');
				}
				if (this.dateIsDisabled(date)){
					cls.push('disabled', 'disabled-date');
				}
				if ($.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1){
					cls.push('highlighted');
				}

				if (this.range){
					if (date > this.range[0] && date < this.range[this.range.length-1]){
						cls.push('range');
					}
					if ($.inArray(date.valueOf(), this.range) !== -1){
						cls.push('selected');
					}
					if (date.valueOf() === this.range[0]){
	          cls.push('range-start');
	        }
	        if (date.valueOf() === this.range[this.range.length-1]){
	          cls.push('range-end');
	        }
				}
				return cls;
			},

			_fill_yearsView: function(selector, cssClass, factor, year, startYear, endYear, beforeFn){
				var html = '';
				var step = factor / 10;
				var view = this.picker.find(selector);
				var startVal = Math.floor(year / factor) * factor;
				var endVal = startVal + step * 9;
				var focusedVal = Math.floor(this.viewDate.getFullYear() / step) * step;
				var selected = $.map(this.dates, function(d){
					return Math.floor(d.getUTCFullYear() / step) * step;
				});

				var classes, tooltip, before;
				for (var currVal = startVal - step; currVal <= endVal + step; currVal += step) {
					classes = [cssClass];
					tooltip = null;

					if (currVal === startVal - step) {
						classes.push('old');
					} else if (currVal === endVal + step) {
						classes.push('new');
					}
					if ($.inArray(currVal, selected) !== -1) {
						classes.push('active');
					}
					if (currVal < startYear || currVal > endYear) {
						classes.push('disabled');
					}
					if (currVal === focusedVal) {
					  classes.push('focused');
	        }

					if (beforeFn !== $.noop) {
						before = beforeFn(new Date(currVal, 0, 1));
						if (before === undefined$1) {
							before = {};
						} else if (typeof before === 'boolean') {
							before = {enabled: before};
						} else if (typeof before === 'string') {
							before = {classes: before};
						}
						if (before.enabled === false) {
							classes.push('disabled');
						}
						if (before.classes) {
							classes = classes.concat(before.classes.split(/\s+/));
						}
						if (before.tooltip) {
							tooltip = before.tooltip;
						}
					}

					html += '<span class="' + classes.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + currVal + '</span>';
				}

				view.find('.datepicker-switch').text(startVal + '-' + endVal);
				view.find('td').html(html);
			},

			fill: function(){
				var d = new Date(this.viewDate),
					year = d.getUTCFullYear(),
					month = d.getUTCMonth(),
					startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
					startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
					endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
					endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
					todaytxt = dates[this.o.language].today || dates['en'].today || '',
					cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
					titleFormat = dates[this.o.language].titleFormat || dates['en'].titleFormat,
					tooltip,
					before;
				if (isNaN(year) || isNaN(month))
					return;
				this.picker.find('.datepicker-days .datepicker-switch')
							.text(DPGlobal.formatDate(d, titleFormat, this.o.language));
				this.picker.find('tfoot .today')
							.text(todaytxt)
							.css('display', this.o.todayBtn === true || this.o.todayBtn === 'linked' ? 'table-cell' : 'none');
				this.picker.find('tfoot .clear')
							.text(cleartxt)
							.css('display', this.o.clearBtn === true ? 'table-cell' : 'none');
				this.picker.find('thead .datepicker-title')
							.text(this.o.title)
							.css('display', typeof this.o.title === 'string' && this.o.title !== '' ? 'table-cell' : 'none');
				this.updateNavArrows();
				this.fillMonths();
				var prevMonth = UTCDate(year, month, 0),
					day = prevMonth.getUTCDate();
				prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
				var nextMonth = new Date(prevMonth);
				if (prevMonth.getUTCFullYear() < 100){
	        nextMonth.setUTCFullYear(prevMonth.getUTCFullYear());
	      }
				nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
				nextMonth = nextMonth.valueOf();
				var html = [];
				var weekDay, clsName;
				while (prevMonth.valueOf() < nextMonth){
					weekDay = prevMonth.getUTCDay();
					if (weekDay === this.o.weekStart){
						html.push('<tr>');
						if (this.o.calendarWeeks){
							// ISO 8601: First week contains first thursday.
							// ISO also states week starts on Monday, but we can be more abstract here.
							var
								// Start of current week: based on weekstart/current date
								ws = new Date(+prevMonth + (this.o.weekStart - weekDay - 7) % 7 * 864e5),
								// Thursday of this week
								th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
								// First Thursday of year, year from thursday
								yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),
								// Calendar week: ms between thursdays, div ms per day, div 7 days
								calWeek = (th - yth) / 864e5 / 7 + 1;
							html.push('<td class="cw">'+ calWeek +'</td>');
						}
					}
					clsName = this.getClassNames(prevMonth);
					clsName.push('day');

					var content = prevMonth.getUTCDate();

					if (this.o.beforeShowDay !== $.noop){
						before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
						if (before === undefined$1)
							before = {};
						else if (typeof before === 'boolean')
							before = {enabled: before};
						else if (typeof before === 'string')
							before = {classes: before};
						if (before.enabled === false)
							clsName.push('disabled');
						if (before.classes)
							clsName = clsName.concat(before.classes.split(/\s+/));
						if (before.tooltip)
							tooltip = before.tooltip;
						if (before.content)
							content = before.content;
					}

					//Check if uniqueSort exists (supported by jquery >=1.12 and >=2.2)
					//Fallback to unique function for older jquery versions
					if ($.isFunction($.uniqueSort)) {
						clsName = $.uniqueSort(clsName);
					} else {
						clsName = $.unique(clsName);
					}

					html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + ' data-date="' + prevMonth.getTime().toString() + '">' + content + '</td>');
					tooltip = null;
					if (weekDay === this.o.weekEnd){
						html.push('</tr>');
					}
					prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
				}
				this.picker.find('.datepicker-days tbody').html(html.join(''));

				var monthsTitle = dates[this.o.language].monthsTitle || dates['en'].monthsTitle || 'Months';
				var months = this.picker.find('.datepicker-months')
							.find('.datepicker-switch')
								.text(this.o.maxViewMode < 2 ? monthsTitle : year)
								.end()
							.find('tbody span').removeClass('active');

				$.each(this.dates, function(i, d){
					if (d.getUTCFullYear() === year)
						months.eq(d.getUTCMonth()).addClass('active');
				});

				if (year < startYear || year > endYear){
					months.addClass('disabled');
				}
				if (year === startYear){
					months.slice(0, startMonth).addClass('disabled');
				}
				if (year === endYear){
					months.slice(endMonth+1).addClass('disabled');
				}

				if (this.o.beforeShowMonth !== $.noop){
					var that = this;
					$.each(months, function(i, month){
	          var moDate = new Date(year, i, 1);
	          var before = that.o.beforeShowMonth(moDate);
						if (before === undefined$1)
							before = {};
						else if (typeof before === 'boolean')
							before = {enabled: before};
						else if (typeof before === 'string')
							before = {classes: before};
						if (before.enabled === false && !$(month).hasClass('disabled'))
						    $(month).addClass('disabled');
						if (before.classes)
						    $(month).addClass(before.classes);
						if (before.tooltip)
						    $(month).prop('title', before.tooltip);
					});
				}

				// Generating decade/years picker
				this._fill_yearsView(
					'.datepicker-years',
					'year',
					10,
					year,
					startYear,
					endYear,
					this.o.beforeShowYear
				);

				// Generating century/decades picker
				this._fill_yearsView(
					'.datepicker-decades',
					'decade',
					100,
					year,
					startYear,
					endYear,
					this.o.beforeShowDecade
				);

				// Generating millennium/centuries picker
				this._fill_yearsView(
					'.datepicker-centuries',
					'century',
					1000,
					year,
					startYear,
					endYear,
					this.o.beforeShowCentury
				);
			},

			updateNavArrows: function(){
				if (!this._allow_update)
					return;

				var d = new Date(this.viewDate),
					year = d.getUTCFullYear(),
					month = d.getUTCMonth(),
					startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
					startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
					endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
					endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
					prevIsDisabled,
					nextIsDisabled,
					factor = 1;
				switch (this.viewMode){
					case 4:
						factor *= 10;
						/* falls through */
					case 3:
						factor *= 10;
						/* falls through */
					case 2:
						factor *= 10;
						/* falls through */
					case 1:
						prevIsDisabled = Math.floor(year / factor) * factor < startYear;
						nextIsDisabled = Math.floor(year / factor) * factor + factor > endYear;
						break;
					case 0:
						prevIsDisabled = year <= startYear && month < startMonth;
						nextIsDisabled = year >= endYear && month > endMonth;
						break;
				}

				this.picker.find('.prev').toggleClass('disabled', prevIsDisabled);
				this.picker.find('.next').toggleClass('disabled', nextIsDisabled);
			},

			click: function(e){
				e.preventDefault();
				e.stopPropagation();

				var target, day, year, month;
				target = $(e.target);

				// Clicked on the switch
				if (target.hasClass('datepicker-switch') && this.viewMode !== this.o.maxViewMode){
					this.setViewMode(this.viewMode + 1);
				}

				// Clicked on today button
				if (target.hasClass('today') && !target.hasClass('day')){
					this.setViewMode(0);
					this._setDate(UTCToday(), this.o.todayBtn === 'linked' ? null : 'view');
				}

				// Clicked on clear button
				if (target.hasClass('clear')){
					this.clearDates();
				}

				if (!target.hasClass('disabled')){
					// Clicked on a month, year, decade, century
					if (target.hasClass('month')
							|| target.hasClass('year')
							|| target.hasClass('decade')
							|| target.hasClass('century')) {
						this.viewDate.setUTCDate(1);

						day = 1;
						if (this.viewMode === 1){
							month = target.parent().find('span').index(target);
							year = this.viewDate.getUTCFullYear();
							this.viewDate.setUTCMonth(month);
						} else {
							month = 0;
							year = Number(target.text());
							this.viewDate.setUTCFullYear(year);
						}

						this._trigger(DPGlobal.viewModes[this.viewMode - 1].e, this.viewDate);

						if (this.viewMode === this.o.minViewMode){
							this._setDate(UTCDate(year, month, day));
						} else {
							this.setViewMode(this.viewMode - 1);
							this.fill();
						}
					}
				}

				if (this.picker.is(':visible') && this._focused_from){
					this._focused_from.focus();
				}
				delete this._focused_from;
			},

			dayCellClick: function(e){
				var $target = $(e.currentTarget);
				var timestamp = $target.data('date');
				var date = new Date(timestamp);

				if (this.o.updateViewDate) {
					if (date.getUTCFullYear() !== this.viewDate.getUTCFullYear()) {
						this._trigger('changeYear', this.viewDate);
					}

					if (date.getUTCMonth() !== this.viewDate.getUTCMonth()) {
						this._trigger('changeMonth', this.viewDate);
					}
				}
				this._setDate(date);
			},

			// Clicked on prev or next
			navArrowsClick: function(e){
				var $target = $(e.currentTarget);
				var dir = $target.hasClass('prev') ? -1 : 1;
				if (this.viewMode !== 0){
					dir *= DPGlobal.viewModes[this.viewMode].navStep * 12;
				}
				this.viewDate = this.moveMonth(this.viewDate, dir);
				this._trigger(DPGlobal.viewModes[this.viewMode].e, this.viewDate);
				this.fill();
			},

			_toggle_multidate: function(date){
				var ix = this.dates.contains(date);
				if (!date){
					this.dates.clear();
				}

				if (ix !== -1){
					if (this.o.multidate === true || this.o.multidate > 1 || this.o.toggleActive){
						this.dates.remove(ix);
					}
				} else if (this.o.multidate === false) {
					this.dates.clear();
					this.dates.push(date);
				}
				else {
					this.dates.push(date);
				}

				if (typeof this.o.multidate === 'number')
					while (this.dates.length > this.o.multidate)
						this.dates.remove(0);
			},

			_setDate: function(date, which){
				if (!which || which === 'date')
					this._toggle_multidate(date && new Date(date));
				if ((!which && this.o.updateViewDate) || which === 'view')
					this.viewDate = date && new Date(date);

				this.fill();
				this.setValue();
				if (!which || which !== 'view') {
					this._trigger('changeDate');
				}
				this.inputField.trigger('change');
				if (this.o.autoclose && (!which || which === 'date')){
					this.hide();
				}
			},

			moveDay: function(date, dir){
				var newDate = new Date(date);
				newDate.setUTCDate(date.getUTCDate() + dir);

				return newDate;
			},

			moveWeek: function(date, dir){
				return this.moveDay(date, dir * 7);
			},

			moveMonth: function(date, dir){
				if (!isValidDate(date))
					return this.o.defaultViewDate;
				if (!dir)
					return date;
				var new_date = new Date(date.valueOf()),
					day = new_date.getUTCDate(),
					month = new_date.getUTCMonth(),
					mag = Math.abs(dir),
					new_month, test;
				dir = dir > 0 ? 1 : -1;
				if (mag === 1){
					test = dir === -1
						// If going back one month, make sure month is not current month
						// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
						? function(){
							return new_date.getUTCMonth() === month;
						}
						// If going forward one month, make sure month is as expected
						// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
						: function(){
							return new_date.getUTCMonth() !== new_month;
						};
					new_month = month + dir;
					new_date.setUTCMonth(new_month);
					// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
					new_month = (new_month + 12) % 12;
				}
				else {
					// For magnitudes >1, move one month at a time...
					for (var i=0; i < mag; i++)
						// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
						new_date = this.moveMonth(new_date, dir);
					// ...then reset the day, keeping it in the new month
					new_month = new_date.getUTCMonth();
					new_date.setUTCDate(day);
					test = function(){
						return new_month !== new_date.getUTCMonth();
					};
				}
				// Common date-resetting loop -- if date is beyond end of month, make it
				// end of month
				while (test()){
					new_date.setUTCDate(--day);
					new_date.setUTCMonth(new_month);
				}
				return new_date;
			},

			moveYear: function(date, dir){
				return this.moveMonth(date, dir*12);
			},

			moveAvailableDate: function(date, dir, fn){
				do {
					date = this[fn](date, dir);

					if (!this.dateWithinRange(date))
						return false;

					fn = 'moveDay';
				}
				while (this.dateIsDisabled(date));

				return date;
			},

			weekOfDateIsDisabled: function(date){
				return $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1;
			},

			dateIsDisabled: function(date){
				return (
					this.weekOfDateIsDisabled(date) ||
					$.grep(this.o.datesDisabled, function(d){
						return isUTCEquals(date, d);
					}).length > 0
				);
			},

			dateWithinRange: function(date){
				return date >= this.o.startDate && date <= this.o.endDate;
			},

			keydown: function(e){
				if (!this.picker.is(':visible')){
					if (e.keyCode === 40 || e.keyCode === 27) { // allow down to re-show picker
						this.show();
						e.stopPropagation();
	        }
					return;
				}
				var dateChanged = false,
					dir, newViewDate,
					focusDate = this.focusDate || this.viewDate;
				switch (e.keyCode){
					case 27: // escape
						if (this.focusDate){
							this.focusDate = null;
							this.viewDate = this.dates.get(-1) || this.viewDate;
							this.fill();
						}
						else
							this.hide();
						e.preventDefault();
						e.stopPropagation();
						break;
					case 37: // left
					case 38: // up
					case 39: // right
					case 40: // down
						if (!this.o.keyboardNavigation || this.o.daysOfWeekDisabled.length === 7)
							break;
						dir = e.keyCode === 37 || e.keyCode === 38 ? -1 : 1;
	          if (this.viewMode === 0) {
	  					if (e.ctrlKey){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');

	  						if (newViewDate)
	  							this._trigger('changeYear', this.viewDate);
	  					} else if (e.shiftKey){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');

	  						if (newViewDate)
	  							this._trigger('changeMonth', this.viewDate);
	  					} else if (e.keyCode === 37 || e.keyCode === 39){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveDay');
	  					} else if (!this.weekOfDateIsDisabled(focusDate)){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveWeek');
	  					}
	          } else if (this.viewMode === 1) {
	            if (e.keyCode === 38 || e.keyCode === 40) {
	              dir = dir * 4;
	            }
	            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');
	          } else if (this.viewMode === 2) {
	            if (e.keyCode === 38 || e.keyCode === 40) {
	              dir = dir * 4;
	            }
	            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');
	          }
						if (newViewDate){
							this.focusDate = this.viewDate = newViewDate;
							this.setValue();
							this.fill();
							e.preventDefault();
						}
						break;
					case 13: // enter
						if (!this.o.forceParse)
							break;
						focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
						if (this.o.keyboardNavigation) {
							this._toggle_multidate(focusDate);
							dateChanged = true;
						}
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.setValue();
						this.fill();
						if (this.picker.is(':visible')){
							e.preventDefault();
							e.stopPropagation();
							if (this.o.autoclose)
								this.hide();
						}
						break;
					case 9: // tab
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
						this.hide();
						break;
				}
				if (dateChanged){
					if (this.dates.length)
						this._trigger('changeDate');
					else
						this._trigger('clearDate');
					this.inputField.trigger('change');
				}
			},

			setViewMode: function(viewMode){
				this.viewMode = viewMode;
				this.picker
					.children('div')
					.hide()
					.filter('.datepicker-' + DPGlobal.viewModes[this.viewMode].clsName)
						.show();
				this.updateNavArrows();
	      this._trigger('changeViewMode', new Date(this.viewDate));
			}
		};

		var DateRangePicker = function(element, options){
			$.data(element, 'datepicker', this);
			this.element = $(element);
			this.inputs = $.map(options.inputs, function(i){
				return i.jquery ? i[0] : i;
			});
			delete options.inputs;

			this.keepEmptyValues = options.keepEmptyValues;
			delete options.keepEmptyValues;

			datepickerPlugin.call($(this.inputs), options)
				.on('changeDate', $.proxy(this.dateUpdated, this));

			this.pickers = $.map(this.inputs, function(i){
				return $.data(i, 'datepicker');
			});
			this.updateDates();
		};
		DateRangePicker.prototype = {
			updateDates: function(){
				this.dates = $.map(this.pickers, function(i){
					return i.getUTCDate();
				});
				this.updateRanges();
			},
			updateRanges: function(){
				var range = $.map(this.dates, function(d){
					return d.valueOf();
				});
				$.each(this.pickers, function(i, p){
					p.setRange(range);
				});
			},
			clearDates: function(){
				$.each(this.pickers, function(i, p){
					p.clearDates();
				});
			},
			dateUpdated: function(e){
				// `this.updating` is a workaround for preventing infinite recursion
				// between `changeDate` triggering and `setUTCDate` calling.  Until
				// there is a better mechanism.
				if (this.updating)
					return;
				this.updating = true;

				var dp = $.data(e.target, 'datepicker');

				if (dp === undefined$1) {
					return;
				}

				var new_date = dp.getUTCDate(),
					keep_empty_values = this.keepEmptyValues,
					i = $.inArray(e.target, this.inputs),
					j = i - 1,
					k = i + 1,
					l = this.inputs.length;
				if (i === -1)
					return;

				$.each(this.pickers, function(i, p){
					if (!p.getUTCDate() && (p === dp || !keep_empty_values))
						p.setUTCDate(new_date);
				});

				if (new_date < this.dates[j]){
					// Date being moved earlier/left
					while (j >= 0 && new_date < this.dates[j]){
						this.pickers[j--].setUTCDate(new_date);
					}
				} else if (new_date > this.dates[k]){
					// Date being moved later/right
					while (k < l && new_date > this.dates[k]){
						this.pickers[k++].setUTCDate(new_date);
					}
				}
				this.updateDates();

				delete this.updating;
			},
			destroy: function(){
				$.map(this.pickers, function(p){ p.destroy(); });
				$(this.inputs).off('changeDate', this.dateUpdated);
				delete this.element.data().datepicker;
			},
			remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead')
		};

		function opts_from_el(el, prefix){
			// Derive options from element data-attrs
			var data = $(el).data(),
				out = {}, inkey,
				replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
			prefix = new RegExp('^' + prefix.toLowerCase());
			function re_lower(_,a){
				return a.toLowerCase();
			}
			for (var key in data)
				if (prefix.test(key)){
					inkey = key.replace(replace, re_lower);
					out[inkey] = data[key];
				}
			return out;
		}

		function opts_from_locale(lang){
			// Derive options from locale plugins
			var out = {};
			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			if (!dates[lang]){
				lang = lang.split('-')[0];
				if (!dates[lang])
					return;
			}
			var d = dates[lang];
			$.each(locale_opts, function(i,k){
				if (k in d)
					out[k] = d[k];
			});
			return out;
		}

		var old = $.fn.datepicker;
		var datepickerPlugin = function(option){
			var args = Array.apply(null, arguments);
			args.shift();
			var internal_return;
			this.each(function(){
				var $this = $(this),
					data = $this.data('datepicker'),
					options = typeof option === 'object' && option;
				if (!data){
					var elopts = opts_from_el(this, 'date'),
						// Preliminary otions
						xopts = $.extend({}, defaults, elopts, options),
						locopts = opts_from_locale(xopts.language),
						// Options priority: js args, data-attrs, locales, defaults
						opts = $.extend({}, defaults, locopts, elopts, options);
					if ($this.hasClass('input-daterange') || opts.inputs){
						$.extend(opts, {
							inputs: opts.inputs || $this.find('input').toArray()
						});
						data = new DateRangePicker(this, opts);
					}
					else {
						data = new Datepicker(this, opts);
					}
					$this.data('datepicker', data);
				}
				if (typeof option === 'string' && typeof data[option] === 'function'){
					internal_return = data[option].apply(data, args);
				}
			});

			if (
				internal_return === undefined$1 ||
				internal_return instanceof Datepicker ||
				internal_return instanceof DateRangePicker
			)
				return this;

			if (this.length > 1)
				throw new Error('Using only allowed for the collection of a single element (' + option + ' function)');
			else
				return internal_return;
		};
		$.fn.datepicker = datepickerPlugin;

		var defaults = $.fn.datepicker.defaults = {
			assumeNearbyYear: false,
			autoclose: false,
			beforeShowDay: $.noop,
			beforeShowMonth: $.noop,
			beforeShowYear: $.noop,
			beforeShowDecade: $.noop,
			beforeShowCentury: $.noop,
			calendarWeeks: false,
			clearBtn: false,
			toggleActive: false,
			daysOfWeekDisabled: [],
			daysOfWeekHighlighted: [],
			datesDisabled: [],
			endDate: Infinity,
			forceParse: true,
			format: 'mm/dd/yyyy',
			keepEmptyValues: false,
			keyboardNavigation: true,
			language: 'en',
			minViewMode: 0,
			maxViewMode: 4,
			multidate: false,
			multidateSeparator: ',',
			orientation: "auto",
			rtl: false,
			startDate: -Infinity,
			startView: 0,
			todayBtn: false,
			todayHighlight: false,
			updateViewDate: true,
			weekStart: 0,
			disableTouchKeyboard: false,
			enableOnReadonly: true,
			showOnFocus: true,
			zIndexOffset: 10,
			container: 'body',
			immediateUpdates: false,
			title: '',
			templates: {
				leftArrow: '&#x00AB;',
				rightArrow: '&#x00BB;'
			},
	    showWeekDays: true
		};
		var locale_opts = $.fn.datepicker.locale_opts = [
			'format',
			'rtl',
			'weekStart'
		];
		$.fn.datepicker.Constructor = Datepicker;
		var dates = $.fn.datepicker.dates = {
			en: {
				days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
				daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
				daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
				months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
				monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
				today: "Today",
				clear: "Clear",
				titleFormat: "MM yyyy"
			}
		};

		var DPGlobal = {
			viewModes: [
				{
					names: ['days', 'month'],
					clsName: 'days',
					e: 'changeMonth'
				},
				{
					names: ['months', 'year'],
					clsName: 'months',
					e: 'changeYear',
					navStep: 1
				},
				{
					names: ['years', 'decade'],
					clsName: 'years',
					e: 'changeDecade',
					navStep: 10
				},
				{
					names: ['decades', 'century'],
					clsName: 'decades',
					e: 'changeCentury',
					navStep: 100
				},
				{
					names: ['centuries', 'millennium'],
					clsName: 'centuries',
					e: 'changeMillennium',
					navStep: 1000
				}
			],
			validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
			nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
			parseFormat: function(format){
				if (typeof format.toValue === 'function' && typeof format.toDisplay === 'function')
	                return format;
	            // IE treats \0 as a string end in inputs (truncating the value),
				// so it's a bad format delimiter, anyway
				var separators = format.replace(this.validParts, '\0').split('\0'),
					parts = format.match(this.validParts);
				if (!separators || !separators.length || !parts || parts.length === 0){
					throw new Error("Invalid date format.");
				}
				return {separators: separators, parts: parts};
			},
			parseDate: function(date, format, language, assumeNearby){
				if (!date)
					return undefined$1;
				if (date instanceof Date)
					return date;
				if (typeof format === 'string')
					format = DPGlobal.parseFormat(format);
				if (format.toValue)
					return format.toValue(date, format, language);
				var fn_map = {
						d: 'moveDay',
						m: 'moveMonth',
						w: 'moveWeek',
						y: 'moveYear'
					},
					dateAliases = {
						yesterday: '-1d',
						today: '+0d',
						tomorrow: '+1d'
					},
					parts, part, dir, i, fn;
				if (date in dateAliases){
					date = dateAliases[date];
				}
				if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(date)){
					parts = date.match(/([\-+]\d+)([dmwy])/gi);
					date = new Date();
					for (i=0; i < parts.length; i++){
						part = parts[i].match(/([\-+]\d+)([dmwy])/i);
						dir = Number(part[1]);
						fn = fn_map[part[2].toLowerCase()];
						date = Datepicker.prototype[fn](date, dir);
					}
					return Datepicker.prototype._zero_utc_time(date);
				}

				parts = date && date.match(this.nonpunctuation) || [];

				function applyNearbyYear(year, threshold){
					if (threshold === true)
						threshold = 10;

					// if year is 2 digits or less, than the user most likely is trying to get a recent century
					if (year < 100){
						year += 2000;
						// if the new year is more than threshold years in advance, use last century
						if (year > ((new Date()).getFullYear()+threshold)){
							year -= 100;
						}
					}

					return year;
				}

				var parsed = {},
					setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
					setters_map = {
						yyyy: function(d,v){
							return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
						},
						m: function(d,v){
							if (isNaN(d))
								return d;
							v -= 1;
							while (v < 0) v += 12;
							v %= 12;
							d.setUTCMonth(v);
							while (d.getUTCMonth() !== v)
								d.setUTCDate(d.getUTCDate()-1);
							return d;
						},
						d: function(d,v){
							return d.setUTCDate(v);
						}
					},
					val, filtered;
				setters_map['yy'] = setters_map['yyyy'];
				setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
				setters_map['dd'] = setters_map['d'];
				date = UTCToday();
				var fparts = format.parts.slice();
				// Remove noop parts
				if (parts.length !== fparts.length){
					fparts = $(fparts).filter(function(i,p){
						return $.inArray(p, setters_order) !== -1;
					}).toArray();
				}
				// Process remainder
				function match_part(){
					var m = this.slice(0, parts[i].length),
						p = parts[i].slice(0, m.length);
					return m.toLowerCase() === p.toLowerCase();
				}
				if (parts.length === fparts.length){
					var cnt;
					for (i=0, cnt = fparts.length; i < cnt; i++){
						val = parseInt(parts[i], 10);
						part = fparts[i];
						if (isNaN(val)){
							switch (part){
								case 'MM':
									filtered = $(dates[language].months).filter(match_part);
									val = $.inArray(filtered[0], dates[language].months) + 1;
									break;
								case 'M':
									filtered = $(dates[language].monthsShort).filter(match_part);
									val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
									break;
							}
						}
						parsed[part] = val;
					}
					var _date, s;
					for (i=0; i < setters_order.length; i++){
						s = setters_order[i];
						if (s in parsed && !isNaN(parsed[s])){
							_date = new Date(date);
							setters_map[s](_date, parsed[s]);
							if (!isNaN(_date))
								date = _date;
						}
					}
				}
				return date;
			},
			formatDate: function(date, format, language){
				if (!date)
					return '';
				if (typeof format === 'string')
					format = DPGlobal.parseFormat(format);
				if (format.toDisplay)
	                return format.toDisplay(date, format, language);
	            var val = {
					d: date.getUTCDate(),
					D: dates[language].daysShort[date.getUTCDay()],
					DD: dates[language].days[date.getUTCDay()],
					m: date.getUTCMonth() + 1,
					M: dates[language].monthsShort[date.getUTCMonth()],
					MM: dates[language].months[date.getUTCMonth()],
					yy: date.getUTCFullYear().toString().substring(2),
					yyyy: date.getUTCFullYear()
				};
				val.dd = (val.d < 10 ? '0' : '') + val.d;
				val.mm = (val.m < 10 ? '0' : '') + val.m;
				date = [];
				var seps = $.extend([], format.separators);
				for (var i=0, cnt = format.parts.length; i <= cnt; i++){
					if (seps.length)
						date.push(seps.shift());
					date.push(val[format.parts[i]]);
				}
				return date.join('');
			},
			headTemplate: '<thead>'+
				              '<tr>'+
				                '<th colspan="7" class="datepicker-title"></th>'+
				              '</tr>'+
								'<tr>'+
									'<th class="prev">'+defaults.templates.leftArrow+'</th>'+
									'<th colspan="5" class="datepicker-switch"></th>'+
									'<th class="next">'+defaults.templates.rightArrow+'</th>'+
								'</tr>'+
							'</thead>',
			contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
			footTemplate: '<tfoot>'+
								'<tr>'+
									'<th colspan="7" class="today"></th>'+
								'</tr>'+
								'<tr>'+
									'<th colspan="7" class="clear"></th>'+
								'</tr>'+
							'</tfoot>'
		};
		DPGlobal.template = '<div class="datepicker">'+
								'<div class="datepicker-days">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										'<tbody></tbody>'+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-months">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-years">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-decades">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-centuries">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
							'</div>';

		$.fn.datepicker.DPGlobal = DPGlobal;


		/* DATEPICKER NO CONFLICT
		* =================== */

		$.fn.datepicker.noConflict = function(){
			$.fn.datepicker = old;
			return this;
		};

		/* DATEPICKER VERSION
		 * =================== */
		$.fn.datepicker.version = '1.8.0';

		$.fn.datepicker.deprecated = function(msg){
			var console = window.console;
			if (console && console.warn) {
				console.warn('DEPRECATED: ' + msg);
			}
		};


		/* DATEPICKER DATA-API
		* ================== */

		$(document).on(
			'focus.datepicker.data-api click.datepicker.data-api',
			'[data-provide="datepicker"]',
			function(e){
				var $this = $(this);
				if ($this.data('datepicker'))
					return;
				e.preventDefault();
				// component click requires us to explicitly show it
				datepickerPlugin.call($this, 'show');
			}
		);
		$(function(){
			datepickerPlugin.call($('[data-provide="datepicker-inline"]'));
		});

	}));
	});

	/**
	 * Extends eternicode's bootstrap-datepicker without changing the original.
	 * https://github.com/eternicode/bootstrap-datepicker
	 */
	class DatepickerExtended extends Widget {

	    static get selector() {
	        return '.question input[type="date"]:not([readonly])';
	    }

	    static condition() {
	        const badSamsung = /GT-P31[0-9]{2}.+AppleWebKit\/534\.30/;

	        /*
	         * Samsung mobile browser (called "Internet") has a weird bug that appears sometimes (?) when an input field
	         * already has a value and is edited. The new value YYYY-MM-DD prepends old or replaces the year of the old value and first hyphen. E.g.
	         * existing: 2010-01-01, new value entered: 2012-12-12 => input field shows: 2012-12-1201-01.
	         * This doesn't seem to effect the actual value of the input, just the way it is displayed. But if the incorrectly displayed date is then
	         * attempted to be edited again, it does get the incorrect value and it's impossible to clear this and create a valid date.
	         *
	         * browser: "Mozilla/5.0 (Linux; U; Android 4.1.1; en-us; GT-P3113 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30";
	         * webview: "Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; GT-P3100 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30"
	         */

	        return !support.touch || !support.inputTypes.date || badSamsung.test( navigator.userAgent );
	    }

	    _init() {
	        this.settings = ( this.props.appearances.includes( 'year' ) ) ? {
	            format: 'yyyy',
	            startView: 'decade',
	            minViewMode: 'years'
	        } : ( this.props.appearances.includes( 'month-year' ) ) ? {
	            format: 'yyyy-mm',
	            startView: 'year',
	            minViewMode: 'months'
	        } : {
	            format: 'yyyy-mm-dd',
	            startView: 'month',
	            minViewMode: 'days'
	        };

	        this.$fakeDateI = this._createFakeDateInput( this.settings.format );

	        this._setChangeHandler( this.$fakeDateI );
	        this._setFocusHandler( this.$fakeDateI );
	        this._setResetHandler( this.$fakeDateI );

	        this.$fakeDateI.datepicker( {
	            format: this.settings.format,
	            autoclose: true,
	            todayHighlight: true,
	            startView: this.settings.startView,
	            minViewMode: this.settings.minViewMode,
	            forceParse: false
	        } );

	        this.value = this.element.value;
	    }

	    /**
	     * Creates fake date input elements
	     * @param  {string} format the date format
	     * @return {jQuery}        the jQuery-wrapped fake date input element
	     */
	    _createFakeDateInput( format ) {
	        const $dateI = jquery( this.element );
	        const $fakeDate = jquery( `<div class="widget date"><input class="ignore input-small" type="text" placeholder="${format}" /></div>` )
	            .append( this.resetButtonHtml );
	        const $fakeDateI = $fakeDate.find( 'input' );

	        $dateI.hide().after( $fakeDate );

	        return $fakeDateI;
	    }

	    /**
	     * Copy manual changes that were not detected by bootstrap-datepicker (one without pressing Enter) to original date input field
	     *
	     * @param { jQuery } $fakeDateI Fake date input element
	     */
	    _setChangeHandler( $fakeDateI ) {
	        const settings = this.settings;

	        $fakeDateI.on( 'change paste', e => {
	            let convertedValue = '';
	            let value = e.type === 'paste' ? getPasteData( e ) : this.value;

	            if ( value.length > 0 ) {
	                // Note: types.date.convert considers numbers to be a number of days since the epoch 
	                // as this is what the XPath evaluator may return.
	                // For user-entered input, we want to consider a Number value to be incorrect, expect for year input.
	                if ( isNumber( value ) && settings.format !== 'yyyy' ) {
	                    convertedValue = '';
	                } else {
	                    value = this._toActualDate( value );
	                    convertedValue = types.date.convert( value );
	                }
	            }

	            // Here we have to do something unusual to prevent native inputs from automatically 
	            // changing 2012-12-32 into 2013-01-01
	            // convertedValue is '' for invalid 2012-12-32
	            if ( convertedValue === '' || this.originalInputValue !== convertedValue ) {
	                if ( e.type === 'paste' ) {
	                    e.stopImmediatePropagation();
	                }
	                this.originalInputValue = convertedValue;
	                this.element.blur();
	            }

	            $fakeDateI.val( this._toDisplayDate( convertedValue ) ).datepicker( 'update' );

	            return false;
	        } );
	    }

	    /**
	     * Reset button handler
	     *
	     * @param { jQuery } $fakeDateI Fake date input element
	     */
	    _setResetHandler( $fakeDateI ) {
	        $fakeDateI.next( '.btn-reset' ).on( 'click', () => {
	            if ( this.originalInputValue ) {
	                this.value = '';
	            }
	        } );
	    }

	    /**
	     * Handler for focus events.
	     * These events on the original input are used to check whether to display the 'required' message
	     *
	     * @param { jQuery } $fakeDateI Fake date input element
	     */
	    _setFocusHandler( $fakeDateI ) {
	        // Handle focus on original input (goTo functionality)
	        jquery( this.element ).on( 'applyfocus', () => {
	            $fakeDateI[ 0 ].focus();
	        } );
	    }

	    _toActualDate( date = '' ) {
	        date = date.trim();
	        return date && this.settings.format === 'yyyy' && date.length < 5 ? `${date}-01-01` : ( date && this.settings.format === 'yyyy-mm' && date.length < 8 ? `${date}-01` : date );
	    }

	    _toDisplayDate( date = '' ) {
	        date = date.trim();
	        return date && this.settings.format === 'yyyy' ? date.substring( 0, 4 ) : ( this.settings.format === 'yyyy-mm' ? date.substring( 0, 7 ) : date );
	    }

	    update() {
	        this.value = this.element.value;
	    }

	    get displayedValue() {
	        return this.question.querySelector( '.widget input' ).value;
	    }

	    get value() {
	        return this._toActualDate( this.displayedValue );
	    }

	    set value( date ) {
	        this.$fakeDateI.datepicker( 'setDate', this._toDisplayDate( date ) );
	    }

	}

	/**
	 * The whole purpose of this widget is to hide the placeholder text on native date inputs
	 * and show a consistent date format between readonly and non-readonly questions. This widget
	 * is only activated for READONLY questions on NON-MOBILE devices.
	 * 
	 * The placeholder is considered particularly unhelpful for month-year and year appearances. 
	 * For consistency it's also removed from regular date inputs.
	 * 
	 */

	class DatepickerNative extends Widget {
	    static get selector() {
	        return '.question input[type="date"]';
	    }
	    static condition( element ) {
	        // Do not instantiate if DatepickerExtended was instantiated on element or if mobile device is used.
	        return !elementDataStore.has( element, 'DatepickerExtended' ) && !support.touch;
	    }
	    _init() {
	        this.element.type = 'text';
	        this.element.classList.add( 'mask-date' );
	    }
	}

	/**
	 * For now, the whole purpose of this widget is to show a native month picker on 
	 * MOBILE devices with browsers that support it.
	 */
	class DatepickerMobile extends Widget {

	    static get selector() {
	        return '.or-appearance-month-year input[type="date"]';
	    }

	    static condition( element ) {
	        // Do not instantiate if DatepickerExtended was instantiated on element or if non-mobile device is used.
	        return !elementDataStore.has( element, 'DatepickerExtended' ) && support.touch;
	    }

	    _init() {
	        if ( support.inputTypes.month ) {
	            this.element.classList.add( 'hide' );
	            const fragment = document.createRange().createContextualFragment( '<input class="ignore widget datepicker-mobile" type="month"/>' );
	            this.element.after( fragment );
	            this.widgetInput = this.question.querySelector( 'input.widget' );
	            // set default value
	            this.value = this.originalInputValue;

	            this.widgetInput.addEventListener( 'change', () => {
	                this.originalInputValue = this.value;
	            } );
	        }
	    }

	    get value() {
	        return this.widgetInput.value ? `${this.widgetInput.value}-01` : '';
	    }

	    set value( value ) {
	        const toSet = value ? value.substring( 0, value.lastIndexOf( '-' ) ) : '';
	        this.widgetInput.value = toSet;
	    }

	    update() {
	        this.value = this.originalInputValue;
	    }
	}

	/*!
	 * Timepicker
	 *
	 * Forked from https://github.com/jdewit/bootstrap-timepicker: 
	 * 
	 * Copyright 2013 Joris de Wit and timepicker contributors
	 *
	 * Contributors https://github.com/jdewit/bootstrap-timepicker/graphs/contributors
	 * Contributors https://github.com/enketo/timepicker-basic/graphs/contributors
	 *
	 * For the full copyright and license information, please view the LICENSE
	 * file that was distributed with this source code.
	 */
	( ( ( $, window, document ) => {
	    // TIMEPICKER PUBLIC CLASS DEFINITION
	    const Timepicker = function( element, options ) {
	        this.widget = '';
	        this.$element = $( element );
	        this.defaultTime = options.defaultTime;
	        this.disableFocus = options.disableFocus;
	        this.disableMousewheel = options.disableMousewheel;
	        this.isOpen = options.isOpen;
	        this.minuteStep = options.minuteStep;
	        this.orientation = options.orientation;
	        this.secondStep = options.secondStep;
	        this.snapToStep = options.snapToStep;
	        this.showInputs = options.showInputs;
	        this.showMeridian = options.showMeridian;
	        this.meridianNotation = options.meridianNotation;
	        this.showSeconds = options.showSeconds;
	        this.template = options.template;
	        this.appendWidgetTo = options.appendWidgetTo;
	        this.showWidgetOnAddonClick = options.showWidgetOnAddonClick;
	        this.icons = options.icons;
	        this.maxHours = options.maxHours;
	        this.explicitMode = options.explicitMode; // If true 123 = 1:23, 12345 = 1:23:45, else invalid.

	        this.handleDocumentClick = e => {
	            const self = e.data.scope;
	            // This condition was inspired by datepicker.
	            // The element the timepicker is invoked on is the input but it has a sibling for addon/button.
	            if ( !( self.$element.parent().find( e.target ).length ||
	                    self.$widget.is( e.target ) ||
	                    self.$widget.find( e.target ).length ) ) {
	                self.hideWidget();
	            }
	        };

	        this._init();
	    };

	    Timepicker.prototype = {

	        constructor: Timepicker,
	        _init() {
	            const self = this;

	            if ( this.showWidgetOnAddonClick && ( this.$element.parent().hasClass( 'input-group' ) && this.$element.parent().hasClass( 'timepicker' ) ) ) {
	                this.$element.parent( '.input-group.timepicker' ).find( '.input-group-addon' ).on( {
	                    'click.timepicker': $.proxy( this.showWidget, this )
	                } );
	                this.$element.on( {
	                    'focus.timepicker': $.proxy( this.highlightUnit, this ),
	                    'click.timepicker': $.proxy( this.highlightUnit, this ),
	                    'keydown.timepicker': $.proxy( this.elementKeydown, this ),
	                    'blur.timepicker': $.proxy( this.blurElement, this ),
	                    'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy( this.mousewheel, this )
	                } );
	            } else {
	                if ( this.template ) {
	                    this.$element.on( {
	                        'focus.timepicker': $.proxy( this.showWidget, this ),
	                        'click.timepicker': $.proxy( this.showWidget, this ),
	                        'blur.timepicker': $.proxy( this.blurElement, this ),
	                        'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy( this.mousewheel, this )
	                    } );
	                } else {
	                    this.$element.on( {
	                        'focus.timepicker': $.proxy( this.highlightUnit, this ),
	                        'click.timepicker': $.proxy( this.highlightUnit, this ),
	                        'keydown.timepicker': $.proxy( this.elementKeydown, this ),
	                        'blur.timepicker': $.proxy( this.blurElement, this ),
	                        'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy( this.mousewheel, this )
	                    } );
	                }
	            }

	            if ( this.template !== false ) {
	                this.$widget = $( this.getTemplate() ).on( 'click', $.proxy( this.widgetClick, this ) );
	            } else {
	                this.$widget = false;
	            }

	            if ( this.showInputs && this.$widget !== false ) {
	                this.$widget.find( 'input' ).each( function() {
	                    $( this ).on( {
	                        'click.timepicker': function() {
	                            $( this ).select();
	                        },
	                        'keydown.timepicker': $.proxy( self.widgetKeydown, self ),
	                        'keyup.timepicker': $.proxy( self.widgetKeyup, self )
	                    } );
	                } );
	            }

	            this.setDefaultTime( this.defaultTime );
	        },

	        blurElement() {
	            this.highlightedUnit = null;
	            this.updateFromElementVal();
	        },

	        clear() {
	            this.hour = '';
	            this.minute = '';
	            this.second = '';
	            this.meridian = '';

	            this.$element.val( '' );
	        },

	        decrementHour() {
	            // If value is empty, make sure that first shown value is current hour.
	            if ( this.hour === '' ) {
	                this.hour = this.getCurrentHour();
	                this.incrementHour();
	            }

	            if ( this.showMeridian ) {
	                if ( this.hour === 1 ) {
	                    this.hour = 12;
	                } else if ( this.hour === 12 ) {
	                    this.hour--;

	                    return this.toggleMeridian();
	                } else if ( this.hour === 0 ) {
	                    this.hour = 11;

	                    return this.toggleMeridian();
	                } else {
	                    this.hour--;
	                }
	            } else {
	                if ( this.hour <= 0 ) {
	                    this.hour = this.maxHours - 1;
	                } else {
	                    this.hour--;
	                }
	            }
	        },

	        decrementMinute( step ) {
	            let newVal;

	            // If value is empty, make sure that first shown value is current minutes.
	            if ( this.minute === '' ) {
	                this.minute = this.getCurrentMinute();
	                this.incrementMinute();
	            }

	            if ( step ) {
	                newVal = this.minute - step;
	            } else {
	                newVal = this.minute - this.minuteStep;
	            }

	            if ( newVal < 0 ) {
	                this.decrementHour();
	                this.minute = newVal + 60;
	            } else {
	                this.minute = newVal;
	            }
	        },

	        decrementSecond() {
	            const newVal = this.second - this.secondStep;

	            if ( newVal < 0 ) {
	                this.decrementMinute( true );
	                this.second = newVal + 60;
	            } else {
	                this.second = newVal;
	            }
	        },

	        elementKeydown( e ) {
	            switch ( e.which ) {
	                case 9: //tab
	                    if ( e.shiftKey ) {
	                        if ( this.highlightedUnit === 'hour' ) {
	                            this.hideWidget();
	                            break;
	                        }
	                        this.highlightPrevUnit();
	                    } else if ( ( this.showMeridian && this.highlightedUnit === 'meridian' ) || ( this.showSeconds && this.highlightedUnit === 'second' ) || ( !this.showMeridian && !this.showSeconds && this.highlightedUnit === 'minute' ) ) {
	                        this.hideWidget();
	                        break;
	                    } else {
	                        this.highlightNextUnit();
	                    }
	                    e.preventDefault();
	                    this.updateFromElementVal();
	                    break;
	                case 27: // escape
	                    this.updateFromElementVal();
	                    break;
	                case 37: // left arrow
	                    e.preventDefault();
	                    this.highlightPrevUnit();
	                    this.updateFromElementVal();
	                    break;
	                case 38: // up arrow
	                    e.preventDefault();
	                    switch ( this.highlightedUnit ) {
	                        case 'hour':
	                            this.incrementHour();
	                            this.highlightHour();
	                            break;
	                        case 'minute':
	                            this.incrementMinute();
	                            this.highlightMinute();
	                            break;
	                        case 'second':
	                            this.incrementSecond();
	                            this.highlightSecond();
	                            break;
	                        case 'meridian':
	                            this.toggleMeridian();
	                            this.highlightMeridian();
	                            break;
	                    }
	                    this.update();
	                    break;
	                case 39: // right arrow
	                    e.preventDefault();
	                    this.highlightNextUnit();
	                    this.updateFromElementVal();
	                    break;
	                case 40: // down arrow
	                    e.preventDefault();
	                    switch ( this.highlightedUnit ) {
	                        case 'hour':
	                            this.decrementHour();
	                            this.highlightHour();
	                            break;
	                        case 'minute':
	                            this.decrementMinute();
	                            this.highlightMinute();
	                            break;
	                        case 'second':
	                            this.decrementSecond();
	                            this.highlightSecond();
	                            break;
	                        case 'meridian':
	                            this.toggleMeridian();
	                            this.highlightMeridian();
	                            break;
	                    }

	                    this.update();
	                    break;
	            }
	        },

	        getCursorPosition() {
	            const input = this.$element.get( 0 );

	            if ( 'selectionStart' in input ) { // Standard-compliant browsers

	                return input.selectionStart;
	            } else if ( document.selection ) { // IE fix
	                input.focus();
	                const sel = document.selection.createRange(),
	                    selLen = document.selection.createRange().text.length;

	                sel.moveStart( 'character', -input.value.length );

	                return sel.text.length - selLen;
	            }
	        },

	        getMeridianLength() {
	            const el = document.createElement( 'span' );
	            el.textContent = this.meridianNotation.am;
	            el.style.position = 'absolute';
	            document.querySelector( 'body' ).appendChild( el );
	            const amLength = el.scrollWidth;
	            el.textContent = this.meridianNotation.pm;
	            const pmLength = el.scrollWidth;
	            el.remove();
	            return amLength > pmLength ? amLength : pmLength;
	        },

	        getTemplate() {
	            let template, hourTemplate, minuteTemplate, secondTemplate, meridianTemplate, templateContent;

	            if ( this.showInputs ) {
	                const width = this.getMeridianLength() > 26 ? `style="width: ${this.getMeridianLength() + 24}px"` : '';
	                hourTemplate = `<input type="text" class="timepicker-hour" ${width}/>`;
	                minuteTemplate = `<input type="text" class="timepicker-minute" ${width}/>`;
	                secondTemplate = `<input type="text" class="timepicker-second" ${width}/>`;
	                meridianTemplate = `<input type="text" class="timepicker-meridian"${width}/>`;
	            } else {
	                hourTemplate = '<span class="timepicker-hour"></span>';
	                minuteTemplate = '<span class="timepicker-minute"></span>';
	                secondTemplate = '<span class="timepicker-second"></span>';
	                meridianTemplate = '<span class="timepicker-meridian"></span>';
	            }

	            templateContent = `<table><tr><td><a href="#" data-action="incrementHour"><span class="${this.icons.up}"></span></a></td><td class="separator">&nbsp;</td><td><a href="#" data-action="incrementMinute"><span class="${this.icons.up}"></span></a></td>${this.showSeconds ?
        `<td class="separator">&nbsp;</td><td><a href="#" data-action="incrementSecond"><span class="${this.icons.up}"></span></a></td>` : ''}${this.showMeridian ?
        `<td class="separator">&nbsp;</td><td class="meridian-column"><a href="#" data-action="toggleMeridian"><span class="${this.icons.up}"></span></a></td>` : ''}</tr><tr><td>${hourTemplate}</td> <td class="separator">:</td><td>${minuteTemplate}</td> ${this.showSeconds ?
        `<td class="separator">:</td><td>${secondTemplate}</td>` : ''}${this.showMeridian ?
        `<td class="separator">&nbsp;</td><td>${meridianTemplate}</td>` : ''}</tr><tr><td><a href="#" data-action="decrementHour"><span class="${this.icons.down}"></span></a></td><td class="separator"></td><td><a href="#" data-action="decrementMinute"><span class="${this.icons.down}"></span></a></td>${this.showSeconds ?
        `<td class="separator">&nbsp;</td><td><a href="#" data-action="decrementSecond"><span class="${this.icons.down}"></span></a></td>` : ''}${this.showMeridian ?
        `<td class="separator">&nbsp;</td><td><a href="#" data-action="toggleMeridian"><span class="${this.icons.down}"></span></a></td>` : ''}</tr></table>`;

	            switch ( this.template ) {
	                case 'dropdown':
	                    template = `<div class="timepicker-widget dropdown-menu">${templateContent}</div>`;
	                    break;
	            }

	            return template;
	        },

	        getTime() {
	            if ( this.hour === '' ) {
	                return '';
	            }
	            //return this.hour +                                                           ':' + ( this.minute.toString().length === 1 ? '0' + this.minute : this.minute ) + ( this.showSeconds ? ':' + ( this.second.toString().length === 1 ? '0' + this.second : this.second ) : '' ) + ( this.showMeridian ? ' ' + this.meridian : '' );
	            return `${this.hour.toString().length === 1 ? `0${this.hour}` : this.hour}:${this.minute.toString().length === 1 ? `0${this.minute}` : this.minute}${this.showSeconds ? `:${this.second.toString().length === 1 ? `0${this.second}` : this.second}` : ''}${this.showMeridian ? ` ${this.meridian}` : ''}`;
	        },

	        hideWidget() {
	            if ( this.isOpen === false ) {
	                return;
	            }

	            this.$element.trigger( {
	                'type': 'hide.timepicker',
	                'time': {
	                    'value': this.getTime(),
	                    'hours': this.hour,
	                    'minutes': this.minute,
	                    'seconds': this.second,
	                    'meridian': this.meridian
	                }
	            } );

	            this.$widget.removeClass( 'open' );

	            $( document ).off( 'mousedown.timepicker, touchend.timepicker', this.handleDocumentClick );

	            this.isOpen = false;
	            // show/hide approach taken by datepicker
	            this.$widget.detach();
	        },

	        highlightUnit() {
	            this.position = this.getCursorPosition();
	            if ( this.position >= 0 && this.position <= 2 ) {
	                this.highlightHour();
	            } else if ( this.position >= 3 && this.position <= 5 ) {
	                this.highlightMinute();
	            } else if ( this.position >= 6 && this.position <= 8 ) {
	                if ( this.showSeconds ) {
	                    this.highlightSecond();
	                } else {
	                    this.highlightMeridian();
	                }
	            } else if ( this.position >= 9 && this.position <= 11 ) {
	                this.highlightMeridian();
	            }
	        },

	        highlightNextUnit() {
	            switch ( this.highlightedUnit ) {
	                case 'hour':
	                    this.highlightMinute();
	                    break;
	                case 'minute':
	                    if ( this.showSeconds ) {
	                        this.highlightSecond();
	                    } else if ( this.showMeridian ) {
	                        this.highlightMeridian();
	                    } else {
	                        this.highlightHour();
	                    }
	                    break;
	                case 'second':
	                    if ( this.showMeridian ) {
	                        this.highlightMeridian();
	                    } else {
	                        this.highlightHour();
	                    }
	                    break;
	                case 'meridian':
	                    this.highlightHour();
	                    break;
	            }
	        },

	        highlightPrevUnit() {
	            switch ( this.highlightedUnit ) {
	                case 'hour':
	                    if ( this.showMeridian ) {
	                        this.highlightMeridian();
	                    } else if ( this.showSeconds ) {
	                        this.highlightSecond();
	                    } else {
	                        this.highlightMinute();
	                    }
	                    break;
	                case 'minute':
	                    this.highlightHour();
	                    break;
	                case 'second':
	                    this.highlightMinute();
	                    break;
	                case 'meridian':
	                    if ( this.showSeconds ) {
	                        this.highlightSecond();
	                    } else {
	                        this.highlightMinute();
	                    }
	                    break;
	            }
	        },

	        highlightHour() {
	            const $element = this.$element.get( 0 ),
	                self = this;

	            this.highlightedUnit = 'hour';

	            if ( $element.setSelectionRange ) {
	                setTimeout( () => {
	                    if ( self.hour < 10 ) {
	                        $element.setSelectionRange( 0, 1 );
	                    } else {
	                        $element.setSelectionRange( 0, 2 );
	                    }
	                }, 0 );
	            }
	        },

	        highlightMinute() {
	            const $element = this.$element.get( 0 ),
	                self = this;

	            this.highlightedUnit = 'minute';

	            if ( $element.setSelectionRange ) {
	                setTimeout( () => {
	                    if ( self.hour < 10 ) {
	                        $element.setSelectionRange( 2, 4 );
	                    } else {
	                        $element.setSelectionRange( 3, 5 );
	                    }
	                }, 0 );
	            }
	        },

	        highlightSecond() {
	            const $element = this.$element.get( 0 ),
	                self = this;

	            this.highlightedUnit = 'second';

	            if ( $element.setSelectionRange ) {
	                setTimeout( () => {
	                    if ( self.hour < 10 ) {
	                        $element.setSelectionRange( 5, 7 );
	                    } else {
	                        $element.setSelectionRange( 6, 8 );
	                    }
	                }, 0 );
	            }
	        },

	        highlightMeridian() {
	            const $element = this.$element.get( 0 ),
	                self = this;

	            this.highlightedUnit = 'meridian';

	            if ( $element.setSelectionRange ) {
	                if ( this.showSeconds ) {
	                    setTimeout( () => {
	                        if ( self.hour < 10 ) {
	                            $element.setSelectionRange( 8, 10 );
	                        } else {
	                            $element.setSelectionRange( 9, 11 );
	                        }
	                    }, 0 );
	                } else {
	                    setTimeout( () => {
	                        if ( self.hour < 10 ) {
	                            $element.setSelectionRange( 5, 7 );
	                        } else {
	                            $element.setSelectionRange( 6, 8 );
	                        }
	                    }, 0 );
	                }
	            }
	        },

	        getCurrentHour() {
	            const h24 = new Date().getHours();
	            return ( this.showMeridian ) ? h24 % 12 : h24;
	        },

	        getCurrentMinute() {
	            return new Date().getMinutes();
	        },

	        incrementHour() {
	            // If value is empty, make sure that first shown value is current hour.
	            if ( this.hour === '' ) {
	                this.hour = this.getCurrentHour();
	                this.decrementHour();
	            }

	            // if this.hour is empty string
	            if ( this.showMeridian ) {
	                if ( this.hour === 11 ) {
	                    this.hour++;
	                    return this.toggleMeridian();
	                } else if ( this.hour === 12 ) {
	                    this.hour = 0;
	                }
	            }
	            if ( this.hour === this.maxHours - 1 ) {
	                this.hour = 0;

	                return;
	            }
	            this.hour++;
	        },

	        incrementMinute( step ) {
	            let newVal;

	            // If value is empty, make sure that first shown value is current minutes.
	            if ( this.minute === '' ) {
	                this.minute = this.getCurrentMinute();
	                this.decrementMinute();
	            }

	            if ( step ) {
	                newVal = this.minute + step;
	            } else {
	                newVal = this.minute + this.minuteStep - ( this.minute % this.minuteStep );
	            }

	            if ( newVal > 59 ) {
	                this.incrementHour();
	                this.minute = newVal - 60;
	            } else {
	                this.minute = newVal;
	            }
	        },

	        incrementSecond() {
	            const newVal = this.second + this.secondStep - ( this.second % this.secondStep );

	            if ( newVal > 59 ) {
	                this.incrementMinute( true );
	                this.second = newVal - 60;
	            } else {
	                this.second = newVal;
	            }
	        },

	        mousewheel( e ) {
	            if ( this.disableMousewheel ) {
	                return;
	            }

	            e.preventDefault();
	            e.stopPropagation();

	            const delta = e.originalEvent.wheelDelta || -e.originalEvent.detail;
	            let scrollTo = null;

	            if ( e.type === 'mousewheel' ) {
	                scrollTo = ( e.originalEvent.wheelDelta * -1 );
	            } else if ( e.type === 'DOMMouseScroll' ) {
	                scrollTo = 40 * e.originalEvent.detail;
	            }

	            if ( scrollTo ) {
	                e.preventDefault();
	                $( this ).scrollTop( scrollTo + $( this ).scrollTop() );
	            }

	            switch ( this.highlightedUnit ) {
	                case 'minute':
	                    if ( delta > 0 ) {
	                        this.incrementMinute();
	                    } else {
	                        this.decrementMinute();
	                    }
	                    this.highlightMinute();
	                    break;
	                case 'second':
	                    if ( delta > 0 ) {
	                        this.incrementSecond();
	                    } else {
	                        this.decrementSecond();
	                    }
	                    this.highlightSecond();
	                    break;
	                case 'meridian':
	                    this.toggleMeridian();
	                    this.highlightMeridian();
	                    break;
	                default:
	                    if ( delta > 0 ) {
	                        this.incrementHour();
	                    } else {
	                        this.decrementHour();
	                    }
	                    this.highlightHour();
	                    break;
	            }

	            return false;
	        },

	        /**
	         * Given a segment value like 43, will round and snap the segment
	         * to the nearest "step", like 45 if step is 15. Segment will
	         * "overflow" to 0 if it's larger than 59 or would otherwise
	         * round up to 60.
	         */
	        changeToNearestStep( segment, step ) {
	            if ( segment % step === 0 ) {
	                return segment;
	            }
	            if ( Math.round( ( segment % step ) / step ) ) {
	                return ( segment + ( step - segment % step ) ) % 60;
	            } else {
	                return segment - segment % step;
	            }
	        },

	        // This method was adapted from datepicker.
	        place() {
	            if ( this.isInline ) {
	                return;
	            }
	            const widgetWidth = this.$widget.outerWidth(),
	                widgetHeight = this.$widget.outerHeight(),
	                visualPadding = 10,
	                windowWidth =
	                $( window ).width(),
	                windowHeight = $( window ).height(),
	                scrollTop = $( window ).scrollTop();

	            const zIndex = parseInt( this.$element.parents().filter( function() {
	                return $( this ).css( 'z-index' ) !== 'auto';
	            } ).first().css( 'z-index' ), 10 ) + 10;
	            const offset = this.component ? this.component.parent().offset() : this.$element.offset();
	            const height = this.component ? this.component.outerHeight( true ) : this.$element.outerHeight( false );
	            const width = this.component ? this.component.outerWidth( true ) : this.$element.outerWidth( false );
	            let left = offset.left,
	                top = offset.top;

	            this.$widget.removeClass( 'timepicker-orient-top timepicker-orient-bottom timepicker-orient-right timepicker-orient-left' );

	            if ( this.orientation.x !== 'auto' ) {
	                this.$widget.addClass( `timepicker-orient-${this.orientation.x}` );
	                if ( this.orientation.x === 'right' ) {
	                    left -= widgetWidth - width;
	                }
	            } else {
	                // auto x orientation is best-placement: if it crosses a window edge, fudge it sideways
	                // Default to left
	                this.$widget.addClass( 'timepicker-orient-left' );
	                if ( offset.left < 0 ) {
	                    left -= offset.left - visualPadding;
	                } else if ( offset.left + widgetWidth > windowWidth ) {
	                    left = windowWidth - widgetWidth - visualPadding;
	                }
	            }
	            // auto y orientation is best-situation: top or bottom, no fudging, decision based on which shows more of the widget
	            let yorient = this.orientation.y,
	                topOverflow, bottomOverflow;
	            if ( yorient === 'auto' ) {
	                topOverflow = -scrollTop + offset.top - widgetHeight;
	                bottomOverflow = scrollTop + windowHeight - ( offset.top + height + widgetHeight );
	                if ( Math.max( topOverflow, bottomOverflow ) === bottomOverflow ) {
	                    yorient = 'top';
	                } else {
	                    yorient = 'bottom';
	                }
	            }
	            this.$widget.addClass( `timepicker-orient-${yorient}` );
	            if ( yorient === 'top' ) {
	                top += height;
	            } else {
	                top -= widgetHeight + parseInt( this.$widget.css( 'padding-top' ), 10 );
	            }

	            this.$widget.css( {
	                top,
	                left,
	                zIndex
	            } );
	        },

	        remove() {
	            $( 'document' ).off( '.timepicker' );
	            if ( this.$widget ) {
	                this.$widget.remove();
	            }
	            delete this.$element.data().timepicker;
	        },

	        setDefaultTime( defaultTime ) {
	            if ( !this.$element.val() ) {
	                if ( defaultTime === 'current' ) {
	                    const dTime = new Date();
	                    let hours = dTime.getHours();
	                    let minutes = dTime.getMinutes();
	                    let seconds = dTime.getSeconds();
	                    let meridian = this.meridianNotation.am;

	                    if ( seconds !== 0 ) {
	                        seconds = Math.ceil( dTime.getSeconds() / this.secondStep ) * this.secondStep;
	                        if ( seconds === 60 ) {
	                            minutes += 1;
	                            seconds = 0;
	                        }
	                    }

	                    if ( minutes !== 0 ) {
	                        minutes = Math.ceil( dTime.getMinutes() / this.minuteStep ) * this.minuteStep;
	                        if ( minutes === 60 ) {
	                            hours += 1;
	                            minutes = 0;
	                        }
	                    }

	                    if ( this.showMeridian ) {
	                        if ( hours === 0 ) {
	                            hours = 12;
	                        } else if ( hours >= 12 ) {
	                            if ( hours > 12 ) {
	                                hours = hours - 12;
	                            }
	                            meridian = this.meridianNotation.pm;
	                        } else {
	                            meridian = this.meridianNotation.am;
	                        }
	                    }

	                    this.hour = hours;
	                    this.minute = minutes;
	                    this.second = seconds;
	                    this.meridian = meridian;

	                    this.update();
	                } else if ( defaultTime === false ) {
	                    this.hour = 0;
	                    this.minute = 0;
	                    this.second = 0;
	                    this.meridian = this.meridianNotation.am;
	                } else {
	                    this.setTime( defaultTime );
	                }
	            } else {
	                this.updateFromElementVal();
	            }
	        },

	        setTime( time, ignoreWidget ) {
	            if ( !time ) {
	                this.clear();
	                return;
	            }

	            let timeMode, timeArray, hour, minute, second, meridian;

	            if ( typeof time === 'object' && time.getMonth ) {
	                // this is a date object
	                hour = time.getHours();
	                minute = time.getMinutes();
	                second = time.getSeconds();

	                if ( this.showMeridian ) {
	                    meridian = this.meridianNotation.am;
	                    if ( hour > 12 ) {
	                        meridian = this.meridianNotation.pm;
	                        hour = hour % 12;
	                    }

	                    if ( hour === 12 ) {
	                        meridian = this.meridianNotation.pm;
	                    }
	                }
	            } else {
	                timeMode = ( ( /a/i ).test( time ) ? 1 : 0 ) + ( ( /p/i ).test( time ) ? 2 : 0 ); // 0 = none, 1 = AM, 2 = PM, 3 = BOTH.
	                if ( timeMode > 2 ) { // If both are present, fail.
	                    this.clear();
	                    return;
	                }

	                timeArray = time.replace( /[^0-9:]/g, '' ).split( ':' );

	                hour = timeArray[ 0 ] ? timeArray[ 0 ].toString() : timeArray.toString();

	                if ( this.explicitMode && hour.length > 2 && ( hour.length % 2 ) !== 0 ) {
	                    this.clear();
	                    return;
	                }

	                minute = timeArray[ 1 ] ? timeArray[ 1 ].toString() : '';
	                second = timeArray[ 2 ] ? timeArray[ 2 ].toString() : '';

	                // adaptive time parsing
	                if ( hour.length > 4 ) {
	                    second = hour.slice( -2 );
	                    hour = hour.slice( 0, -2 );
	                }

	                if ( hour.length > 2 ) {
	                    minute = hour.slice( -2 );
	                    hour = hour.slice( 0, -2 );
	                }

	                if ( minute.length > 2 ) {
	                    second = minute.slice( -2 );
	                    minute = minute.slice( 0, -2 );
	                }

	                hour = parseInt( hour, 10 );
	                minute = parseInt( minute, 10 );
	                second = parseInt( second, 10 );

	                if ( isNaN( hour ) ) {
	                    hour = 0;
	                }
	                if ( isNaN( minute ) ) {
	                    minute = 0;
	                }
	                if ( isNaN( second ) ) {
	                    second = 0;
	                }

	                // Adjust the time based upon unit boundary.
	                // NOTE: Negatives will never occur due to time.replace() above.
	                if ( second > 59 ) {
	                    second = 59;
	                }

	                if ( minute > 59 ) {
	                    minute = 59;
	                }

	                if ( hour >= this.maxHours ) {
	                    // No day/date handling.
	                    hour = this.maxHours - 1;
	                }

	                if ( this.showMeridian ) {
	                    if ( hour > 12 ) {
	                        // Force PM.
	                        timeMode = 2;
	                        hour -= 12;
	                    }
	                    if ( !timeMode ) {
	                        timeMode = 1;
	                    }
	                    if ( hour === 0 ) {
	                        hour = 12; // AM or PM, reset to 12.  0 AM = 12 AM.  0 PM = 12 PM, etc.
	                    }
	                    meridian = timeMode === 1 ? this.meridianNotation.am : this.meridianNotation.pm;
	                } else if ( hour < 12 && timeMode === 2 ) {
	                    hour += 12;
	                } else {
	                    if ( hour >= this.maxHours ) {
	                        hour = this.maxHours - 1;
	                    } else if ( ( hour < 0 ) || ( hour === 12 && timeMode === 1 ) ) {
	                        hour = 0;
	                    }
	                }
	            }

	            this.hour = hour;
	            if ( this.snapToStep ) {
	                this.minute = this.changeToNearestStep( minute, this.minuteStep );
	                this.second = this.changeToNearestStep( second, this.secondStep );
	            } else {
	                this.minute = minute;
	                this.second = second;
	            }
	            this.meridian = meridian;

	            this.update( ignoreWidget );
	        },

	        showWidget() {
	            if ( this.isOpen ) {
	                return;
	            }

	            if ( this.$element.is( ':disabled' ) ) {
	                return;
	            }

	            // make sure the widget is in sync with input
	            this.setTime( this.$element.val() );
	            this.updateWidget();

	            // show/hide approach taken by datepicker
	            this.$widget.appendTo( this.appendWidgetTo );
	            $( document ).on( 'mousedown.timepicker, touchend.timepicker', {
	                scope: this
	            }, this.handleDocumentClick );

	            this.$element.trigger( {
	                'type': 'show.timepicker',
	                'time': {
	                    'value': this.getTime(),
	                    'hours': this.hour,
	                    'minutes': this.minute,
	                    'seconds': this.second,
	                    'meridian': this.meridian
	                }
	            } );

	            this.place();
	            if ( this.disableFocus ) {
	                this.$element.blur();
	            }

	            if ( this.hour === '' ) {
	                if ( this.defaultTime ) {
	                    this.setDefaultTime( this.defaultTime );
	                }
	            }

	            if ( this.isOpen === false ) {
	                this.$widget.addClass( 'open' );
	            }

	            this.isOpen = true;
	        },

	        toggleMeridian() {
	            this.meridian = this.meridian === this.meridianNotation.am ? this.meridianNotation.pm : this.meridianNotation.am;
	        },

	        update( ignoreWidget ) {
	            this.updateElement();
	            if ( !ignoreWidget ) {
	                this.updateWidget();
	            }

	            this.$element.trigger( {
	                'type': 'changeTime.timepicker',
	                'time': {
	                    'value': this.getTime(),
	                    'hours': this.hour,
	                    'minutes': this.minute,
	                    'seconds': this.second,
	                    'meridian': this.meridian
	                }
	            } );
	        },

	        updateElement() {
	            this.$element.val( this.getTime() );
	            // this.$element.change() method does not fire an event that can be 
	            // caught with el.addEventListener('change', () => {})
	            this.$element[ 0 ].dispatchEvent( event.Change() );
	        },

	        updateFromElementVal() {
	            this.setTime( this.$element.val() );
	        },

	        updateWidget() {
	            if ( this.$widget === false ) {
	                return;
	            }

	            const hour = this.hour,
	                minute = this.minute.toString().length === 1 ? `0${this.minute}` : this.minute,
	                second = this.second.toString().length === 1 ? `0${this.second}` : this.second;

	            if ( this.showInputs ) {
	                this.$widget.find( 'input.timepicker-hour' ).val( hour );
	                this.$widget.find( 'input.timepicker-minute' ).val( minute );

	                if ( this.showSeconds ) {
	                    this.$widget.find( 'input.timepicker-second' ).val( second );
	                }
	                if ( this.showMeridian ) {
	                    this.$widget.find( 'input.timepicker-meridian' ).val( this.meridian );
	                }
	            } else {
	                this.$widget.find( 'span.timepicker-hour' ).text( hour );
	                this.$widget.find( 'span.timepicker-minute' ).text( minute );

	                if ( this.showSeconds ) {
	                    this.$widget.find( 'span.timepicker-second' ).text( second );
	                }
	                if ( this.showMeridian ) {
	                    this.$widget.find( 'span.timepicker-meridian' ).text( this.meridian );
	                }
	            }
	        },

	        updateFromWidgetInputs() {
	            if ( this.$widget === false ) {
	                return;
	            }

	            const t = `${this.$widget.find( 'input.timepicker-hour' ).val()}:${this.$widget.find( 'input.timepicker-minute' ).val()}${this.showSeconds ? `:${this.$widget.find( 'input.timepicker-second' ).val()}` : ''}${this.showMeridian ? this.$widget.find( 'input.timepicker-meridian' ).val() : ''}`;

	            this.setTime( t, true );
	        },

	        widgetClick( e ) {
	            e.stopPropagation();
	            e.preventDefault();

	            const $input = $( e.target ),
	                action = $input.closest( 'a' ).data( 'action' );

	            if ( action ) {
	                this[ action ]();
	            }
	            this.update();

	            if ( $input.is( 'input' ) ) {
	                $input.get( 0 ).setSelectionRange( 0, 2 );
	            }
	        },

	        widgetKeydown( e ) {
	            const $input = $( e.target ),
	                name = $input.attr( 'class' ).replace( 'timepicker-', '' );

	            switch ( e.which ) {
	                case 9: //tab
	                    if ( e.shiftKey ) {
	                        if ( name === 'hour' ) {
	                            return this.hideWidget();
	                        }
	                    } else if ( ( this.showMeridian && name === 'meridian' ) || ( this.showSeconds && name === 'second' ) || ( !this.showMeridian && !this.showSeconds && name === 'minute' ) ) {
	                        return this.hideWidget();
	                    }
	                    break;
	                case 27: // escape
	                    this.hideWidget();
	                    break;
	                case 38: // up arrow
	                    e.preventDefault();
	                    switch ( name ) {
	                        case 'hour':
	                            this.incrementHour();
	                            break;
	                        case 'minute':
	                            this.incrementMinute();
	                            break;
	                        case 'second':
	                            this.incrementSecond();
	                            break;
	                        case 'meridian':
	                            this.toggleMeridian();
	                            break;
	                    }
	                    this.setTime( this.getTime() );
	                    $input.get( 0 ).setSelectionRange( 0, 2 );
	                    break;
	                case 40: // down arrow
	                    e.preventDefault();
	                    switch ( name ) {
	                        case 'hour':
	                            this.decrementHour();
	                            break;
	                        case 'minute':
	                            this.decrementMinute();
	                            break;
	                        case 'second':
	                            this.decrementSecond();
	                            break;
	                        case 'meridian':
	                            this.toggleMeridian();
	                            break;
	                    }
	                    this.setTime( this.getTime() );
	                    $input.get( 0 ).setSelectionRange( 0, 2 );
	                    break;
	            }
	        },

	        widgetKeyup( e ) {
	            if ( ( e.which === 65 ) || ( e.which === 77 ) || ( e.which === 80 ) || ( e.which === 46 ) || ( e.which === 8 ) || ( e.which >= 48 && e.which <= 57 ) || ( e.which >= 96 && e.which <= 105 ) ) {
	                this.updateFromWidgetInputs();
	            }
	        }
	    };

	    //TIMEPICKER PLUGIN DEFINITION
	    $.fn.timepicker = function( option ) {
	        const args = Array( ...arguments );
	        args.shift();
	        return this.each( function() {
	            const $this = $( this );
	            let data = $this.data( 'timepicker' );
	            const options = typeof option === 'object' && option;

	            if ( !data ) {
	                $this.data( 'timepicker', ( data = new Timepicker( this, $.extend( {}, $.fn.timepicker.defaults, options, $( this ).data() ) ) ) );
	            }

	            if ( typeof option === 'string' ) {
	                data[ option ]( ...args );
	            }
	        } );
	    };

	    $.fn.timepicker.defaults = {
	        defaultTime: 'current',
	        disableFocus: false,
	        disableMousewheel: false,
	        isOpen: false,
	        minuteStep: 15,
	        orientation: {
	            x: 'auto',
	            y: 'auto'
	        },
	        secondStep: 15,
	        snapToStep: false,
	        showSeconds: false,
	        showInputs: true,
	        showMeridian: true,
	        meridianNotation: {
	            am: 'AM',
	            pm: 'PM'
	        },
	        template: 'dropdown',
	        appendWidgetTo: 'body',
	        showWidgetOnAddonClick: true,
	        icons: {
	            up: 'glyphicon glyphicon-chevron-up',
	            down: 'glyphicon glyphicon-chevron-down'
	        },
	        maxHours: 24,
	        explicitMode: false
	    };

	    $.fn.timepicker.Constructor = Timepicker;

	    $( document ).on(
	        'focus.timepicker.data-api click.timepicker.data-api',
	        '[data-provide="timepicker"]',
	        function( e ) {
	            const $this = $( this );
	            if ( $this.data( 'timepicker' ) ) {
	                return;
	            }
	            e.preventDefault();
	            // component click requires us to explicitly show it
	            $this.timepicker();
	        }
	    );
	} ) )( jquery, window, document );

	class TimepickerExtended extends Widget {

	    static get selector() {
	        return '.question input[type="time"]:not([readonly])';
	    }

	    static condition() {
	        return !support.touch || !support.inputTypes.time;
	    }

	    _init() {
	        const fragment = document.createRange().createContextualFragment(
	            `<div class="widget timepicker">
                <input class="ignore timepicker-default" type="text" placeholder="hh:mm" />
            </div>`
	        );
	        fragment.querySelector( '.widget' ).append( this.resetButtonHtml );
	        this.element.classList.add( 'hide' );
	        this.element.after( fragment );

	        const resetBtn = this.question.querySelector( '.widget > .btn-reset' );
	        this.fakeTimeI = this.question.querySelector( '.widget > input' );

	        jquery( this.fakeTimeI )
	            .timepicker( {
	                showMeridian: time.hour12,
	                meridianNotation: {
	                    am: time.amNotation,
	                    pm: time.pmNotation
	                }
	            } );

	        // using setTime ensures that the fakeInput shows the meridan when needed
	        this.value = this.originalInputValue;

	        this.fakeTimeI.addEventListener( 'change', () => {
	            const modified = time.hour12 ? types.time.convertMeridian( this.value ) : this.value;
	            this.originalInputValue = modified;
	        } );

	        // reset button
	        resetBtn.addEventListener( 'click', this._reset.bind( this ) );

	        // handle original input focus
	        this.element.addEventListener( event.ApplyFocus().type, () => {
	            this.fakeTimeI.focus();
	        } );

	    }

	    _reset() {
	        const ev = this.originalInputValue ? event.Change() : null;
	        if ( ev || this.value ) {
	            this.value = '';
	            //this.originalInputValue = '';
	            this.fakeTimeI.dispatchEvent( ev );
	        }
	    }

	    update() {
	        jquery( this.element )
	            .next( '.widget' )
	            .find( 'input' )
	            .timepicker( 'setTime', this.element.value );
	    }

	    get value() {
	        return this.fakeTimeI.value;
	    }

	    set value( value ) {
	        jquery( this.fakeTimeI ).timepicker( 'setTime', value );
	    }
	}

	class DatetimepickerExtended extends Widget {

	    static get selector() {
	        return '.question input[type="datetime"]:not([readonly])';
	    }

	    static condition() {
	        const badSamsung = /GT-P31[0-9]{2}.+AppleWebKit\/534\.30/;

	        /*
	         * Samsung mobile browser (called "Internet") has a weird bug that appears sometimes (?) when an input field
	         * already has a value and is edited. The new value YYYY-MM-DD prepends old or replaces the year of the old value and first hyphen. E.g.
	         * existing: 2010-01-01, new value entered: 2012-12-12 => input field shows: 2012-12-1201-01.
	         * This doesn't seem to effect the actual value of the input, just the way it is displayed. But if the incorrectly displayed date is then
	         * attempted to be edited again, it does get the incorrect value and it's impossible to clear this and create a valid date.
	         *
	         * browser: "Mozilla/5.0 (Linux; U; Android 4.1.1; en-us; GT-P3113 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30";
	         * webview: "Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; GT-P3100 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30"
	         */

	        return !support.touch || !support.inputTypes.datetime || badSamsung.test( navigator.userAgent );
	    }

	    _init() {
	        this.$fakeDateI = this._createFakeDateInput();
	        this.$fakeTimeI = this._createFakeTimeInput();

	        this.element.classList.add( 'hide' );
	        this.element.after( document.createRange().createContextualFragment( '<div class="datetimepicker widget" />' ) );
	        const widget = this.question.querySelector( '.widget' );
	        widget.append( this.$fakeDateI[ 0 ].closest( '.date' ) );
	        widget.append( this.$fakeTimeI[ 0 ].closest( '.timepicker' ) );

	        this.$fakeDateI
	            .datepicker( {
	                format: 'yyyy-mm-dd',
	                autoclose: true,
	                todayHighlight: true,
	                forceParse: false
	            } );

	        this.$fakeTimeI
	            .timepicker( {
	                showMeridian: time.hour12,
	                meridianNotation: {
	                    am: time.amNotation,
	                    pm: time.pmNotation
	                }
	            } );

	        this.value = this.originalInputValue;

	        this._setFocusHandler( this.$fakeDateI.add( this.$fakeTimeI ) );

	        this.$fakeDateI
	            .on( 'change changeDate', () => {
	                if ( !types.date.validate( this.$fakeDateI[ 0 ].value ) ) {
	                    this.$fakeDateI.val( '' ).datepicker( 'update' );
	                }
	                this.originalInputValue = this.value;
	                return false;
	            } );

	        this.$fakeTimeI
	            .on( 'change', () => {
	                this.originalInputValue = this.value;
	                return false;
	            } );

	        //reset button
	        this.question.querySelector( '.btn-reset' ).addEventListener( 'click', () => {
	            const event = this.originalInputValue ? 'change' : '';
	            if ( event || this.$fakeDateI.val() || this.$fakeTimeI.val() ) {
	                this.$fakeDateI.val( '' ).trigger( event ).datepicker( 'update' );
	                this.$fakeTimeI.val( '' ).trigger( event );
	            }
	        } );

	    }

	    _createFakeDateInput() {
	        const $fakeDate = jquery(
	            '<div class="date">' +
	            '<input class="ignore" type="text" placeholder="yyyy-mm-dd"/>' +
	            '</div>' );

	        return $fakeDate.find( 'input' );
	    }

	    _createFakeTimeInput() {
	        const $fakeTime = jquery(
	                `<div class="timepicker">
                    <input class="ignore timepicker-default" type="text" placeholder="hh:mm"/>
                </div>` )
	            .append( this.resetButtonHtml );

	        return $fakeTime.find( 'input' );
	    }

	    _setFocusHandler( $els ) {
	        // Handle focus on original input (goTo functionality)
	        this.element.addEventListener( event.ApplyFocus().type, () => {
	            $els.eq( 0 ).focus();
	        } );
	    }

	    update() {
	        const $dateTimeI = jquery( this.element );
	        const val = ( $dateTimeI.val().length > 0 ) ? new Date( $dateTimeI.val() ).toISOLocalString() : '';
	        const vals = val.split( 'T' );
	        const dateVal = vals[ 0 ];
	        const timeVal = ( vals[ 1 ] && vals[ 1 ].length > 4 ) ? vals[ 1 ].substring( 0, 5 ) : '';

	        this.$fakeDateI.datepicker( 'setDate', dateVal );
	        this.$fakeTimeI.timepicker( 'setTime', timeVal );
	    }

	    get value() {
	        if ( this.$fakeDateI.val().length > 0 && this.$fakeTimeI.val().length > 3 ) {
	            const d = this.$fakeDateI.val().split( '-' );
	            const timeModified = time.hour12 ? types.time.convertMeridian( this.$fakeTimeI.val() ) : this.$fakeTimeI.val();
	            const t = timeModified.split( ':' );
	            return new Date( d[ 0 ], d[ 1 ] - 1, d[ 2 ], t[ 0 ], t[ 1 ] ).toISOLocalString();
	        } else {
	            return '';
	        }
	    }

	    set value( value ) {
	        /*
	          Loaded or default datetime values remain untouched until they are edited. This is done to preserve 
	          the timezone information (especially for instances-to-edit) if the values are not edited (the
	          original entry may have been done in a different time zone than the edit). However, 
	          values shown in the widget should reflect the local time representation of that value.
	         */
	        const val = value ? new Date( value ).toISOLocalString() : '';
	        const vals = val.split( 'T' );
	        const dateVal = vals[ 0 ];
	        const timeVal = ( vals[ 1 ] && vals[ 1 ].length > 4 ) ? vals[ 1 ].substring( 0, 5 ) : '';
	        this.$fakeDateI.datepicker( 'setDate', dateVal );
	        this.$fakeTimeI.timepicker( 'setTime', timeVal );
	    }
	}

	/**
	 * Compact Picker. Hides text labels if a media label is present.
	 */
	class CompactPicker extends Widget {

	    static get selector() {
	        return '.or-appearance-compact, .or-appearance-quickcompact, [class*="or-appearance-compact-"]';
	    }

	    _init() {
	        this.element.querySelectorAll( '.option-label' ).forEach( function( optionLabel ) {
	            if ( getSiblingElements( optionLabel, 'img, video, audio' ).length > 0 ) {
	                optionLabel.style.display = 'none';
	            }
	        } );
	    }

	}

	/**
	 * Simple file manager with cross-browser support. That uses the FileReader
	 * to create previews. Can be replaced with a more advanced version that
	 * obtains files from storage.
	 *
	 * The replacement should support the same public methods and return the same
	 * types.
	 */
	const fileManager = {};

	/**
	 * Initialize the file manager .
	 * @return {[type]} promise boolean or rejection with Error
	 */
	fileManager.init = () => Promise.resolve( true );

	/**
	 * Whether the filemanager is waiting for user permissions
	 * @return {Boolean} [description]
	 */
	fileManager.isWaitingForPermissions = () => false;

	/**
	 * Obtains a URL that can be used to show a preview of the file when used
	 * as a src attribute.
	 * 
	 * It is meant for media previews and media downloads.
	 *
	 * @param  {?string|Object} subject File or filename in local storage
	 * @return {[type]}         promise url string or rejection with Error
	 */
	fileManager.getFileUrl = subject => new Promise( ( resolve, reject ) => {
	    let error;

	    if ( !subject ) {
	        resolve( null );
	    } else if ( typeof subject === 'string' ) {
	        // TODO obtain from storage as http URL or objectURL
	        reject( 'no!' );
	    } else if ( typeof subject === 'object' ) {
	        if ( fileManager.isTooLarge( subject ) ) {
	            error = new Error( t( 'filepicker.toolargeerror', { maxSize: fileManager.getMaxSizeReadable() } ) );
	            reject( error );
	        } else {
	            resolve( URL.createObjectURL( subject ) );
	        }
	    } else {
	        reject( new Error( 'Unknown error occurred' ) );
	    }
	} );

	/**
	 * Similar to getFileURL, except that this one is guaranteed to return an objectURL
	 * 
	 * It is meant for loading images into a canvas.
	 * 
	 * @param  {?string|Object} subject File or filename in local storage
	 * @return {[type]}         promise url string or rejection with Error
	 */
	fileManager.getObjectUrl = subject => fileManager.getFileUrl( subject )
	    .then( url => {
	        if ( /https?:\/\//.test( url ) ) {
	            return fileManager.urlToBlob( url ).then( URL.createObjectURL );
	        }
	        return url;
	    } );

	fileManager.urlToBlob = url => {
	    const xhr = new XMLHttpRequest();

	    return new Promise( resolve => {
	        xhr.open( 'GET', url );
	        xhr.responseType = 'blob';
	        xhr.onload = () => {
	            resolve( xhr.response );
	        };
	        xhr.send();
	    } );
	};

	/**
	 * Obtain files currently stored in file input elements of open record
	 * @return {[File]} array of files
	 */
	fileManager.getCurrentFiles = () => {
	    const files = [];

	    // Get any files inside file input elements or text input elements for drawings.
	    jquery( 'form.or' ).find( 'input[type="file"]:not(.ignore), input[type="text"][data-drawing="true"]' ).each( function() {
	        let newFilename;
	        let file = null;
	        let canvas = null;
	        if ( this.type === 'file' ) {
	            file = this.files[ 0 ]; // Why doesn't this fail for empty file inputs?
	        } else if ( this.value ) {
	            canvas = jquery( this ).closest( '.question' )[ 0 ].querySelector( '.draw-widget canvas' );
	            if ( canvas ) {
	                // TODO: In the future, we could simply do canvas.toBlob() instead
	                file = dataUriToBlobSync( canvas.toDataURL() );
	                file.name = this.value;
	            }
	        }
	        if ( file && file.name ) {
	            // Correct file names by adding a unique-ish postfix
	            // First create a clone, because the name property is immutable
	            // TODO: in the future, when browser support increase we can invoke
	            // the File constructor to do this.
	            newFilename = getFilename( file, this.dataset.filenamePostfix );
	            file = new Blob( [ file ], {
	                type: file.type
	            } );
	            file.name = newFilename;
	            files.push( file );
	        }
	    } );

	    return files;
	};

	/**
	 * Placeholder function to check if file size is acceptable. 
	 * 
	 * @param  {Blob}  file [description]
	 * @return {Boolean}      [description]
	 */
	fileManager.isTooLarge = () => false;

	/**
	 * Replace with function that determines max size published in OpenRosa server response header.
	 */
	fileManager.getMaxSizeReadable = () => `${5}MB`;

	// Error to be translated
	function TranslatedError( message, translationKey, translationOptions ) {
	    this.message = message;
	    this.translationKey = translationKey;
	    this.translationOptions = translationOptions;
	}
	TranslatedError.prototype = Object.create( Error.prototype );
	TranslatedError.prototype.name = 'TranslatedError';

	// TODO: remove remaining jquery (events, namespaces)
	// TODO: run (some) standard widget tests

	/**
	 * FilePicker that works both offline and online. It abstracts the file storage/cache away
	 * with the injected fileManager.
	 */
	class Filepicker extends Widget {

	    static get selector() {
	        return '.question:not(.or-appearance-draw):not(.or-appearance-signature):not(.or-appearance-annotate) input[type="file"]';
	    }

	    _init() {
	        const existingFileName = this.element.getAttribute( 'data-loaded-file-name' );
	        const that = this;

	        this.element.classList.add( 'hide' );
	        this.question.classList.add( 'with-media', 'clearfix' );

	        const fragment = document.createRange().createContextualFragment(
	            `<div class="widget file-picker">
                    <input class="ignore fake-file-input"/>
                    <div class="file-feedback"></div>
                    <div class="file-preview"></div>
                </div>` );

	        fragment.querySelector( 'input' ).after( this.downloadButtonHtml );
	        fragment.querySelector( 'input' ).after( this.resetButtonHtml );

	        this.element.after( fragment );

	        this.disable();

	        const widget = this.question.querySelector( '.widget' );
	        this.feedback = widget.querySelector( '.file-feedback' );
	        this.preview = widget.querySelector( '.file-preview' );
	        this.fakeInput = widget.querySelector( '.fake-file-input' );
	        this.downloadLink = widget.querySelector( '.btn-download' );

	        that._setResetButtonListener( widget.querySelector( '.btn-reset' ) );

	        // Focus listener needs to be added synchronously
	        that._setFocusListener();

	        // show loaded file name or placeholder regardless of whether widget is supported
	        this._showFileName( existingFileName );

	        if ( fileManager.isWaitingForPermissions() ) {
	            this._showFeedback( t( 'filepicker.waitingForPermissions' ), 'warning' );
	        }

	        // Monitor maxSize changes to update placeholder text. This facilitates asynchronous 
	        // obtaining of max size from server without slowing down form loading.
	        this._updatePlaceholder();
	        jquery( this.element.closest( 'form.or' ) ).on( 'updateMaxSize', this._updatePlaceholder.bind( this ) );

	        fileManager.init()
	            .then( () => {
	                that._showFeedback();
	                that._setChangeListener();
	                if ( !that.props.readonly ) {
	                    that.enable();
	                }
	                if ( existingFileName ) {
	                    fileManager.getFileUrl( existingFileName )
	                        .then( url => {
	                            that._showPreview( url, that.props.mediaType );
	                            that._updateDownloadLink( url, existingFileName );
	                        } )
	                        .catch( () => {
	                            that._showFeedback( t( 'filepicker.notFound', {
	                                existing: existingFileName
	                            } ), 'error' );
	                        } );
	                }
	            } )
	            .catch( error => {
	                that._showFeedback( error, 'error' );
	            } );
	    }

	    _updatePlaceholder() {
	        this.fakeInput.setAttribute( 'placeholder', t( 'filepicker.placeholder', { maxSize: fileManager.getMaxSizeReadable() || '?MB' } ) );
	    }

	    _setResetButtonListener( resetButton ) {
	        if ( resetButton ) {
	            resetButton.addEventListener( 'click', () => {
	                if ( ( this.originalInputValue || this.value ) ) {
	                    dialog.confirm( t( 'filepicker.resetWarning', { item: t( 'filepicker.file' ) } ) )
	                        .then( confirmed => {
	                            if ( confirmed ) {
	                                this.originalInputValue = '';
	                            }
	                        } )
	                        .catch( () => {} );
	                }
	            } );
	        }
	    }

	    _setChangeListener() {
	        const that = this;

	        jquery( this.element )
	            .on( 'click', event => {
	                // The purpose of this handler is to block the filepicker window
	                // when the label is clicked outside of the input.
	                if ( that.props.readonly || event.namespace !== 'propagate' ) {
	                    that.fakeInput.focus();
	                    event.stopImmediatePropagation();
	                    return false;
	                }
	            } )
	            .on( 'change.propagate', event => {
	                let file;
	                let fileName;
	                let postfix;
	                const loadedFileName = this.element.getAttribute( 'data-loaded-file-name' );
	                const now = new Date();

	                if ( event.namespace === 'propagate' ) {
	                    // Trigger eventhandler to update instance value
	                    jquery( this.element ).trigger( 'change.file' );
	                    return false;
	                } else {
	                    event.stopImmediatePropagation();
	                }

	                // Get the file
	                file = event.target.files[ 0 ];
	                postfix = `-${now.getHours()}_${now.getMinutes()}_${now.getSeconds()}`;
	                event.target.dataset.filenamePostfix = postfix;
	                fileName = getFilename( file, postfix );

	                // Process the file
	                fileManager.getFileUrl( file, fileName )
	                    .then( url => {
	                        // Update UI
	                        that._showPreview( url, that.props.mediaType );
	                        that._showFeedback();
	                        that._showFileName( fileName );
	                        if ( loadedFileName && loadedFileName !== fileName ) {
	                            that.element.removeAttribute( 'data-loaded-file-name' );
	                        }
	                        that._updateDownloadLink( url, fileName );
	                        // Update record
	                        jquery( that.element ).trigger( 'change.propagate' );
	                    } )
	                    .catch( error => {
	                        // Update record to clear any existing valid value
	                        jquery( that.element ).val( '' ).trigger( 'change.propagate' );
	                        // Update UI
	                        that._showFileName( '' );
	                        that._showPreview( null );
	                        that._showFeedback( error, 'error' );
	                        that._updateDownloadLink( '', '' );
	                    } );
	            } );

	        this.fakeInput.addEventListener( 'click', event => {
	            /* 
	                The purpose of this handler is to selectively propagate clicks on the fake
	                input to the underlying file input (to show the file picker window).
	                It blocks propagation if the filepicker has a value to avoid accidentally
	                clearing files in a loaded record, hereby blocking native browser file input behavior
	                to clear values. Instead the reset button is the only way to clear a value.
	            */
	            event.preventDefault();
	            if ( this.props.readonly || this.originalInputValue || this.value ) {
	                this.fakeInput.focus();
	                event.stopImmediatePropagation();
	                return;
	            }
	            jquery( that.element ).trigger( 'click.propagate' );
	        } );

	        // For robustness, avoid any editing of filenames by user.
	        this.fakeInput.addEventListener( 'change', event => {
	            event.preventDefault();
	            event.stopPropagation();
	        } );
	    }

	    _setFocusListener() {

	        // Handle focus on original input (goTo functionality)
	        this.element.addEventListener( event.ApplyFocus().type, () => {
	            this.fakeInput.focus();
	        } );
	    }

	    _showFileName( fileName ) {
	        this.value = fileName;
	        this.fakeInput.readOnly = !!fileName;
	    }

	    _showFeedback( fb, status ) {
	        const message = fb instanceof TranslatedError ? t( fb.translationKey, fb.translationOptions ) :
	            fb instanceof Error ? fb.message :
	            fb || '';
	        status = status || '';
	        // replace text and replace all existing classes with the new status class
	        this.feedback.textContent = message;
	        this.feedback.setAttribute( 'class', `file-feedback ${status}` );
	    }

	    _showPreview( url, mediaType ) {
	        let htmlStr;

	        empty( this.preview );

	        switch ( mediaType ) {
	            case 'image/*':
	                htmlStr = '<img />';
	                break;
	            case 'audio/*':
	                htmlStr = '<audio controls="controls"/>';
	                break;
	            case 'video/*':
	                htmlStr = '<video controls="controls"/>';
	                break;
	        }

	        if ( url && htmlStr ) {
	            const fragment = document.createRange().createContextualFragment( htmlStr );
	            fragment.querySelector( '*' ).src = url;
	            this.preview.append( fragment );
	        }
	    }

	    _updateDownloadLink( objectUrl, fileName ) {
	        updateDownloadLink( this.downloadLink, objectUrl, fileName );
	    }

	    disable() {
	        this.element.disabled = true;
	        this.question.querySelector( '.btn-reset' ).disabled = true;
	    }
	    enable() {
	        this.element.disabled = false;
	        this.question.querySelector( '.btn-reset' ).disabled = false;
	    }

	    get props() {
	        const props = this._props;
	        props.mediaType = this.element.getAttribute( 'accept' );

	        return props;
	    }

	    get value() {
	        return this.fakeInput.value;
	    }

	    set value( value ) {
	        this.fakeInput.value = value;
	    }

	}

	/*!
	 * Signature Pad v2.3.2
	 * https://github.com/szimek/signature_pad
	 *
	 * Copyright 2017 Szymon Nowak
	 * Released under the MIT license
	 *
	 * The main idea and some parts of the code (e.g. drawing variable width Bézier curve) are taken from:
	 * http://corner.squareup.com/2012/07/smoother-signatures.html
	 *
	 * Implementation of interpolation using cubic Bézier curves is taken from:
	 * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript
	 *
	 * Algorithm for approximated length of a Bézier curve is taken from:
	 * http://www.lemoda.net/maths/bezier-length/index.html
	 *
	 */

	function Point(x, y, time) {
	  this.x = x;
	  this.y = y;
	  this.time = time || new Date().getTime();
	}

	Point.prototype.velocityFrom = function (start) {
	  return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 1;
	};

	Point.prototype.distanceTo = function (start) {
	  return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
	};

	Point.prototype.equals = function (other) {
	  return this.x === other.x && this.y === other.y && this.time === other.time;
	};

	function Bezier(startPoint, control1, control2, endPoint) {
	  this.startPoint = startPoint;
	  this.control1 = control1;
	  this.control2 = control2;
	  this.endPoint = endPoint;
	}

	// Returns approximated length.
	Bezier.prototype.length = function () {
	  var steps = 10;
	  var length = 0;
	  var px = void 0;
	  var py = void 0;

	  for (var i = 0; i <= steps; i += 1) {
	    var t = i / steps;
	    var cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
	    var cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
	    if (i > 0) {
	      var xdiff = cx - px;
	      var ydiff = cy - py;
	      length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
	    }
	    px = cx;
	    py = cy;
	  }

	  return length;
	};

	/* eslint-disable no-multi-spaces, space-in-parens */
	Bezier.prototype._point = function (t, start, c1, c2, end) {
	  return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;
	};

	/* eslint-disable */

	// http://stackoverflow.com/a/27078401/815507
	function throttle(func, wait, options) {
	  var context, args, result;
	  var timeout = null;
	  var previous = 0;
	  if (!options) options = {};
	  var later = function later() {
	    previous = options.leading === false ? 0 : Date.now();
	    timeout = null;
	    result = func.apply(context, args);
	    if (!timeout) context = args = null;
	  };
	  return function () {
	    var now = Date.now();
	    if (!previous && options.leading === false) previous = now;
	    var remaining = wait - (now - previous);
	    context = this;
	    args = arguments;
	    if (remaining <= 0 || remaining > wait) {
	      if (timeout) {
	        clearTimeout(timeout);
	        timeout = null;
	      }
	      previous = now;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    } else if (!timeout && options.trailing !== false) {
	      timeout = setTimeout(later, remaining);
	    }
	    return result;
	  };
	}

	function SignaturePad(canvas, options) {
	  var self = this;
	  var opts = options || {};

	  this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;
	  this.minWidth = opts.minWidth || 0.5;
	  this.maxWidth = opts.maxWidth || 2.5;
	  this.throttle = 'throttle' in opts ? opts.throttle : 16; // in miliseconds
	  this.minDistance = 'minDistance' in opts ? opts.minDistance : 5;

	  if (this.throttle) {
	    this._strokeMoveUpdate = throttle(SignaturePad.prototype._strokeUpdate, this.throttle);
	  } else {
	    this._strokeMoveUpdate = SignaturePad.prototype._strokeUpdate;
	  }

	  this.dotSize = opts.dotSize || function () {
	    return (this.minWidth + this.maxWidth) / 2;
	  };
	  this.penColor = opts.penColor || 'black';
	  this.backgroundColor = opts.backgroundColor || 'rgba(0,0,0,0)';
	  this.onBegin = opts.onBegin;
	  this.onEnd = opts.onEnd;

	  this._canvas = canvas;
	  this._ctx = canvas.getContext('2d');
	  this.clear();

	  // We need add these inline so they are available to unbind while still having
	  // access to 'self' we could use _.bind but it's not worth adding a dependency.
	  this._handleMouseDown = function (event) {
	    if (event.which === 1) {
	      self._mouseButtonDown = true;
	      self._strokeBegin(event);
	    }
	  };

	  this._handleMouseMove = function (event) {
	    if (self._mouseButtonDown) {
	      self._strokeMoveUpdate(event);
	    }
	  };

	  this._handleMouseUp = function (event) {
	    if (event.which === 1 && self._mouseButtonDown) {
	      self._mouseButtonDown = false;
	      self._strokeEnd(event);
	    }
	  };

	  this._handleTouchStart = function (event) {
	    if (event.targetTouches.length === 1) {
	      var touch = event.changedTouches[0];
	      self._strokeBegin(touch);
	    }
	  };

	  this._handleTouchMove = function (event) {
	    // Prevent scrolling.
	    event.preventDefault();

	    var touch = event.targetTouches[0];
	    self._strokeMoveUpdate(touch);
	  };

	  this._handleTouchEnd = function (event) {
	    var wasCanvasTouched = event.target === self._canvas;
	    if (wasCanvasTouched) {
	      event.preventDefault();
	      self._strokeEnd(event);
	    }
	  };

	  // Enable mouse and touch event handlers
	  this.on();
	}

	// Public methods
	SignaturePad.prototype.clear = function () {
	  var ctx = this._ctx;
	  var canvas = this._canvas;

	  ctx.fillStyle = this.backgroundColor;
	  ctx.clearRect(0, 0, canvas.width, canvas.height);
	  ctx.fillRect(0, 0, canvas.width, canvas.height);

	  this._data = [];
	  this._reset();
	  this._isEmpty = true;
	};

	SignaturePad.prototype.fromDataURL = function (dataUrl) {
	  var _this = this;

	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  var image = new Image();
	  var ratio = options.ratio || window.devicePixelRatio || 1;
	  var width = options.width || this._canvas.width / ratio;
	  var height = options.height || this._canvas.height / ratio;

	  this._reset();
	  image.src = dataUrl;
	  image.onload = function () {
	    _this._ctx.drawImage(image, 0, 0, width, height);
	  };
	  this._isEmpty = false;
	};

	SignaturePad.prototype.toDataURL = function (type) {
	  var _canvas;

	  switch (type) {
	    case 'image/svg+xml':
	      return this._toSVG();
	    default:
	      for (var _len = arguments.length, options = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        options[_key - 1] = arguments[_key];
	      }

	      return (_canvas = this._canvas).toDataURL.apply(_canvas, [type].concat(options));
	  }
	};

	SignaturePad.prototype.on = function () {
	  this._handleMouseEvents();
	  this._handleTouchEvents();
	};

	SignaturePad.prototype.off = function () {
	  this._canvas.removeEventListener('mousedown', this._handleMouseDown);
	  this._canvas.removeEventListener('mousemove', this._handleMouseMove);
	  document.removeEventListener('mouseup', this._handleMouseUp);

	  this._canvas.removeEventListener('touchstart', this._handleTouchStart);
	  this._canvas.removeEventListener('touchmove', this._handleTouchMove);
	  this._canvas.removeEventListener('touchend', this._handleTouchEnd);
	};

	SignaturePad.prototype.isEmpty = function () {
	  return this._isEmpty;
	};

	// Private methods
	SignaturePad.prototype._strokeBegin = function (event) {
	  this._data.push([]);
	  this._reset();
	  this._strokeUpdate(event);

	  if (typeof this.onBegin === 'function') {
	    this.onBegin(event);
	  }
	};

	SignaturePad.prototype._strokeUpdate = function (event) {
	  var x = event.clientX;
	  var y = event.clientY;

	  var point = this._createPoint(x, y);
	  var lastPointGroup = this._data[this._data.length - 1];
	  var lastPoint = lastPointGroup && lastPointGroup[lastPointGroup.length - 1];
	  var isLastPointTooClose = lastPoint && point.distanceTo(lastPoint) < this.minDistance;

	  // Skip this point if it's too close to the previous one
	  if (!(lastPoint && isLastPointTooClose)) {
	    var _addPoint = this._addPoint(point),
	        curve = _addPoint.curve,
	        widths = _addPoint.widths;

	    if (curve && widths) {
	      this._drawCurve(curve, widths.start, widths.end);
	    }

	    this._data[this._data.length - 1].push({
	      x: point.x,
	      y: point.y,
	      time: point.time,
	      color: this.penColor
	    });
	  }
	};

	SignaturePad.prototype._strokeEnd = function (event) {
	  var canDrawCurve = this.points.length > 2;
	  var point = this.points[0]; // Point instance

	  if (!canDrawCurve && point) {
	    this._drawDot(point);
	  }

	  if (point) {
	    var lastPointGroup = this._data[this._data.length - 1];
	    var lastPoint = lastPointGroup[lastPointGroup.length - 1]; // plain object

	    // When drawing a dot, there's only one point in a group, so without this check
	    // such group would end up with exactly the same 2 points.
	    if (!point.equals(lastPoint)) {
	      lastPointGroup.push({
	        x: point.x,
	        y: point.y,
	        time: point.time,
	        color: this.penColor
	      });
	    }
	  }

	  if (typeof this.onEnd === 'function') {
	    this.onEnd(event);
	  }
	};

	SignaturePad.prototype._handleMouseEvents = function () {
	  this._mouseButtonDown = false;

	  this._canvas.addEventListener('mousedown', this._handleMouseDown);
	  this._canvas.addEventListener('mousemove', this._handleMouseMove);
	  document.addEventListener('mouseup', this._handleMouseUp);
	};

	SignaturePad.prototype._handleTouchEvents = function () {
	  // Pass touch events to canvas element on mobile IE11 and Edge.
	  this._canvas.style.msTouchAction = 'none';
	  this._canvas.style.touchAction = 'none';

	  this._canvas.addEventListener('touchstart', this._handleTouchStart);
	  this._canvas.addEventListener('touchmove', this._handleTouchMove);
	  this._canvas.addEventListener('touchend', this._handleTouchEnd);
	};

	SignaturePad.prototype._reset = function () {
	  this.points = [];
	  this._lastVelocity = 0;
	  this._lastWidth = (this.minWidth + this.maxWidth) / 2;
	  this._ctx.fillStyle = this.penColor;
	};

	SignaturePad.prototype._createPoint = function (x, y, time) {
	  var rect = this._canvas.getBoundingClientRect();

	  return new Point(x - rect.left, y - rect.top, time || new Date().getTime());
	};

	SignaturePad.prototype._addPoint = function (point) {
	  var points = this.points;
	  var tmp = void 0;

	  points.push(point);

	  if (points.length > 2) {
	    // To reduce the initial lag make it work with 3 points
	    // by copying the first point to the beginning.
	    if (points.length === 3) points.unshift(points[0]);

	    tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
	    var c2 = tmp.c2;
	    tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
	    var c3 = tmp.c1;
	    var curve = new Bezier(points[1], c2, c3, points[2]);
	    var widths = this._calculateCurveWidths(curve);

	    // Remove the first element from the list,
	    // so that we always have no more than 4 points in points array.
	    points.shift();

	    return { curve: curve, widths: widths };
	  }

	  return {};
	};

	SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
	  var dx1 = s1.x - s2.x;
	  var dy1 = s1.y - s2.y;
	  var dx2 = s2.x - s3.x;
	  var dy2 = s2.y - s3.y;

	  var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };
	  var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };

	  var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
	  var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

	  var dxm = m1.x - m2.x;
	  var dym = m1.y - m2.y;

	  var k = l2 / (l1 + l2);
	  var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };

	  var tx = s2.x - cm.x;
	  var ty = s2.y - cm.y;

	  return {
	    c1: new Point(m1.x + tx, m1.y + ty),
	    c2: new Point(m2.x + tx, m2.y + ty)
	  };
	};

	SignaturePad.prototype._calculateCurveWidths = function (curve) {
	  var startPoint = curve.startPoint;
	  var endPoint = curve.endPoint;
	  var widths = { start: null, end: null };

	  var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - this.velocityFilterWeight) * this._lastVelocity;

	  var newWidth = this._strokeWidth(velocity);

	  widths.start = this._lastWidth;
	  widths.end = newWidth;

	  this._lastVelocity = velocity;
	  this._lastWidth = newWidth;

	  return widths;
	};

	SignaturePad.prototype._strokeWidth = function (velocity) {
	  return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
	};

	SignaturePad.prototype._drawPoint = function (x, y, size) {
	  var ctx = this._ctx;

	  ctx.moveTo(x, y);
	  ctx.arc(x, y, size, 0, 2 * Math.PI, false);
	  this._isEmpty = false;
	};

	SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
	  var ctx = this._ctx;
	  var widthDelta = endWidth - startWidth;
	  var drawSteps = Math.floor(curve.length());

	  ctx.beginPath();

	  for (var i = 0; i < drawSteps; i += 1) {
	    // Calculate the Bezier (x, y) coordinate for this step.
	    var t = i / drawSteps;
	    var tt = t * t;
	    var ttt = tt * t;
	    var u = 1 - t;
	    var uu = u * u;
	    var uuu = uu * u;

	    var x = uuu * curve.startPoint.x;
	    x += 3 * uu * t * curve.control1.x;
	    x += 3 * u * tt * curve.control2.x;
	    x += ttt * curve.endPoint.x;

	    var y = uuu * curve.startPoint.y;
	    y += 3 * uu * t * curve.control1.y;
	    y += 3 * u * tt * curve.control2.y;
	    y += ttt * curve.endPoint.y;

	    var width = startWidth + ttt * widthDelta;
	    this._drawPoint(x, y, width);
	  }

	  ctx.closePath();
	  ctx.fill();
	};

	SignaturePad.prototype._drawDot = function (point) {
	  var ctx = this._ctx;
	  var width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;

	  ctx.beginPath();
	  this._drawPoint(point.x, point.y, width);
	  ctx.closePath();
	  ctx.fill();
	};

	SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {
	  for (var i = 0; i < pointGroups.length; i += 1) {
	    var group = pointGroups[i];

	    if (group.length > 1) {
	      for (var j = 0; j < group.length; j += 1) {
	        var rawPoint = group[j];
	        var point = new Point(rawPoint.x, rawPoint.y, rawPoint.time);
	        var color = rawPoint.color;

	        if (j === 0) {
	          // First point in a group. Nothing to draw yet.

	          // All points in the group have the same color, so it's enough to set
	          // penColor just at the beginning.
	          this.penColor = color;
	          this._reset();

	          this._addPoint(point);
	        } else if (j !== group.length - 1) {
	          // Middle point in a group.
	          var _addPoint2 = this._addPoint(point),
	              curve = _addPoint2.curve,
	              widths = _addPoint2.widths;

	          if (curve && widths) {
	            drawCurve(curve, widths, color);
	          }
	        }
	      }
	    } else {
	      this._reset();
	      var _rawPoint = group[0];
	      drawDot(_rawPoint);
	    }
	  }
	};

	SignaturePad.prototype._toSVG = function () {
	  var _this2 = this;

	  var pointGroups = this._data;
	  var canvas = this._canvas;
	  var ratio = Math.max(window.devicePixelRatio || 1, 1);
	  var minX = 0;
	  var minY = 0;
	  var maxX = canvas.width / ratio;
	  var maxY = canvas.height / ratio;
	  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

	  svg.setAttributeNS(null, 'width', canvas.width);
	  svg.setAttributeNS(null, 'height', canvas.height);

	  this._fromData(pointGroups, function (curve, widths, color) {
	    var path = document.createElement('path');

	    // Need to check curve for NaN values, these pop up when drawing
	    // lines on the canvas that are not continuous. E.g. Sharp corners
	    // or stopping mid-stroke and than continuing without lifting mouse.
	    if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
	      var attr = 'M ' + curve.startPoint.x.toFixed(3) + ',' + curve.startPoint.y.toFixed(3) + ' ' + ('C ' + curve.control1.x.toFixed(3) + ',' + curve.control1.y.toFixed(3) + ' ') + (curve.control2.x.toFixed(3) + ',' + curve.control2.y.toFixed(3) + ' ') + (curve.endPoint.x.toFixed(3) + ',' + curve.endPoint.y.toFixed(3));

	      path.setAttribute('d', attr);
	      path.setAttribute('stroke-width', (widths.end * 2.25).toFixed(3));
	      path.setAttribute('stroke', color);
	      path.setAttribute('fill', 'none');
	      path.setAttribute('stroke-linecap', 'round');

	      svg.appendChild(path);
	    }
	  }, function (rawPoint) {
	    var circle = document.createElement('circle');
	    var dotSize = typeof _this2.dotSize === 'function' ? _this2.dotSize() : _this2.dotSize;
	    circle.setAttribute('r', dotSize);
	    circle.setAttribute('cx', rawPoint.x);
	    circle.setAttribute('cy', rawPoint.y);
	    circle.setAttribute('fill', rawPoint.color);

	    svg.appendChild(circle);
	  });

	  var prefix = 'data:image/svg+xml;base64,';
	  var header = '<svg' + ' xmlns="http://www.w3.org/2000/svg"' + ' xmlns:xlink="http://www.w3.org/1999/xlink"' + (' viewBox="' + minX + ' ' + minY + ' ' + maxX + ' ' + maxY + '"') + (' width="' + maxX + '"') + (' height="' + maxY + '"') + '>';
	  var body = svg.innerHTML;

	  // IE hack for missing innerHTML property on SVGElement
	  if (body === undefined) {
	    var dummy = document.createElement('dummy');
	    var nodes = svg.childNodes;
	    dummy.innerHTML = '';

	    for (var i = 0; i < nodes.length; i += 1) {
	      dummy.appendChild(nodes[i].cloneNode(true));
	    }

	    body = dummy.innerHTML;
	  }

	  var footer = '</svg>';
	  var data = header + body + footer;

	  return prefix + btoa(data);
	};

	SignaturePad.prototype.fromData = function (pointGroups) {
	  var _this3 = this;

	  this.clear();

	  this._fromData(pointGroups, function (curve, widths) {
	    return _this3._drawCurve(curve, widths.start, widths.end);
	  }, function (rawPoint) {
	    return _this3._drawDot(rawPoint);
	  });

	  this._data = pointGroups;
	};

	SignaturePad.prototype.toData = function () {
	  return this._data;
	};

	const DELAY = 1500;

	/**
	 * SignaturePad.prototype.fromDataURL is asynchronous and does not return a 
	 * Promise. This is a rewrite returning a promise and the objectUrl.
	 * In addition it also fixes a bug where a loaded image is stretched to fit
	 * the canvas.
	 * 
	 * @param {*} objectUrl 
	 * @param {*} options 
	 */
	SignaturePad.prototype.fromObjectURL = function( objectUrl, options ) {
	    const image = new Image();
	    options = options || {};
	    const deviceRatio = options.ratio || window.devicePixelRatio || 1;
	    const width = options.width || ( this._canvas.width / deviceRatio );
	    const height = options.height || ( this._canvas.height / deviceRatio );
	    const that = this;

	    this._reset();

	    return new Promise( resolve => {
	        image.src = objectUrl;
	        image.onload = () => {
	            const imgWidth = image.width;
	            const imgHeight = image.height;
	            const hRatio = width / imgWidth;
	            const vRatio = height / imgHeight;
	            let left;
	            let top;

	            if ( hRatio < 1 || vRatio < 1 ) { //if image is bigger than canvas then fit within the canvas
	                const ratio = Math.min( hRatio, vRatio );
	                left = ( width - imgWidth * ratio ) / 2;
	                top = ( height - imgHeight * ratio ) / 2;
	                that._ctx.drawImage( image, 0, 0, imgWidth, imgHeight, left, top, imgWidth * ratio, imgHeight * ratio );
	            } else { // if image is smaller than canvas then show it in the center and don't stretch it
	                left = ( width - imgWidth ) / 2;
	                top = ( height - imgHeight ) / 2;
	                that._ctx.drawImage( image, left, top, imgWidth, imgHeight );
	            }
	            resolve( objectUrl );
	        };
	        that._isEmpty = false;
	    } );
	};

	/**
	 * Similar to SignaturePad.prototype.fromData except that it doesn't clear the canvas.
	 * This is to facilitate undoing a drawing stroke over a background (bitmap) image.
	 * 
	 * @param {*} pointGroups 
	 */
	SignaturePad.prototype.updateData = function( pointGroups ) {
	    const that = this;
	    this._fromData(
	        pointGroups,
	        ( curve, widths ) => { that._drawCurve( curve, widths.start, widths.end ); },
	        rawPoint => { that._drawDot( rawPoint ); }
	    );

	    this._data = pointGroups;
	};

	/**
	 * Widget to obtain user-provided drawings or signature.
	 */
	class DrawWidget extends Widget {
	    static get selector() {
	        // note that the selector needs to match both the pre-instantiated form and the post-instantiated form (type attribute changes)
	        return '.or-appearance-draw input[data-type-xml="binary"][accept^="image"], .or-appearance-signature input[data-type-xml="binary"][accept^="image"], .or-appearance-annotate input[data-type-xml="binary"][accept^="image"]';
	    }

	    _init() {
	        let canvas;
	        const that = this;
	        const existingFilename = this.element.dataset.loadedFileName;

	        this.element.type = 'text';
	        this.element.dataset.drawing = true;

	        this.element.after( this._getMarkup() );
	        const question = this.question;

	        question.classList.add( `or-${this.props.type}-initialized` );

	        this.$widget = jquery( question.querySelector( '.widget' ) );

	        canvas = this.$widget[ 0 ].querySelector( '.draw-widget__body__canvas' );
	        this._handleResize( canvas );
	        this._resizeCanvas( canvas );

	        if ( this.props.load ) {
	            this._handleFiles( existingFilename );
	        }

	        // We built a delay in saving on stroke "end", to avoid excessive updating
	        // This event does not fire on touchscreens for which we use the .hide-canvas-btn click
	        // to do the same thing.
	        canvas.addEventListener( 'blur', this._forceUpdate.bind( this ) );

	        this.initialize = fileManager.init()
	            .then( () => {
	                that.pad = new SignaturePad( canvas, {
	                    onEnd: () => {
	                        // keep replacing this timer so continuous drawing
	                        // doesn't update the value after every stroke.
	                        clearTimeout( that._updateWithDelay );
	                        that._updateWithDelay = setTimeout( that._updateValue.bind( that ), DELAY );
	                    },
	                    penColor: that.props.colors[ 0 ] || 'black'
	                } );
	                that.pad.off();
	                if ( existingFilename ) {
	                    that.element.value = existingFilename;
	                    return that._loadFileIntoPad( existingFilename )
	                        .then( that._updateDownloadLink.bind( that ) );
	                }
	                return true;
	            } );
	        this.disable();
	        this.initialize
	            .then( () => {
	                that.$widget
	                    .find( '.btn-reset' ).on( 'click', that._reset.bind( that ) )
	                    .end().find( '.draw-widget__colorpicker' )
	                    .on( 'click', '.current', function() {
	                        jquery( this ).parent().toggleClass( 'reveal' );
	                    } )
	                    .on( 'click', '[data-color]:not(.current)', function() {
	                        jquery( this ).siblings().removeClass( 'current' ).end().addClass( 'current' )
	                            .parent().removeClass( 'reveal' );
	                        that.pad.penColor = this.dataset.color;
	                    } )
	                    .end().find( '.draw-widget__undo' ).on( 'click', () => {
	                        const data = that.pad.toData();
	                        that.pad.clear();
	                        const fileInput = that.$widget[ 0 ].querySelector( 'input[type=file]' );
	                        // that.element.dataset.loadedFileName will have been removed only after resetting 
	                        const fileToLoad = fileInput && fileInput.files[ 0 ] ? fileInput.files[ 0 ] : that.element.dataset.loadedFileName;
	                        that._loadFileIntoPad( fileToLoad )
	                            .then( () => {
	                                that.pad.updateData( data.slice( 0, -1 ) );
	                                that._updateValue();
	                                that.pad.penColor = that.$widget.find( '.draw-widget__colorpicker .current' )[ 0 ].dataset.color;
	                            } );
	                    } )
	                    .end().find( '.show-canvas-btn' ).on( 'click', () => {
	                        that.$widget.addClass( 'full-screen' );
	                        that._resizeCanvas( canvas );
	                        that.enable();
	                        return false;
	                    } )
	                    .end().find( '.hide-canvas-btn' ).on( 'click', () => {
	                        that.$widget.removeClass( 'full-screen' );
	                        that.pad.off();
	                        that._resizeCanvas( canvas );
	                        that._forceUpdate();
	                        return false;
	                    } ).click();

	                jquery( canvas )
	                    .on( 'canvasreload', () => {
	                        if ( that.cache ) {
	                            that.pad.fromObjectURL( that.cache )
	                                .then( that._updateValue.bind( that ) );
	                        }
	                    } );
	                that.enable();
	            } )
	            .catch( error => {
	                that._showFeedback( error.message );
	            } );

	        jquery( this.element )
	            .on( 'applyfocus', () => {
	                canvas.focus();
	            } )
	            .closest( '[role="page"]' ).on( 'pageflip', () => {
	                // When an existing value is loaded into the canvas and is not 
	                // the first page, it won't become visible until the canvas is clicked
	                // or the window is resized:
	                // https://github.com/kobotoolbox/enketo-express/issues/895
	                // This also fixes a similar issue with an empty canvas:
	                // https://github.com/kobotoolbox/enketo-express/issues/844
	                that._resizeCanvas( canvas );
	            } );
	    }

	    _forceUpdate() {
	        if ( this._updateWithDelay ) {
	            clearTimeout( this._updateWithDelay );
	            this._updateValue();
	        }
	    }

	    // All this is copied from the file-picker widget
	    _handleFiles( loadedFileName ) {
	        // Monitor maxSize changes to update placeholder text in annotate widget. This facilitates asynchronous 
	        // obtaining of max size from server without slowing down form loading.
	        this._updatePlaceholder();
	        this.$widget.closest( 'form.or' ).on( 'updateMaxSize', this._updatePlaceholder.bind( this ) );

	        const that = this;

	        const $input = this.$widget.find( 'input[type=file]' );
	        const $fakeInput = this.$widget.find( '.fake-file-input' );

	        // show loaded file name or placeholder regardless of whether widget is supported
	        this._showFileName( loadedFileName );

	        $input
	            .on( 'click', event => {
	                // The purpose of this handler is to block the filepicker window
	                // when the label is clicked outside of the input.
	                if ( that.props.readonly || event.namespace !== 'propagate' ) {
	                    that.$fakeInput.focus();
	                    event.stopImmediatePropagation();
	                    return false;
	                }
	            } )
	            .on( 'change', function() {
	                // Get the file
	                const file = this.files[ 0 ];

	                if ( file ) {
	                    // Process the file
	                    if ( !fileManager.isTooLarge( file ) ) {
	                        // Update UI
	                        that.pad.clear();
	                        that._loadFileIntoPad( this.files[ 0 ] )
	                            .then( () => {
	                                that._updateValue.call( that );
	                                that._showFileName( file.name );
	                                that.enable();
	                            } );
	                    } else {
	                        that._showFeedback( t( 'filepicker.toolargeerror', { maxSize: fileManager.getMaxSizeReadable() } ) );
	                    }
	                } else {
	                    that._showFileName( null );
	                }
	            } );

	        $fakeInput
	            .on( 'click', function( event ) {
	                /* 
	                    The purpose of this handler is to selectively propagate clicks on the fake
	                    input to the underlying file input (to show the file picker window).
	                    It blocks propagation if the filepicker has a value to avoid accidentally
	                    clearing files in a loaded record, hereby blocking native browser file input behavior
	                    to clear values. Instead the reset button is the only way to clear a value.
	                */
	                if ( that.props.readonly || $input[ 0 ].value || $fakeInput[ 0 ].value ) {
	                    jquery( this ).focus();
	                    event.stopImmediatePropagation();
	                    return false;
	                }
	                event.preventDefault();
	                $input.trigger( 'click.propagate' );
	            } )
	            .on( 'change', () => // For robustness, avoid any editing of filenames by user.
	                false );
	    }

	    _showFileName( fileName ) {
	        this.$widget.find( '.fake-file-input' ).val( fileName ).prop( 'readonly', !!fileName );
	    }

	    _updatePlaceholder() {
	        this.$widget.find( '.fake-file-input' ).attr( 'placeholder', t( 'filepicker.placeholder', { maxSize: fileManager.getMaxSizeReadable() || '?MB' } ) );
	    }

	    _getMarkup() {
	        // HTML syntax copied from filepicker widget
	        const load = this.props.load ? `<input type="file" class="ignore draw-widget__load"${this.props.capture !== null ? ` capture="${this.props.capture}"` : ''} accept="${this.props.accept}"/><div class="widget file-picker"><input class="ignore fake-file-input"/><div class="file-feedback"></div></div>` : '';
	        const fullscreenBtns = this.props.touch ? '<button type="button" class="show-canvas-btn btn btn-default">Draw/Sign</button>' +
	            '<button type="button" class="hide-canvas-btn btn btn-default"><span class="icon icon-arrow-left"> </span></button>' : '';
	        const fragment = document.createRange().createContextualFragment(
	            `<div class="widget draw-widget">
                <div class="draw-widget__body">
                    ${fullscreenBtns}
                    ${load}
                    <canvas class="draw-widget__body__canvas noSwipe disabled" tabindex="0"></canvas>
                    <div class="draw-widget__colorpicker"></div>
                    ${this.props.type === 'signature' ? '' : '<button class="btn-icon-only draw-widget__undo" aria-label="undo" type=button><i class="icon icon-undo"> </i></button>'}
                </div>
                <div class="draw-widget__footer">
                    <div class="draw-widget__feedback"></div>
                </div>
            </div>`
	        );
	        fragment.querySelector( '.draw-widget__footer' ).prepend( this.downloadButtonHtml );
	        fragment.querySelector( '.draw-widget__footer' ).prepend( this.resetButtonHtml );

	        const colorpicker = fragment.querySelector( '.draw-widget__colorpicker' );

	        this.props.colors.forEach( ( color, index ) => {
	            const current = index === 0 ? ' current' : '';
	            const colorDiv = document.createRange().createContextualFragment( `<div class="${current}"data-color="${color}" style="background: ${color};" />` );
	            colorpicker.append( colorDiv );
	        } );

	        return fragment;
	    }

	    _updateValue() {
	        const now = new Date();
	        const postfix = `-${now.getHours()}_${now.getMinutes()}_${now.getSeconds()}`;
	        this.element.dataset.filenamePostfix = postfix;
	        // Note that this.element has become a text input.
	        this.originalInputValue = this.props.filename;
	        // pad.toData() doesn't seem to work when redrawing on a smaller canvas. Doesn't scale.
	        // pad.toDataURL() is crude and memory-heavy but the advantage is that it will also work for appearance=annotate
	        this.value = this.pad.toDataURL();
	        this._updateDownloadLink( this.value );
	    }

	    _reset() {
	        const that = this;

	        if ( this.element.value ) {
	            // This discombulated line is to help the i18next parser pick up all 3 keys.
	            const item = this.props.type === 'signature' ?
	                t( 'drawwidget.signature' ) : ( this.props.type === 'drawing' ? t( 'drawwidget.drawing' ) : t( 'drawwidget.annotation' ) );
	            dialog.confirm( t( 'filepicker.resetWarning', { item } ) )
	                .then( confirmed => {
	                    if ( !confirmed ) {
	                        return;
	                    }
	                    that.pad.clear();
	                    that.cache = null;
	                    // Only upon reset is loadedFileName removed, so that "undo" will work
	                    // for drawings loaded from storage.
	                    delete that.element.dataset.loadedFileName;
	                    that.element.dataset.filenamePostfix = '';
	                    jquery( that.element ).val( '' ).trigger( 'change' );
	                    // Annotate file input
	                    that.$widget.find( 'input[type=file]' ).val( '' ).trigger( 'change' );
	                    that._updateDownloadLink( '' );
	                    that.disable();
	                    that.enable();
	                } );
	        }
	    }

	    /**
	     * 
	     * @param {*} file Either a filename or a file.
	     */
	    _loadFileIntoPad( file ) {
	        const that = this;
	        if ( !file ) {
	            return Promise.resolve( '' );
	        }
	        return fileManager.getObjectUrl( file )
	            .then( that.pad.fromObjectURL.bind( that.pad ) )
	            .then( objectUrl => {
	                that.cache = objectUrl;
	                return objectUrl;
	            } )
	            .catch( () => {
	                that._showFeedback( 'File could not be loaded (leave unchanged if already submitted and you want to preserve it).', 'error' );
	            } );
	    }

	    _showFeedback( message ) {
	        message = message || '';

	        // replace text and replace all existing classes with the new status class
	        this.$widget.find( '.draw-widget__feedback' ).text( message );
	    }

	    _updateDownloadLink( url ) {
	        if ( url && url.indexOf( 'data:' ) === 0 ) {
	            url = URL.createObjectURL( dataUriToBlobSync( url ) );
	        }
	        const fileName = url ? getFilename( { name: this.element.value }, this.element.dataset.filenamePostfix ) : '';
	        updateDownloadLink( this.$widget.find( '.btn-download' )[ 0 ], url, fileName );
	    }

	    _handleResize( canvas ) {
	        const that = this;
	        jquery( window ).on( 'resize', () => {
	            that._resizeCanvas( canvas );
	        } );
	    }

	    // Adjust canvas coordinate space taking into account pixel ratio,
	    // to make it look crisp on mobile devices.
	    // This also causes canvas to be cleared.
	    _resizeCanvas( canvas ) {
	        // Use a little trick to avoid resizing currently-hidden canvases
	        // https://github.com/enketo/enketo-core/issues/605
	        if ( canvas.offsetWidth > 0 ) {
	            // When zoomed out to less than 100%, for some very strange reason,
	            // some browsers report devicePixelRatio as less than 1
	            // and only part of the canvas is cleared then.
	            const ratio = Math.max( window.devicePixelRatio || 1, 1 );
	            canvas.width = canvas.offsetWidth * ratio;
	            canvas.height = canvas.offsetHeight * ratio;
	            canvas.getContext( '2d' ).scale( ratio, ratio );
	            jquery( canvas ).trigger( 'canvasreload' );
	        }
	    }

	    disable() {
	        const that = this;
	        const canvas = this.$widget.find( '.draw-widget__body__canvas' )[ 0 ];

	        this.initialize
	            .then( () => {
	                that.pad.off();
	                canvas.classList.add( 'disabled' );
	                that.$widget
	                    .find( '.btn-reset' )
	                    .prop( 'disabled', true );
	            } );
	    }

	    enable() {
	        const that = this;
	        const canvas = this.$widget.find( '.draw-widget__body__canvas' )[ 0 ];
	        const touchNotFull = this.props.touch && !this.$widget.is( '.full-screen' );
	        const needFile = this.props.load && !this.element.value;

	        this.initialize
	            .then( () => {
	                if ( !that.props.readonly && !needFile && !touchNotFull ) {
	                    that.pad.on();
	                    canvas.classList.remove( 'disabled' );
	                    that.$widget
	                        .find( '.btn-reset' )
	                        .prop( 'disabled', false );
	                }
	                // https://github.com/enketo/enketo-core/issues/450
	                // When loading a question with a relevant, it is invisible 
	                // until branch.js removes the "pre-init" class. The rendering of the 
	                // canvas may therefore still be ongoing when this widget is instantiated.
	                // For that reason we call _resizeCanvas when enable is called to make
	                // sure the canvas is rendered properly.
	                that._resizeCanvas( canvas );
	            } );
	    }

	    /** 
	     * Updates value when it is programmatically cleared.
	     * There is no way to programmatically update a file input other than clearing it, so that's all
	     * we need to do.
	     * 
	     * @param  {[type]} element [description]
	     * @return {[type]}         [description]
	     */
	    update() {
	        if ( this.originalInputValue === '' ) {
	            this._reset();
	        }
	    }

	    get props() {
	        const props = this._props;

	        props.type = props.appearances.includes( 'draw' ) ? 'drawing' : ( props.appearances.includes( 'signature' ) ? 'signature' : 'annotation' );
	        props.filename = `${props.type}.png`;
	        props.load = props.type === 'annotation';
	        props.colors = props.type === 'signature' ? [] : [ 'black', 'lightblue', 'blue', 'red', 'orange', 'cyan', 'yellow', 'lightgreen', 'green', 'pink', 'purple', 'lightgray', 'darkgray' ];
	        props.touch = support.touch;
	        props.accept = this.element.getAttribute( 'accept' );
	        props.capture = this.element.getAttribute( 'capture' );

	        return props;
	    }

	    get value() {
	        return this.cache || '';
	    }

	    set value( dataUrl ) {
	        this.cache = dataUrl;
	    }

	}

	// Since this class has no static selector getter, there will be no attempt to instantiate it.
	class LikertItem {}

	/**
	 * Horizontal Choices Widgets. Adds a filler if the last row contains two elements.
	 * The filler avoids the last radiobutton or checkbox to not be lined up correctly below the second column.
	 */
	class HorizontalChoices extends Widget {

	    static get selector() {
	        return '.question.or-appearance-horizontal';
	    }

	    _init() {
	        this.element.querySelectorAll( '.option-wrapper' ).forEach( wrapper => {
	            const COLUMNS = 3;

	            let fillers = COLUMNS - wrapper.querySelectorAll( 'label' ).length % COLUMNS;

	            while ( fillers < COLUMNS && fillers > 0 ) {
	                wrapper.append( document.createRange().createContextualFragment( '<label class="filler"></label>' ) );
	                fillers--;
	            }
	            // if added to correct question type, add initialized class
	            this.question.classList.add( 'or-horizontal-initialized' );
	        } );
	    }
	}

	class RangeWidget extends Widget {

	    static get selector() {
	        return '.or-appearance-distress input[type="number"], .question:not(.or-appearance-analog-scale) > input[type="number"][min][max][step]';
	    }

	    _init() {
	        const that = this;

	        const fragment = document.createRange().createContextualFragment( this._getHtmlStr() );
	        fragment.querySelector( '.range-widget__scale__end' ).before( this.resetButtonHtml );
	        fragment.querySelector( '.range-widget__scale__start' ).textContent = this.props.min;
	        fragment.querySelector( '.range-widget__scale__end' ).textContent = this.props.max;

	        this.element.after( fragment );
	        this.element.classList.add( 'hide' );
	        this.element.addEventListener( 'applyfocus', () => {
	            this.range.focus();
	        } );

	        this.widget = this.question.querySelector( '.widget' );
	        this.range = this.widget.querySelector( 'input' );
	        this.current = this.widget.querySelector( '.range-widget__current' );

	        if ( this.props.readonly ) {
	            this.disable();
	        }

	        this.range.addEventListener( 'change', () => {
	            this.current.textContent = this.value;
	            this.originalInputValue = this.value;
	            this._updateMercury( ( this.value - this.props.min ) / ( that.props.max - that.props.min ) );
	        } );

	        // Do not use change handler for this because this doesn't fire if the user clicks on the internal DEFAULT
	        // value of the range input.
	        this.widget.querySelector( 'input.empty' ).addEventListener( 'click', () => {
	            this.range.classList.remove( 'empty' );
	            this.range.dispatchEvent( event.Change() );
	        } );
	        this.widget.querySelector( 'input.empty' ).addEventListener( 'touchstart', () => {
	            this.range.classList.remove( 'empty' );
	            this.range.dispatchEvent( event.Change() );
	        } );

	        this.widget.querySelector( '.btn-reset' ).addEventListener( 'click', this._reset.bind( this ) );

	        // loads the default value if exists, else resets
	        this.update();

	        let ticks = this.props.ticks ? Math.ceil( Math.abs( ( this.props.max - this.props.min ) / this.props.step ) ) : 1;
	        // Now reduce to a number < 50 to avoid showing a sold black tick line.
	        let divisor = Math.ceil( ticks / this.props.maxTicks );
	        while ( ticks % divisor && divisor < ticks ) {
	            divisor++;
	        }
	        ticks = ticks / divisor;

	        // Various attemps to use more elegant CSS background on the _ticks div, have failed due to little 
	        // issues seemingly related to rounding or browser sloppiness. This far is less elegant but nice and robust:
	        this.widget.querySelector( '.range-widget__ticks' )
	            .append( document.createRange().createContextualFragment( new Array( ticks ).fill( '<span></span>' ).join( '' ) ) );
	    }

	    /**
	     * This is separated so it can be extended (in the analog-scale widget)
	     */
	    _getHtmlStr() {
	        const html =
	            `<div class="widget range-widget">
                <div class="range-widget__wrap">
                    <div class="range-widget__current"></div>
                    <div class="range-widget__bg"></div>
                    <div class="range-widget__ticks"></div>
                    <div class="range-widget__scale">
                        <span class="range-widget__scale__start"></span>
                        ${this._stepsBetweenHtmlStr( this.props )}
                        <span class="range-widget__scale__end"></span>
                    </div>
                    <div class="range-widget__bulb">
                        <div class="range-widget__bulb__inner"></div>
                        <div class="range-widget__bulb__mercury"></div>
                    </div>
                </div>
                <input type="range" class="ignore empty" min="${this.props.min}" max="${this.props.max}" step="${this.props.step}"/>
            </div>`;

	        return html;
	    }

	    _updateMercury( completeness ) {
	        const trackHeight = this.widget.querySelector( '.range-widget__ticks' ).clientHeight;
	        const bulbHeight = this.widget.querySelector( '.range-widget__bulb' ).clientHeight;
	        this.widget.querySelector( '.range-widget__bulb__mercury' ).style.height = `${( completeness * trackHeight ) + ( 0.5 * bulbHeight )}px`;
	    }

	    _stepsBetweenHtmlStr( props ) {
	        let html = '';
	        if ( props.distress ) {
	            const stepsCount = ( props.max - props.min ) / props.step;
	            if ( stepsCount <= 10 && ( props.max - props.min ) % props.step === 0 ) {
	                for ( let i = props.min + props.step; i < props.max; i += props.step ) {
	                    html += `<span class="range-widget__scale__between">${i}</span>`;
	                }
	            }
	        }
	        return html;
	    }

	    _reset() {
	        this.value = '';
	        this.originalInputValue = '';
	        this.current.textContent = '-';
	        this._updateMercury( -1 );
	    }

	    disable() {
	        this.widget.querySelectorAll( 'input, button' ).forEach( el => el.disabled = true );
	    }

	    enable() {
	        this.widget.querySelectorAll( 'input, button' ).forEach( el => el.disabled = false );
	    }

	    update() {
	        const value = this.element.value;

	        if ( isNumber( value ) ) {
	            this.value = value;
	            this.range.dispatchEvent( event.Change() );
	        } else {
	            this._reset();
	        }
	    }

	    get props() {
	        const props = this._props;
	        const min = isNumber( this.element.getAttribute( 'min' ) ) ? this.element.getAttribute( 'min' ) : 0;
	        const max = isNumber( this.element.getAttribute( 'max' ) ) ? this.element.getAttribute( 'max' ) : 10;
	        const step = isNumber( this.element.getAttribute( 'step' ) ) ? this.element.getAttribute( 'step' ) : 1;
	        const distress = props.appearances.includes( 'distress' );

	        props.min = Number( min );
	        props.max = Number( max );
	        props.step = Number( step );
	        props.vertical = props.appearances.includes( 'vertical' ) || distress;
	        props.ticks = !props.appearances.includes( 'no-ticks' );
	        props.distress = distress;
	        props.maxTicks = 50;

	        return props;
	    }

	    get value() {
	        return this.range.classList.contains( 'empty' ) ? '' : this.range.value;
	    }

	    set value( value ) {
	        this.range.value = value;
	        // value '' actually sets the value to some default value in html range input, not really helpful
	        this.range.classList.toggle( 'empty', value === '' );
	    }


	}

	class AnalogScaleWidget extends RangeWidget {

	    static get selector() {
	        return '.or-appearance-analog-scale input[type="number"]';
	    }

	    _init() {
	        super._init();
	        if ( this.props.vertical ) {
	            this.question.classList.add( 'or-appearance-vertical' );
	        }
	        this.question.classList.add( 'or-analog-scale-initialized' );
	        this._renderLabels();
	        this._setResizeListener();
	    }

	    _getHtmlStr() {
	        const html =
	            `<div class="widget analog-scale-widget">
                ${super._getHtmlStr()}
            </div>`;

	        return html;
	    }

	    _updateMercury() {}

	    /** 
	     * (re-)Renders the widget labels based on the current content of .question-label.active
	     */
	    _renderLabels() {
	        const fragment = document.createRange().createContextualFragment( '<div class="label-content widget"></div>' );
	        const wrapper = fragment.querySelector( '.label-content' );

	        this.question.querySelectorAll( '.question-label, .or-hint, .or-required-msg, .or-constraint-msg' )
	            .forEach( el => wrapper.append( el ) );

	        this.question.prepend( fragment );

	        this.labelContent = this.question.querySelector( '.label-content' );
	        this._updateLabels();
	    }

	    _updateLabels() {
	        if ( !this.question.classList.contains( 'or-analog-scale-initialized' ) ) {
	            return;
	        }
	        const labelEl = this.labelContent.querySelector( '.question-label.active:not(.widget)' );
	        const labels = labelEl.innerHTML.split( /\|/ ).map( label => label.trim() );

	        const existingLabel = this.labelContent.querySelector( '.question-label.widget' );
	        if ( existingLabel ) {
	            existingLabel.remove();
	        }
	        const labelFragment = document.createRange().createContextualFragment( `<span class="question-label widget active">${labels[ 0 ]}</span>` );
	        labelEl.after( labelFragment );

	        const existingMaxLabel = this.widget.querySelector( '.max-label' );
	        if ( existingMaxLabel ) {
	            existingMaxLabel.remove();
	        }
	        const maxLabel = document.createRange().createContextualFragment( `<div class="max-label">${labels[ 1 ]}</div>` );
	        this.widget.prepend( maxLabel );

	        const existingMinLabel = this.widget.querySelector( '.min-label' );
	        if ( existingMinLabel ) {
	            existingMinLabel.remove();
	        }
	        const minLabel = document.createRange().createContextualFragment( `<div class="min-label">${labels[ 2 ]}</div>` );
	        this.widget.append( minLabel );

	        const showValue = this.labelContent.querySelector( '.show-value' );
	        if ( showValue ) {
	            showValue.remove();
	        }
	        if ( labels[ 3 ] ) {
	            const showValueBox = document.createRange().createContextualFragment(
	                `<div class="widget show-value">
                    <div class="show-value__box">${labels[ 3 ]}<span class="show-value__value">${this.value}</span></div>
                <div>` );
	            this.labelContent.append( showValueBox );
	            this.current = this.labelContent.querySelector( '.show-value__value' );
	        }
	    }


	    /*
	     * Stretch the question to full page height.
	     * Doing this with pure css flexbox using "flex-direction: column" interferes with the Grid theme 
	     * because that theme relies on flexbox with "flex-direction: row".
	     */
	    _setResizeListener() {
	        if ( this.props.vertical ) {
	            // Will only be triggered if question by itself constitutes a page.
	            // It will not be triggered if question is contained inside a group with fieldlist appearance.
	            this.question.addEventListener( 'pageflip', this._stretchHeight.bind( this ) );
	        }
	    }

	    _stretchHeight() {
	        this.question.style[ 'min-height' ] = 'auto';
	    }

	    update() {
	        super.update();
	        this._updateLabels();
	    }

	    get props() {
	        const props = this._props;
	        props.touch = support.touch;
	        props.min = isNumber( this.element.getAttribute( 'min' ) ) ? this.element.getAttribute( 'min' ) : 0;
	        props.max = isNumber( this.element.getAttribute( 'max' ) ) ? this.element.getAttribute( 'max' ) : 100;
	        props.step = isNumber( this.element.getAttribute( 'step' ) ) ? this.element.getAttribute( 'step' ) : 1; //( props.type === 'decimal' ? 0.1 : 1 );
	        props.vertical = !props.appearances.includes( 'horizontal' );
	        props.ticks = !props.appearances.includes( 'no-ticks' );
	        props.maxTicks = 10;
	        return props;
	    }

	    get value() {
	        return super.value;
	    }

	    set value( value ) {
	        super.value = value;
	    }
	}

	/**
	 * Viewer for image labels that have set a big-image version.
	 */
	class ImageViewer extends Widget {

	    static get selector() {
	        return 'a.or-big-image';
	    }

	    _init() {
	        this.element.addEventListener( 'click', event => {
	            const href = this.element.getAttribute( 'href' );
	            const img = this.element.querySelector( 'img' );
	            const src = img.getAttribute( 'src' );

	            this.element.setAttribute( 'href', src );
	            img.setAttribute( 'src', href );
	            this.element.classList.toggle( 'open' );

	            event.preventDefault();
	            event.stopPropagation();
	        } );
	    }
	}

	/**
	 * Visually transforms a question into a comment modal that can be shown on its linked question.
	 */
	class Comment extends Widget {

	    static get selector() {
	        return '.or-appearance-comment input[type="text"][data-for], .or-appearance-comment textarea[data-for]';
	    }

	    static get helpersRequired() {
	        return [ 'input', 'pathToAbsolute' ];
	    }

	    _init() {
	        this.linkedQuestion = this._getLinkedQuestion( this.element );
	        this.commentQuestion = this.question;

	        if ( this.linkedQuestion ) {
	            // Adding role='comment' is for now only used to make sure that role is not 'page' as that messes things up
	            this.commentQuestion.classList.add( 'hide' );
	            this.commentQuestion.setAttribute( 'role', 'comment' );

	            // Any <button> inside a <label> receives click events if the <label> is clicked!
	            // See http://codepen.io/MartijnR/pen/rWJeOG?editors=1111
	            const fragment = document.createRange().createContextualFragment( '<a class="btn-icon-only btn-comment aria-label="comment" type="button" href="#"><i class="icon"> </i></a>' );
	            const labels = this.linkedQuestion.querySelectorAll( '.question-label' );
	            labels[ labels.length - 1 ].after( fragment );

	            this.commentButton = this.linkedQuestion.querySelector( '.btn-comment' );
	            this._setCommentButtonState( this.originalInputValue );
	            this._setCommentButtonHandler();
	            this._setValidationHandler();
	            this._setFocusHandler();
	        }
	    }

	    _getLinkedQuestion( input ) {
	        const contextPath = this.options.helpers.input.getName( jquery( input ) );
	        const targetPath = this.element.dataset.for.trim();
	        const absoluteTargetPath = this.options.helpers.pathToAbsolute( targetPath, contextPath );
	        // The root is nearest repeat or otherwise nearest form. This avoids having to calculate indices, without
	        // diminishing the flexibility in any meaningful way, 
	        // as it e.g. wouldn't make sense to place a comment node for a top-level question, inside a repeat.
	        const root = input.closest( 'form.or, .or-repeat' );

	        return this.options.helpers.input
	            .getWrapNodes( jquery( root.querySelector( `[name="${absoluteTargetPath}"], [data-name="${absoluteTargetPath}"]` ) ) )[ 0 ];
	    }

	    _commentHasError() {
	        return this.commentQuestion.classList.contains( 'invalid-required' ) || this.commentQuestion.classList.contains( 'invalid-constraint' );
	    }

	    _setCommentButtonState( value, error ) {
	        value = typeof value === 'string' ? value.trim() : value;
	        this.commentButton.classList.toggle( 'empty', !value );
	        this.commentButton.classList.toggle( 'invalid', !!error );
	    }

	    _setCommentButtonHandler() {
	        this.commentButton.addEventListener( 'click', ev => {
	            if ( this._isCommentModalShown( this.linkedQuestion ) ) {
	                this._hideCommentModal( this.linkedQuestion );
	            } else {
	                this._showCommentModal();
	            }
	            ev.preventDefault();
	            ev.stopPropagation();
	        } );
	    }

	    _setValidationHandler() {
	        this.element.closest( 'form.or' ).addEventListener( event.ValidationComplete().type, () => {
	            const error = this._commentHasError();
	            const value = this.originalInputValue;
	            this._setCommentButtonState( value, error );
	        } );
	    }

	    _setFocusHandler() {
	        jquery( this.element ).on( 'applyfocus', () => {
	            if ( this.commentButton.matches( ':visible' ) ) {
	                this.commentButton.click();
	            } else {
	                console.log( `The linked question is not visible. Cannot apply focus to ${this.element.getAttribute( 'name' )}` );
	            }
	        } );
	    }

	    _isCommentModalShown( linkedQuestion ) {
	        return !!linkedQuestion.querySelector( '.or-comment-widget' );
	    }

	    _showCommentModal() {
	        const comment = this.question.cloneNode( true );
	        const updateText = t( 'widget.comment.update' ) || 'Update';
	        const input = comment.querySelector( 'input, textarea' );

	        comment.classList.remove( 'hide' );
	        input.classList.add( 'ignore' );
	        input.removeAttribute( 'name data-for data-type-xml' );

	        const fragment = document.createRange().createContextualFragment(
	            `<section class="widget or-comment-widget">
                <div class="or-comment-widget__content">
                    <button class="btn btn-primary or-comment-widget__content__btn-update" type="button">${updateText}</button>
                    <button class="btn-icon-only or-comment-widget__content__btn-close-x" type="button">&times;</button>
                </div>
            </section>
            `
	        );
	        fragment.querySelector( '.or-comment-widget__content' ).prepend( comment );

	        const overlayFrag = document.createRange().createContextualFragment( '<div class="or-comment-widget__overlay"></div>' );

	        this.linkedQuestion.prepend( fragment );
	        //.find( '.or-comment-widget' ).remove().end()

	        this.linkedQuestion.before( overlayFrag );

	        const overlay = this.linkedQuestion.previousElementSibling;
	        const widget = this.linkedQuestion.querySelector( '.or-comment-widget' );
	        const updateButton = widget.querySelector( '.or-comment-widget__content__btn-update' );
	        const closeButton = widget.querySelector( '.or-comment-widget__content__btn-close-x' );

	        input.focus();
	        widget.scrollIntoView( false );

	        updateButton.addEventListener( 'click', ev => {
	            const value = input.value;
	            this.originalInputValue = value;
	            this.element.dispatchEvent( event.Change() );
	            const error = this._commentHasError();
	            this._setCommentButtonState( value, error );
	            this._hideCommentModal( this.linkedQuestion );
	            /*
	             * Any current error state shown in the linked question will not automatically update.
	             * It only updates when its **own** value changes.
	             * See https://github.com/kobotoolbox/enketo-express/issues/608
	             * Since a linked question and a comment belong so closely together, and likely have 
	             * a `required` or `constraint` dependency, it makes sense to 
	             * separately call a validate method on the linked question to update the error state if necessary.
	             *
	             * Note that with setting "validateContinously" set to "true" this means it will be validated twice.
	             */
	            this.options.helpers.input.validate( jquery( this.linkedQuestion.querySelector( 'input, select, textarea' ) ) );
	            ev.preventDefault();
	            ev.stopPropagation();
	        } );

	        closeButton.addEventListener( 'click', ev => {
	            this._hideCommentModal( this.linkedQuestion );
	            ev.stopPropagation();
	            ev.preventDefault();
	        } );

	        overlay.addEventListener( 'click', ev => {
	            this._hideCommentModal( this.linkedQuestion );
	            ev.stopPropagation();
	            ev.preventDefault();
	        } );
	    }

	    _hideCommentModal( linkedQuestion ) {
	        linkedQuestion.querySelector( '.or-comment-widget' ).remove();
	        const overlay = linkedQuestion.previousElementSibling;
	        if ( overlay && overlay.matches( '.or-comment-widget__overlay' ) ) {
	            overlay.remove();
	        }
	    }
	}

	/**
	 * Image Map widget that turns an SVG image into a clickable map 
	 * by matching radiobutton/checkbox values with id attribute values in the SVG
	 */
	class ImageMap extends Widget {

	    static get selector() {
	        return '.simple-select.or-appearance-image-map label:first-child > input';
	    }

	    _init() {
	        const img = this.question.querySelector( 'img' );
	        this.question.classList.add( 'or-image-map-initialized' );
	        /*
	         * To facilitate Enketo Express' offline webforms,
	         * where the img source is populated after form loading, we initialize upon image load
	         * if the src attribute is not yet populated.
	         *
	         * We could use the same with online-only forms, but that would cause a loading delay.
	         */

	        if ( !img ) {
	            this._showSvgNotFoundError();
	        } else if ( img.getAttribute( 'src' ) ) {
	            // return a promise, resolving with instance for asynchronous initialization
	            return this._addMarkup( img )
	                .then( this._addFunctionality.bind( this ) )
	                .then( () => this );
	        } else {
	            return new Promise( resolve => {
	                img.addEventListener( 'load', () => {
	                    this._addMarkup( img ).then( this._addFunctionality.bind( this ) );
	                    resolve( this );
	                } );
	            } );
	            // Ignore errors, because an img element without source may throw one.
	            // E.g. in Enketo Express inside a repeat: https://github.com/kobotoolbox/enketo-express/issues/961
	        }
	    }

	    _addFunctionality( widget ) {
	        this.svg = widget.querySelector( 'svg' );
	        this.tooltip = widget.querySelector( '.image-map__ui__tooltip' );
	        if ( this.props.readonly ) {
	            this.disable();
	        }
	        this._setSvgClickHandler();
	        this._setChangeHandler();
	        this._setHoverHandler();
	        this._updateImage();
	    }

	    _addMarkup( img ) {
	        const that = this;
	        const src = img.getAttribute( 'src' );

	        /**
	         * For translated forms, we now discard everything except the first image,
	         * since we're assuming the images will be the same in all languages.
	         */
	        return fetch( src )
	            .then( response => response.text() )
	            .then( txt => ( new DOMParser() ).parseFromString( txt, 'text/xml' ) )
	            .then( doc => {
	                if ( that._isSvgDoc( doc ) ) {
	                    const svgFragment = that._removeUnmatchedIds( doc.querySelector( 'svg' ) );
	                    const fragment = document.createRange().createContextualFragment(
	                        `<div class="widget image-map">
                            <div class="image-map__ui">
                                <span class="image-map__ui__tooltip"></span>
                            </div>
                        </div>`
	                    );
	                    fragment.querySelector( '.widget' ).append( svgFragment );

	                    // remove images in all languages
	                    that.question.querySelectorAll( 'img' ).forEach( el => el.remove() );
	                    that.question.querySelector( '.option-wrapper' ).before( fragment );
	                    const widget = that.question.querySelector( '.image-map' );
	                    const svg = widget.querySelector( 'svg' );
	                    // Resize, using original unscaled SVG dimensions
	                    // svg.getBBox() only works after SVG has been added to DOM.
	                    // In FF getBBox causes an "NS_ERROR_FAILURE" exception likely because the SVG
	                    // image has not finished rendering. This doesn't always happen though.
	                    // For now, we just log the FF error, and hope that resizing is done correctly via
	                    // attributes.
	                    let bbox = {};
	                    try {
	                        bbox = svg.getBBox();
	                    } catch ( e ) {
	                        console.error( 'Could not obtain Boundary Box of SVG element', e );
	                    }

	                    const width = bbox.width || svg.getAttribute( 'width' );
	                    const height = bbox.height || svg.getAttribute( 'height' );
	                    svg.setAttribute( 'viewBox', [ 0, 0, parseInt( width, 10 ), parseInt( height, 10 ) ].join( ' ' ) );
	                    return widget;
	                } else {
	                    throw ( 'Image is not an SVG doc' );
	                }
	            } )
	            .catch( this._showSvgNotFoundError.bind( that ) );
	    }

	    _showSvgNotFoundError( err ) {
	        console.error( err );
	        const fragment = document.createRange().createContextualFragment(
	            `<div class="widget image-map">
                <div class="image-map__error">${t( 'imagemap.svgNotFound' )}</div>
            </div>`
	        );
	        this.question.querySelector( '.option-wrapper' ).before( fragment );
	    }

	    /**
	     * Removes id attributes from unmatched path elements in order to prevent hover effect (and click listener).
	     * 
	     * @return {jQuery} [description]
	     */
	    _removeUnmatchedIds( svg ) {
	        svg.querySelectorAll( 'path[id], g[id]' ).forEach( el => {
	            if ( !this._getInput( el.id ) ) {
	                el.removeAttribute( 'id' );
	            }
	        } );

	        return svg;
	    }

	    _getInput( id ) {
	        return this.question.querySelector( `input[value="${id}"]` );
	    }

	    _setSvgClickHandler() {
	        this.svg.addEventListener( 'click', ev => {
	            if ( !ev.target.closest( 'svg' ).matches( '[or-readonly]' ) && ev.target.matches( 'path[id], g[id]' ) ) {
	                const id = ev.target.id || ev.target.closest( 'g[id]' ).id;
	                const input = this._getInput( id );
	                if ( input ) {
	                    input.checked = !input.checked;
	                    input.dispatchEvent( event.Change() );
	                    input.dispatchEvent( event.FakeFocus() );
	                }
	            }
	        } );
	    }

	    _setChangeHandler() {
	        this.question.addEventListener( 'change', this._updateImage.bind( this ) );
	    }

	    _setHoverHandler() {
	        this.svg.querySelectorAll( 'path[id], g[id]' ).forEach( el => {
	            el.addEventListener( 'mouseenter', ev => {
	                const id = ev.target.id || ev.target.closest( 'g[id]' ).id;
	                const labels = getSiblingElements( this._getInput( id ), '.option-label.active' );
	                const optionLabel = labels && labels.length ? labels[ 0 ].textContent : '';
	                this.tooltip.textContent = optionLabel;
	            } );
	            el.addEventListener( 'mouseleave', ev => {
	                if ( ev.target.matches( 'path[id], g[id]' ) ) {
	                    this.tooltip.textContent = '';
	                }
	            } );
	        } );
	    }

	    _isSvgDoc( data ) {
	        return typeof data === 'object' && data.querySelector( 'svg' );
	    }

	    /**
	     * Updates 'selected' attributes in SVG
	     * Always update the map after the value has changed in the original input elements
	     */
	    _updateImage() {
	        let values = this.originalInputValue;
	        this.svg.querySelectorAll( 'path[or-selected], g[or-selected]' ).forEach( el => el.removeAttribute( 'or-selected' ) );

	        if ( typeof values === 'string' ) {
	            values = [ values ];
	        }

	        values.forEach( value => {
	            if ( value ) {
	                // if multiple values have the same id, change all of them (e.g. a province that is not contiguous)
	                this.svg.querySelectorAll( `path#${value},g#${value}` ).forEach( el => el.setAttribute( 'or-selected', '' ) );
	            }
	        } );
	    }

	    disable() {
	        this.svg.setAttribute( 'or-readonly', '' );
	    }

	    enable() {
	        this.svg.removeAttribute( 'or-readonly' );
	    }

	    update() {
	        this._updateImage();
	    }

	    get value() {
	        // This widget is unusual. It would better to get the value from the map.
	        return this.originalInputValue;
	    }

	    set value( value ) {
	        // This widget is unusual. It would more consistent to set the value in the map perhaps.
	        this.originalInputValue = value;
	    }
	}

	/*
	 * HTML5Sortable package
	 * https://github.com/lukasoppermann/html5sortable
	 *
	 * Maintained by Lukas Oppermann <lukas@vea.re>
	 *
	 * Released under the MIT license.
	 */

	/**
	 * Get or set data on element
	 * @param {HTMLElement} element
	 * @param {string} key
	 * @param {any} value
	 * @return {*}
	 */
	function addData(element, key, value) {
	    if (value === undefined) {
	        return element && element.h5s && element.h5s.data && element.h5s.data[key];
	    }
	    else {
	        element.h5s = element.h5s || {};
	        element.h5s.data = element.h5s.data || {};
	        element.h5s.data[key] = value;
	    }
	}
	/**
	 * Remove data from element
	 * @param {HTMLElement} element
	 */
	function removeData(element) {
	    if (element.h5s) {
	        delete element.h5s.data;
	    }
	}

	function _filter (nodes, selector) {
	    if (!(nodes instanceof NodeList || nodes instanceof HTMLCollection || nodes instanceof Array)) {
	        throw new Error('You must provide a nodeList/HTMLCollection/Array of elements to be filtered.');
	    }
	    if (typeof selector !== 'string') {
	        return Array.from(nodes);
	    }
	    return Array.from(nodes).filter(function (item) { return item.nodeType === 1 && item.matches(selector); });
	}

	/* eslint-env browser */
	var stores = new Map();
	/**
	 * Stores data & configurations per Sortable
	 * @param {Object} config
	 */
	var Store = (function () {
	    function Store() {
	        this._config = new Map(); // eslint-disable-line no-undef
	        this._placeholder = undefined; // eslint-disable-line no-undef
	        this._data = new Map(); // eslint-disable-line no-undef
	    }
	    Object.defineProperty(Store.prototype, "config", {
	        /**
	         * get the configuration map of a class instance
	         * @method config
	         * @return {object}
	         */
	        get: function () {
	            // transform Map to object
	            var config = {};
	            this._config.forEach(function (value, key) {
	                config[key] = value;
	            });
	            // return object
	            return config;
	        },
	        /**
	         * set the configuration of a class instance
	         * @method config
	         * @param {object} config object of configurations
	         */
	        set: function (config) {
	            if (typeof config !== 'object') {
	                throw new Error('You must provide a valid configuration object to the config setter.');
	            }
	            // combine config with default
	            var mergedConfig = Object.assign({}, config);
	            // add config to map
	            this._config = new Map(Object.entries(mergedConfig));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * set individual configuration of a class instance
	     * @method setConfig
	     * @param  key valid configuration key
	     * @param  value any value
	     * @return void
	     */
	    Store.prototype.setConfig = function (key, value) {
	        if (!this._config.has(key)) {
	            throw new Error("Trying to set invalid configuration item: " + key);
	        }
	        // set config
	        this._config.set(key, value);
	    };
	    /**
	     * get an individual configuration of a class instance
	     * @method getConfig
	     * @param  key valid configuration key
	     * @return any configuration value
	     */
	    Store.prototype.getConfig = function (key) {
	        if (!this._config.has(key)) {
	            throw new Error("Invalid configuration item requested: " + key);
	        }
	        return this._config.get(key);
	    };
	    Object.defineProperty(Store.prototype, "placeholder", {
	        /**
	         * get the placeholder for a class instance
	         * @method placeholder
	         * @return {HTMLElement|null}
	         */
	        get: function () {
	            return this._placeholder;
	        },
	        /**
	         * set the placeholder for a class instance
	         * @method placeholder
	         * @param {HTMLElement} placeholder
	         * @return {void}
	         */
	        set: function (placeholder) {
	            if (!(placeholder instanceof HTMLElement) && placeholder !== null) {
	                throw new Error('A placeholder must be an html element or null.');
	            }
	            this._placeholder = placeholder;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * set an data entry
	     * @method setData
	     * @param {string} key
	     * @param {any} value
	     * @return {void}
	     */
	    Store.prototype.setData = function (key, value) {
	        if (typeof key !== 'string') {
	            throw new Error("The key must be a string.");
	        }
	        this._data.set(key, value);
	    };
	    /**
	     * get an data entry
	     * @method getData
	     * @param {string} key an existing key
	     * @return {any}
	     */
	    Store.prototype.getData = function (key) {
	        if (typeof key !== 'string') {
	            throw new Error("The key must be a string.");
	        }
	        return this._data.get(key);
	    };
	    /**
	     * delete an data entry
	     * @method deleteData
	     * @param {string} key an existing key
	     * @return {boolean}
	     */
	    Store.prototype.deleteData = function (key) {
	        if (typeof key !== 'string') {
	            throw new Error("The key must be a string.");
	        }
	        return this._data.delete(key);
	    };
	    return Store;
	}());
	function store (sortableElement) {
	    // if sortableElement is wrong type
	    if (!(sortableElement instanceof HTMLElement)) {
	        throw new Error('Please provide a sortable to the store function.');
	    }
	    // create new instance if not avilable
	    if (!stores.has(sortableElement)) {
	        stores.set(sortableElement, new Store());
	    }
	    // return instance
	    return stores.get(sortableElement);
	}

	/**
	 * @param {Array|HTMLElement} element
	 * @param {Function} callback
	 * @param {string} event
	 */
	function addEventListener(element, eventName, callback) {
	    if (element instanceof Array) {
	        for (var i = 0; i < element.length; ++i) {
	            addEventListener(element[i], eventName, callback);
	        }
	        return;
	    }
	    element.addEventListener(eventName, callback);
	    store(element).setData("event" + eventName, callback);
	}
	/**
	 * @param {Array<HTMLElement>|HTMLElement} element
	 * @param {string} eventName
	 */
	function removeEventListener(element, eventName) {
	    if (element instanceof Array) {
	        for (var i = 0; i < element.length; ++i) {
	            removeEventListener(element[i], eventName);
	        }
	        return;
	    }
	    element.removeEventListener(eventName, store(element).getData("event" + eventName));
	    store(element).deleteData("event" + eventName);
	}

	/**
	 * @param {Array<HTMLElement>|HTMLElement} element
	 * @param {string} attribute
	 * @param {string} value
	 */
	function addAttribute(element, attribute, value) {
	    if (element instanceof Array) {
	        for (var i = 0; i < element.length; ++i) {
	            addAttribute(element[i], attribute, value);
	        }
	        return;
	    }
	    element.setAttribute(attribute, value);
	}
	/**
	 * @param {Array|HTMLElement} element
	 * @param {string} attribute
	 */
	function removeAttribute(element, attribute) {
	    if (element instanceof Array) {
	        for (var i = 0; i < element.length; ++i) {
	            removeAttribute(element[i], attribute);
	        }
	        return;
	    }
	    element.removeAttribute(attribute);
	}

	function offset (element) {
	    if (!element.parentElement || element.getClientRects().length === 0) {
	        throw new Error('target element must be part of the dom');
	    }
	    var rect = element.getClientRects()[0];
	    return {
	        left: rect.left + window.pageXOffset,
	        right: rect.right + window.pageXOffset,
	        top: rect.top + window.pageYOffset,
	        bottom: rect.bottom + window.pageYOffset
	    };
	}

	function _debounce (func, wait) {
	    if (wait === void 0) { wait = 0; }
	    var timeout;
	    return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        clearTimeout(timeout);
	        timeout = setTimeout(function () {
	            func.apply(void 0, args);
	        }, wait);
	    };
	}

	function index (element, elementList) {
	    if (!(element instanceof HTMLElement) || !(elementList instanceof NodeList || elementList instanceof HTMLCollection || elementList instanceof Array)) {
	        throw new Error('You must provide an element and a list of elements.');
	    }
	    return Array.from(elementList).indexOf(element);
	}

	function isInDom (element) {
	    if (!(element instanceof HTMLElement)) {
	        throw new Error('Element is not a node element.');
	    }
	    return element.parentNode !== null;
	}

	/* eslint-env browser */
	/**
	 * Insert node before or after target
	 * @param {HTMLElement} referenceNode - reference element
	 * @param {HTMLElement} newElement - element to be inserted
	 * @param {String} position - insert before or after reference element
	 */
	var insertNode = function (referenceNode, newElement, position) {
	    if (!(referenceNode instanceof HTMLElement) || !(referenceNode.parentElement instanceof HTMLElement)) {
	        throw new Error('target and element must be a node');
	    }
	    referenceNode.parentElement.insertBefore(newElement, (position === 'before' ? referenceNode : referenceNode.nextElementSibling));
	};
	/**
	 * Insert before target
	 * @param {HTMLElement} target
	 * @param {HTMLElement} element
	 */
	var insertBefore = function (target, element) { return insertNode(target, element, 'before'); };
	/**
	 * Insert after target
	 * @param {HTMLElement} target
	 * @param {HTMLElement} element
	 */
	var insertAfter = function (target, element) { return insertNode(target, element, 'after'); };

	function _serialize (sortableContainer, customItemSerializer, customContainerSerializer) {
	    if (customItemSerializer === void 0) { customItemSerializer = function (serializedItem, sortableContainer) { return serializedItem; }; }
	    if (customContainerSerializer === void 0) { customContainerSerializer = function (serializedContainer) { return serializedContainer; }; }
	    // check for valid sortableContainer
	    if (!(sortableContainer instanceof HTMLElement) || !sortableContainer.isSortable === true) {
	        throw new Error('You need to provide a sortableContainer to be serialized.');
	    }
	    // check for valid serializers
	    if (typeof customItemSerializer !== 'function' || typeof customContainerSerializer !== 'function') {
	        throw new Error('You need to provide a valid serializer for items and the container.');
	    }
	    // get options
	    var options = addData(sortableContainer, 'opts');
	    var item = options.items;
	    // serialize container
	    var items = _filter(sortableContainer.children, item);
	    var serializedItems = items.map(function (item) {
	        return {
	            parent: sortableContainer,
	            node: item,
	            html: item.outerHTML,
	            index: index(item, items)
	        };
	    });
	    // serialize container
	    var container = {
	        node: sortableContainer,
	        itemCount: serializedItems.length
	    };
	    return {
	        container: customContainerSerializer(container),
	        items: serializedItems.map(function (item) { return customItemSerializer(item, sortableContainer); })
	    };
	}

	function _makePlaceholder (sortableElement, placeholder, placeholderClass) {
	    if (placeholderClass === void 0) { placeholderClass = 'sortable-placeholder'; }
	    if (!(sortableElement instanceof HTMLElement)) {
	        throw new Error('You must provide a valid element as a sortable.');
	    }
	    // if placeholder is not an element
	    if (!(placeholder instanceof HTMLElement) && placeholder !== undefined) {
	        throw new Error('You must provide a valid element as a placeholder or set ot to undefined.');
	    }
	    // if no placeholder element is given
	    if (placeholder === undefined) {
	        if (['UL', 'OL'].includes(sortableElement.tagName)) {
	            placeholder = document.createElement('li');
	        }
	        else if (['TABLE', 'TBODY'].includes(sortableElement.tagName)) {
	            placeholder = document.createElement('tr');
	            // set colspan to always all rows, otherwise the item can only be dropped in first column
	            placeholder.innerHTML = '<td colspan="100"></td>';
	        }
	        else {
	            placeholder = document.createElement('div');
	        }
	    }
	    // add classes to placeholder
	    if (typeof placeholderClass === 'string') {
	        (_a = placeholder.classList).add.apply(_a, placeholderClass.split(' '));
	    }
	    return placeholder;
	    var _a;
	}

	function _getElementHeight (element) {
	    if (!(element instanceof HTMLElement)) {
	        throw new Error('You must provide a valid dom element');
	    }
	    // get calculated style of element
	    var style = window.getComputedStyle(element);
	    // pick applicable properties, convert to int and reduce by adding
	    return ['height', 'padding-top', 'padding-bottom']
	        .map(function (key) {
	        var int = parseInt(style.getPropertyValue(key), 10);
	        return isNaN(int) ? 0 : int;
	    })
	        .reduce(function (sum, value) { return sum + value; });
	}

	/* eslint-env browser */
	/**
	 * get handle or return item
	 * @param {Array<HTMLElement>} items
	 * @param {string} selector
	 */
	function _getHandles (items, selector) {
	    if (!(items instanceof Array)) {
	        throw new Error('You must provide a Array of HTMLElements to be filtered.');
	    }
	    if (typeof selector !== 'string') {
	        return items;
	    }
	    return items
	        .filter(function (item) {
	        return item.querySelector(selector) instanceof HTMLElement ||
	            (item.shadowRoot && item.shadowRoot.querySelector(selector) instanceof HTMLElement);
	    })
	        .map(function (item) {
	        return item.querySelector(selector) || (item.shadowRoot && item.shadowRoot.querySelector(selector));
	    });
	}

	function getEventTarget (event) {
	    return (event.composedPath && event.composedPath()[0]) || event.target;
	}

	/**
	 * defaultDragImage returns the current item as dragged image
	 * @param {HTMLElement} draggedElement - the item that the user drags
	 * @param {object} elementOffset - an object with the offsets top, left, right & bottom
	 * @param {Event} event - the original drag event object
	 * @return {object} with element, posX and posY properties
	 */
	var defaultDragImage = function (draggedElement, elementOffset, event) {
	    return {
	        element: draggedElement,
	        posX: event.pageX - elementOffset.left,
	        posY: event.pageY - elementOffset.top
	    };
	};
	function setDragImage (event, draggedElement, customDragImage) {
	    // check if event is provided
	    if (!(event instanceof Event)) {
	        throw new Error('setDragImage requires a DragEvent as the first argument.');
	    }
	    // check if draggedElement is provided
	    if (!(draggedElement instanceof HTMLElement)) {
	        throw new Error('setDragImage requires the dragged element as the second argument.');
	    }
	    // set default function of none provided
	    if (!customDragImage) {
	        customDragImage = defaultDragImage;
	    }
	    // check if setDragImage method is available
	    if (event.dataTransfer && event.dataTransfer.setDragImage) {
	        // get the elements offset
	        var elementOffset = offset(draggedElement);
	        // get the dragImage
	        var dragImage = customDragImage(draggedElement, elementOffset, event);
	        // check if custom function returns correct values
	        if (!(dragImage.element instanceof HTMLElement) || typeof dragImage.posX !== 'number' || typeof dragImage.posY !== 'number') {
	            throw new Error('The customDragImage function you provided must return and object with the properties element[string], posX[integer], posY[integer].');
	        }
	        // needs to be set for HTML5 drag & drop to work
	        event.dataTransfer.effectAllowed = 'copyMove';
	        // Firefox requires it to use the event target's id for the data
	        event.dataTransfer.setData('text/plain', getEventTarget(event).id);
	        // set the drag image on the event
	        event.dataTransfer.setDragImage(dragImage.element, dragImage.posX, dragImage.posY);
	    }
	}

	function _listsConnected (destination, origin) {
	    // check if valid sortable
	    if (destination.isSortable === true) {
	        var acceptFrom = store(destination).getConfig('acceptFrom');
	        // check if acceptFrom is valid
	        if (acceptFrom !== null && acceptFrom !== false && typeof acceptFrom !== 'string') {
	            throw new Error('HTML5Sortable: Wrong argument, "acceptFrom" must be "null", "false", or a valid selector string.');
	        }
	        if (acceptFrom !== null) {
	            return acceptFrom !== false && acceptFrom.split(',').filter(function (sel) {
	                return sel.length > 0 && origin.matches(sel);
	            }).length > 0;
	        }
	        // drop in same list
	        if (destination === origin) {
	            return true;
	        }
	        // check if lists are connected with connectWith
	        if (store(destination).getConfig('connectWith') !== undefined && store(destination).getConfig('connectWith') !== null) {
	            return store(destination).getConfig('connectWith') === store(origin).getConfig('connectWith');
	        }
	    }
	    return false;
	}

	var defaultConfiguration = {
	    items: null,
	    // deprecated
	    connectWith: null,
	    // deprecated
	    disableIEFix: null,
	    acceptFrom: null,
	    copy: false,
	    placeholder: null,
	    placeholderClass: 'sortable-placeholder',
	    draggingClass: 'sortable-dragging',
	    hoverClass: false,
	    debounce: 0,
	    throttleTime: 100,
	    maxItems: 0,
	    itemSerializer: undefined,
	    containerSerializer: undefined,
	    customDragImage: null
	};

	/**
	 * make sure a function is only called once within the given amount of time
	 * @param {Function} fn the function to throttle
	 * @param {number} threshold time limit for throttling
	 */
	// must use function to keep this context
	function _throttle (fn, threshold) {
	    var _this = this;
	    if (threshold === void 0) { threshold = 250; }
	    // check function
	    if (typeof fn !== 'function') {
	        throw new Error('You must provide a function as the first argument for throttle.');
	    }
	    // check threshold
	    if (typeof threshold !== 'number') {
	        throw new Error('You must provide a number as the second argument for throttle.');
	    }
	    var lastEventTimestamp = null;
	    return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var now = Date.now();
	        if (lastEventTimestamp === null || now - lastEventTimestamp >= threshold) {
	            lastEventTimestamp = now;
	            fn.apply(_this, args);
	        }
	    };
	}

	function enableHoverClass (sortableContainer, enable) {
	    if (typeof store(sortableContainer).getConfig('hoverClass') === 'string') {
	        var hoverClasses_1 = store(sortableContainer).getConfig('hoverClass').split(' ');
	        // add class on hover
	        if (enable === true) {
	            addEventListener(sortableContainer, 'mousemove', _throttle(function (event) {
	                // check of no mouse button was pressed when mousemove started == no drag
	                if (event.buttons === 0) {
	                    _filter(sortableContainer.children, store(sortableContainer).getConfig('items')).forEach(function (item) {
	                        if (item !== event.target) {
	                            (_a = item.classList).remove.apply(_a, hoverClasses_1);
	                        }
	                        else {
	                            (_b = item.classList).add.apply(_b, hoverClasses_1);
	                        }
	                        var _a, _b;
	                    });
	                }
	            }, store(sortableContainer).getConfig('throttleTime')));
	            // remove class on leave
	            addEventListener(sortableContainer, 'mouseleave', function () {
	                _filter(sortableContainer.children, store(sortableContainer).getConfig('items')).forEach(function (item) {
	                    (_a = item.classList).remove.apply(_a, hoverClasses_1);
	                    var _a;
	                });
	            });
	        }
	        else {
	            removeEventListener(sortableContainer, 'mousemove');
	            removeEventListener(sortableContainer, 'mouseleave');
	        }
	    }
	}

	/* eslint-env browser */
	/*
	 * variables global to the plugin
	 */
	var dragging;
	var draggingHeight;
	/*
	 * Keeps track of the initialy selected list, where 'dragstart' event was triggered
	 * It allows us to move the data in between individual Sortable List instances
	 */
	// Origin List - data from before any item was changed
	var originContainer;
	var originIndex;
	var originElementIndex;
	var originItemsBeforeUpdate;
	// Previous Sortable Container - we dispatch as sortenter event when a
	// dragged item enters a sortableContainer for the first time
	var previousContainer;
	// Destination List - data from before any item was changed
	var destinationItemsBeforeUpdate;
	/**
	 * remove event handlers from items
	 * @param {Array|NodeList} items
	 */
	var _removeItemEvents = function (items) {
	    removeEventListener(items, 'dragstart');
	    removeEventListener(items, 'dragend');
	    removeEventListener(items, 'dragover');
	    removeEventListener(items, 'dragenter');
	    removeEventListener(items, 'drop');
	    removeEventListener(items, 'mouseenter');
	    removeEventListener(items, 'mouseleave');
	};
	/**
	 * _getDragging returns the current element to drag or
	 * a copy of the element.
	 * Is Copy Active for sortable
	 * @param {HTMLElement} draggedItem - the item that the user drags
	 * @param {HTMLElement} sortable a single sortable
	 */
	var _getDragging = function (draggedItem, sortable) {
	    var ditem = draggedItem;
	    if (store(sortable).getConfig('copy') === true) {
	        ditem = draggedItem.cloneNode(true);
	        addAttribute(ditem, 'aria-copied', 'true');
	        draggedItem.parentElement.appendChild(ditem);
	        ditem.style.display = 'none';
	        ditem.oldDisplay = draggedItem.style.display;
	    }
	    return ditem;
	};
	/**
	 * Remove data from sortable
	 * @param {HTMLElement} sortable a single sortable
	 */
	var _removeSortableData = function (sortable) {
	    removeData(sortable);
	    removeAttribute(sortable, 'aria-dropeffect');
	};
	/**
	 * Remove data from items
	 * @param {Array<HTMLElement>|HTMLElement} items
	 */
	var _removeItemData = function (items) {
	    removeAttribute(items, 'aria-grabbed');
	    removeAttribute(items, 'aria-copied');
	    removeAttribute(items, 'draggable');
	    removeAttribute(items, 'role');
	};
	/**
	 * find sortable from element. travels up parent element until found or null.
	 * @param {HTMLElement} element a single sortable
	 * @param {Event} event - the current event. We need to pass it to be able to
	 * find Sortable whith shadowRoot (document fragment has no parent)
	 */
	function findSortable(element, event) {
	    if (event.composedPath) {
	        return event.composedPath().find(function (el) { return el.isSortable; });
	    }
	    while (element.isSortable !== true) {
	        element = element.parentElement;
	    }
	    return element;
	}
	/**
	 * Dragging event is on the sortable element. finds the top child that
	 * contains the element.
	 * @param {HTMLElement} sortableElement a single sortable
	 * @param {HTMLElement} element is that being dragged
	 */
	function findDragElement(sortableElement, element) {
	    var options = addData(sortableElement, 'opts');
	    var items = _filter(sortableElement.children, options.items);
	    var itemlist = items.filter(function (ele) {
	        return ele.contains(element) || (ele.shadowRoot && ele.shadowRoot.contains(element));
	    });
	    return itemlist.length > 0 ? itemlist[0] : element;
	}
	/**
	 * Destroy the sortable
	 * @param {HTMLElement} sortableElement a single sortable
	 */
	var _destroySortable = function (sortableElement) {
	    var opts = addData(sortableElement, 'opts') || {};
	    var items = _filter(sortableElement.children, opts.items);
	    var handles = _getHandles(items, opts.handle);
	    // remove event handlers & data from sortable
	    removeEventListener(sortableElement, 'dragover');
	    removeEventListener(sortableElement, 'dragenter');
	    removeEventListener(sortableElement, 'drop');
	    // remove event data from sortable
	    _removeSortableData(sortableElement);
	    // remove event handlers & data from items
	    removeEventListener(handles, 'mousedown');
	    _removeItemEvents(items);
	    _removeItemData(items);
	};
	/**
	 * Enable the sortable
	 * @param {HTMLElement} sortableElement a single sortable
	 */
	var _enableSortable = function (sortableElement) {
	    var opts = addData(sortableElement, 'opts');
	    var items = _filter(sortableElement.children, opts.items);
	    var handles = _getHandles(items, opts.handle);
	    addAttribute(sortableElement, 'aria-dropeffect', 'move');
	    addData(sortableElement, '_disabled', 'false');
	    addAttribute(handles, 'draggable', 'true');
	    // @todo: remove this fix
	    // IE FIX for ghost
	    // can be disabled as it has the side effect that other events
	    // (e.g. click) will be ignored
	    if (opts.disableIEFix === false) {
	        var spanEl = (document || window.document).createElement('span');
	        if (typeof spanEl.dragDrop === 'function') {
	            addEventListener(handles, 'mousedown', function () {
	                if (items.indexOf(this) !== -1) {
	                    this.dragDrop();
	                }
	                else {
	                    var parent = this.parentElement;
	                    while (items.indexOf(parent) === -1) {
	                        parent = parent.parentElement;
	                    }
	                    parent.dragDrop();
	                }
	            });
	        }
	    }
	};
	/**
	 * Disable the sortable
	 * @param {HTMLElement} sortableElement a single sortable
	 */
	var _disableSortable = function (sortableElement) {
	    var opts = addData(sortableElement, 'opts');
	    var items = _filter(sortableElement.children, opts.items);
	    var handles = _getHandles(items, opts.handle);
	    addAttribute(sortableElement, 'aria-dropeffect', 'none');
	    addData(sortableElement, '_disabled', 'true');
	    addAttribute(handles, 'draggable', 'false');
	    removeEventListener(handles, 'mousedown');
	};
	/**
	 * Reload the sortable
	 * @param {HTMLElement} sortableElement a single sortable
	 * @description events need to be removed to not be double bound
	 */
	var _reloadSortable = function (sortableElement) {
	    var opts = addData(sortableElement, 'opts');
	    var items = _filter(sortableElement.children, opts.items);
	    var handles = _getHandles(items, opts.handle);
	    addData(sortableElement, '_disabled', 'false');
	    // remove event handlers from items
	    _removeItemEvents(items);
	    removeEventListener(handles, 'mousedown');
	    // remove event handlers from sortable
	    removeEventListener(sortableElement, 'dragover');
	    removeEventListener(sortableElement, 'dragenter');
	    removeEventListener(sortableElement, 'drop');
	};
	/**
	 * Public sortable object
	 * @param {Array|NodeList} sortableElements
	 * @param {object|string} options|method
	 */
	function sortable(sortableElements, options) {
	    // get method string to see if a method is called
	    var method = String(options);
	    options = options || {};
	    // check if the user provided a selector instead of an element
	    if (typeof sortableElements === 'string') {
	        sortableElements = document.querySelectorAll(sortableElements);
	    }
	    // if the user provided an element, return it in an array to keep the return value consistant
	    if (sortableElements instanceof HTMLElement) {
	        sortableElements = [sortableElements];
	    }
	    sortableElements = Array.prototype.slice.call(sortableElements);
	    if (/serialize/.test(method)) {
	        return sortableElements.map(function (sortableContainer) {
	            var opts = addData(sortableContainer, 'opts');
	            return _serialize(sortableContainer, opts.itemSerializer, opts.containerSerializer);
	        });
	    }
	    sortableElements.forEach(function (sortableElement) {
	        if (/enable|disable|destroy/.test(method)) {
	            return sortable[method](sortableElement);
	        }
	        // log deprecation
	        ['connectWith', 'disableIEFix'].forEach(function (configKey) {
	            if (options.hasOwnProperty(configKey) && options[configKey] !== null) {
	                console.warn("HTML5Sortable: You are using the deprecated configuration \"" + configKey + "\". This will be removed in an upcoming version, make sure to migrate to the new options when updating.");
	            }
	        });
	        // merge options with default options
	        options = Object.assign({}, defaultConfiguration, store(sortableElement).config, options);
	        // init data store for sortable
	        store(sortableElement).config = options;
	        // set options on sortable
	        addData(sortableElement, 'opts', options);
	        // property to define as sortable
	        sortableElement.isSortable = true;
	        // reset sortable
	        _reloadSortable(sortableElement);
	        // initialize
	        var listItems = _filter(sortableElement.children, options.items);
	        // create element if user defined a placeholder element as a string
	        var customPlaceholder;
	        if (options.placeholder !== null && options.placeholder !== undefined) {
	            var tempContainer = document.createElement(sortableElement.tagName);
	            if (options.placeholder instanceof HTMLElement) {
	                tempContainer.appendChild(options.placeholder);
	            }
	            else {
	                tempContainer.innerHTML = options.placeholder;
	            }
	            customPlaceholder = tempContainer.children[0];
	        }
	        // add placeholder
	        store(sortableElement).placeholder = _makePlaceholder(sortableElement, customPlaceholder, options.placeholderClass);
	        addData(sortableElement, 'items', options.items);
	        if (options.acceptFrom) {
	            addData(sortableElement, 'acceptFrom', options.acceptFrom);
	        }
	        else if (options.connectWith) {
	            addData(sortableElement, 'connectWith', options.connectWith);
	        }
	        _enableSortable(sortableElement);
	        addAttribute(listItems, 'role', 'option');
	        addAttribute(listItems, 'aria-grabbed', 'false');
	        // enable hover class
	        enableHoverClass(sortableElement, true);
	        /*
	         Handle drag events on draggable items
	         Handle is set at the sortableElement level as it will bubble up
	         from the item
	         */
	        addEventListener(sortableElement, 'dragstart', function (e) {
	            // ignore dragstart events
	            var target = getEventTarget(e);
	            if (target.isSortable === true) {
	                return;
	            }
	            e.stopImmediatePropagation();
	            if ((options.handle && !target.matches(options.handle)) || target.getAttribute('draggable') === 'false') {
	                return;
	            }
	            var sortableContainer = findSortable(target, e);
	            var dragItem = findDragElement(sortableContainer, target);
	            // grab values
	            originItemsBeforeUpdate = _filter(sortableContainer.children, options.items);
	            originIndex = originItemsBeforeUpdate.indexOf(dragItem);
	            originElementIndex = index(dragItem, sortableContainer.children);
	            originContainer = sortableContainer;
	            // add transparent clone or other ghost to cursor
	            setDragImage(e, dragItem, options.customDragImage);
	            // cache selsection & add attr for dragging
	            draggingHeight = _getElementHeight(dragItem);
	            dragItem.classList.add(options.draggingClass);
	            dragging = _getDragging(dragItem, sortableContainer);
	            addAttribute(dragging, 'aria-grabbed', 'true');
	            // dispatch sortstart event on each element in group
	            sortableContainer.dispatchEvent(new CustomEvent('sortstart', {
	                detail: {
	                    origin: {
	                        elementIndex: originElementIndex,
	                        index: originIndex,
	                        container: originContainer
	                    },
	                    item: dragging,
	                    originalTarget: target
	                }
	            }));
	        });
	        /*
	         We are capturing targetSortable before modifications with 'dragenter' event
	        */
	        addEventListener(sortableElement, 'dragenter', function (e) {
	            var target = getEventTarget(e);
	            var sortableContainer = findSortable(target, e);
	            if (sortableContainer && sortableContainer !== previousContainer) {
	                destinationItemsBeforeUpdate = _filter(sortableContainer.children, addData(sortableContainer, 'items'))
	                    .filter(function (item) { return item !== store(sortableElement).placeholder; });
	                sortableContainer.dispatchEvent(new CustomEvent('sortenter', {
	                    detail: {
	                        origin: {
	                            elementIndex: originElementIndex,
	                            index: originIndex,
	                            container: originContainer
	                        },
	                        destination: {
	                            container: sortableContainer,
	                            itemsBeforeUpdate: destinationItemsBeforeUpdate
	                        },
	                        item: dragging,
	                        originalTarget: target
	                    }
	                }));
	            }
	            previousContainer = sortableContainer;
	        });
	        /*
	         * Dragend Event - https://developer.mozilla.org/en-US/docs/Web/Events/dragend
	         * Fires each time dragEvent end, or ESC pressed
	         * We are using it to clean up any draggable elements and placeholders
	         */
	        addEventListener(sortableElement, 'dragend', function (e) {
	            if (!dragging) {
	                return;
	            }
	            dragging.classList.remove(options.draggingClass);
	            addAttribute(dragging, 'aria-grabbed', 'false');
	            if (dragging.getAttribute('aria-copied') === 'true' && addData(dragging, 'dropped') !== 'true') {
	                dragging.remove();
	            }
	            dragging.style.display = dragging.oldDisplay;
	            delete dragging.oldDisplay;
	            var visiblePlaceholder = Array.from(stores.values()).map(function (data) { return data.placeholder; })
	                .filter(function (placeholder) { return placeholder instanceof HTMLElement; })
	                .filter(isInDom)[0];
	            if (visiblePlaceholder) {
	                visiblePlaceholder.remove();
	            }
	            // dispatch sortstart event on each element in group
	            sortableElement.dispatchEvent(new CustomEvent('sortstop', {
	                detail: {
	                    origin: {
	                        elementIndex: originElementIndex,
	                        index: originIndex,
	                        container: originContainer
	                    },
	                    item: dragging
	                }
	            }));
	            previousContainer = null;
	            dragging = null;
	            draggingHeight = null;
	        });
	        /*
	         * Drop Event - https://developer.mozilla.org/en-US/docs/Web/Events/drop
	         * Fires when valid drop target area is hit
	         */
	        addEventListener(sortableElement, 'drop', function (e) {
	            if (!_listsConnected(sortableElement, dragging.parentElement)) {
	                return;
	            }
	            e.preventDefault();
	            e.stopPropagation();
	            addData(dragging, 'dropped', 'true');
	            // get the one placeholder that is currently visible
	            var visiblePlaceholder = Array.from(stores.values()).map(function (data) {
	                return data.placeholder;
	            })
	                .filter(function (placeholder) { return placeholder instanceof HTMLElement; })
	                .filter(isInDom)[0];
	            // attach element after placeholder
	            insertAfter(visiblePlaceholder, dragging);
	            // remove placeholder from dom
	            visiblePlaceholder.remove();
	            /*
	             * Fires Custom Event - 'sortstop'
	             */
	            sortableElement.dispatchEvent(new CustomEvent('sortstop', {
	                detail: {
	                    origin: {
	                        elementIndex: originElementIndex,
	                        index: originIndex,
	                        container: originContainer
	                    },
	                    item: dragging
	                }
	            }));
	            var placeholder = store(sortableElement).placeholder;
	            var originItems = _filter(originContainer.children, options.items)
	                .filter(function (item) { return item !== placeholder; });
	            var destinationContainer = this.isSortable === true ? this : this.parentElement;
	            var destinationItems = _filter(destinationContainer.children, addData(destinationContainer, 'items'))
	                .filter(function (item) { return item !== placeholder; });
	            var destinationElementIndex = index(dragging, Array.from(dragging.parentElement.children)
	                .filter(function (item) { return item !== placeholder; }));
	            var destinationIndex = index(dragging, destinationItems);
	            /*
	             * When a list item changed container lists or index within a list
	             * Fires Custom Event - 'sortupdate'
	             */
	            if (originElementIndex !== destinationElementIndex || originContainer !== destinationContainer) {
	                sortableElement.dispatchEvent(new CustomEvent('sortupdate', {
	                    detail: {
	                        origin: {
	                            elementIndex: originElementIndex,
	                            index: originIndex,
	                            container: originContainer,
	                            itemsBeforeUpdate: originItemsBeforeUpdate,
	                            items: originItems
	                        },
	                        destination: {
	                            index: destinationIndex,
	                            elementIndex: destinationElementIndex,
	                            container: destinationContainer,
	                            itemsBeforeUpdate: destinationItemsBeforeUpdate,
	                            items: destinationItems
	                        },
	                        item: dragging
	                    }
	                }));
	            }
	        });
	        var debouncedDragOverEnter = _debounce(function (sortableElement, element, pageY) {
	            if (!dragging) {
	                return;
	            }
	            // set placeholder height if forcePlaceholderSize option is set
	            if (options.forcePlaceholderSize) {
	                store(sortableElement).placeholder.style.height = draggingHeight + 'px';
	            }
	            // if element the draggedItem is dragged onto is within the array of all elements in list
	            // (not only items, but also disabled, etc.)
	            if (Array.from(sortableElement.children).indexOf(element) > -1) {
	                var thisHeight = _getElementHeight(element);
	                var placeholderIndex = index(store(sortableElement).placeholder, element.parentElement.children);
	                var thisIndex = index(element, element.parentElement.children);
	                // Check if `element` is bigger than the draggable. If it is, we have to define a dead zone to prevent flickering
	                if (thisHeight > draggingHeight) {
	                    // Dead zone?
	                    var deadZone = thisHeight - draggingHeight;
	                    var offsetTop = offset(element).top;
	                    if (placeholderIndex < thisIndex && pageY < offsetTop) {
	                        return;
	                    }
	                    if (placeholderIndex > thisIndex &&
	                        pageY > offsetTop + thisHeight - deadZone) {
	                        return;
	                    }
	                }
	                if (dragging.oldDisplay === undefined) {
	                    dragging.oldDisplay = dragging.style.display;
	                }
	                if (dragging.style.display !== 'none') {
	                    dragging.style.display = 'none';
	                }
	                // To avoid flicker, determine where to position the placeholder
	                // based on where the mouse pointer is relative to the elements
	                // vertical center.
	                var placeAfter = false;
	                try {
	                    var elementMiddle = offset(element).top + element.offsetHeight / 2;
	                    placeAfter = pageY >= elementMiddle;
	                }
	                catch (e) {
	                    placeAfter = placeholderIndex < thisIndex;
	                }
	                if (placeAfter) {
	                    insertAfter(element, store(sortableElement).placeholder);
	                }
	                else {
	                    insertBefore(element, store(sortableElement).placeholder);
	                }
	                // get placeholders from all stores & remove all but current one
	                Array.from(stores.values())
	                    .filter(function (data) { return data.placeholder !== undefined; })
	                    .forEach(function (data) {
	                    if (data.placeholder !== store(sortableElement).placeholder) {
	                        data.placeholder.remove();
	                    }
	                });
	            }
	            else {
	                // get all placeholders from store
	                var placeholders = Array.from(stores.values())
	                    .filter(function (data) { return data.placeholder !== undefined; })
	                    .map(function (data) {
	                    return data.placeholder;
	                });
	                // check if element is not in placeholders
	                if (placeholders.indexOf(element) === -1 && sortableElement === element && !_filter(element.children, options.items).length) {
	                    placeholders.forEach(function (element) { return element.remove(); });
	                    element.appendChild(store(sortableElement).placeholder);
	                }
	            }
	        }, options.debounce);
	        // Handle dragover and dragenter events on draggable items
	        var onDragOverEnter = function (e) {
	            var element = e.target;
	            var sortableElement = element.isSortable === true ? element : findSortable(element, e);
	            element = findDragElement(sortableElement, element);
	            if (!dragging || !_listsConnected(sortableElement, dragging.parentElement) || addData(sortableElement, '_disabled') === 'true') {
	                return;
	            }
	            var options = addData(sortableElement, 'opts');
	            if (parseInt(options.maxItems) && _filter(sortableElement.children, addData(sortableElement, 'items')).length >= parseInt(options.maxItems) && dragging.parentElement !== sortableElement) {
	                return;
	            }
	            e.preventDefault();
	            e.stopPropagation();
	            e.dataTransfer.dropEffect = store(sortableElement).getConfig('copy') === true ? 'copy' : 'move';
	            debouncedDragOverEnter(sortableElement, element, e.pageY);
	        };
	        addEventListener(listItems.concat(sortableElement), 'dragover', onDragOverEnter);
	        addEventListener(listItems.concat(sortableElement), 'dragenter', onDragOverEnter);
	    });
	    return sortableElements;
	}
	sortable.destroy = function (sortableElement) {
	    _destroySortable(sortableElement);
	};
	sortable.enable = function (sortableElement) {
	    _enableSortable(sortableElement);
	};
	sortable.disable = function (sortableElement) {
	    _disableSortable(sortableElement);
	};

	var html5sortable_cjs = sortable;

	class RankWidget extends Widget {

	    static get selector() {
	        return '.question input.rank';
	    }

	    static get list() {
	        return true;
	    }

	    _init() {
	        const that = this;
	        const loadedValue = this.originalInputValue;
	        const startText = support.touch ? t( 'rankwidget.tapstart' ) : t( 'rankwidget.clickstart' );

	        this.itemSelector = 'label:not(.itemset-template)';
	        this.list = jquery( this.element ).next( '.option-wrapper' ).addClass( 'widget rank-widget' )[ 0 ];

	        jquery( this.list )
	            .toggleClass( 'rank-widget--empty', !loadedValue )
	            .append( this.resetButtonHtml )
	            .append( `<div class="rank-widget__overlay"><span class="rank-widget__overlay__content">${startText}</span></div>` )
	            .on( 'click', function() {
	                if ( !that.element.disabled ) {
	                    this.classList.remove( 'rank-widget--empty' );
	                    that.originalInputValue = that.value;
	                    that.element.dispatchEvent( event.FakeFocus() );
	                }
	            } );

	        this.list.querySelector( '.btn-reset' ).addEventListener( 'click', ( evt ) => {
	            this._reset();
	            evt.stopPropagation();
	        } );

	        this.element.classList.add( 'hide' );

	        this.value = loadedValue;

	        // Create the sortable drag-and-drop functionality
	        html5sortable_cjs( this.list, {
	            items: this.itemSelector,
	            //hoverClass: 'rank-widget__item--hover',
	            containerSerializer( container ) {
	                return {
	                    value: [].slice.call( container.node.querySelectorAll( `${that.itemSelector} input` ) ).map( input => input.value ).join( ' ' )
	                };
	            }
	        } )[ 0 ].addEventListener( 'sortupdate', () => {
	            this.originalInputValue = this.value;
	            this.element.dispatchEvent( event.FakeFocus() );
	        } );

	        if ( this.props.readonly ) {
	            this.disable();
	        }
	    }

	    _reset() {
	        this.originalInputValue = '';
	    }

	    get value() {
	        const result = html5sortable_cjs( this.list, 'serialize' );
	        return result[ 0 ].container.value;
	    }

	    set value( value ) {
	        if ( !value ) {
	            return this._reset();
	        }
	        const that = this;
	        const values = value.split( ' ' );
	        const items = [ ...this.list.querySelectorAll( `${this.itemSelector} input` ) ];

	        // Basic error check
	        if ( values.length !== items.length ) {
	            throw new Error( 'Could not load rank widget value. Number of items mismatch.' );
	        }

	        // Don't even attempt to rectify a mismatch between the value and the available items.
	        items.sort( ( a, b ) => {
	            const aIndex = values.indexOf( a.value );
	            const bIndex = values.indexOf( b.value );
	            if ( aIndex === -1 || bIndex === -1 ) {
	                throw new Error( 'Could not load rank widget value. Mismatch in item values.' );
	            }
	            return aIndex - bIndex;
	        } );

	        items.forEach( item => {
	            jquery( that.list ).find( '.btn-reset' ).before( jquery( item.parentNode ).detach() );
	        } );
	    }

	    disable() {
	        jquery( this.element )
	            .prop( 'disabled', true )
	            .next( '.widget' )
	            .find( 'input, button' )
	            .prop( 'disabled', true );

	        html5sortable_cjs( this.list, 'disable' );
	    }

	    enable() {
	        jquery( this.element )
	            .prop( 'disabled', false )
	            .next( '.widget' )
	            .find( 'input, button' )
	            .prop( 'disabled', false );

	        html5sortable_cjs( this.list, 'enable' );
	    }

	    update() {
	        const value = this.element.value;
	        // re-initalize sortable because the options may have changed
	        html5sortable_cjs( this.list );

	        if ( value ) {
	            this.value = value;
	            this.originalInputValue = value;
	        } else {
	            this._reset();
	        }
	    }

	    // Since we're overriding the setter we also have to overwrite the getter
	    // https://stackoverflow.com/questions/28950760/override-a-setter-and-the-getter-must-also-be-overridden
	    get originalInputValue() {
	        return super.originalInputValue;
	    }

	    /**
	     * This is the input that Enketo's engine listens on.
	     */
	    set originalInputValue( value ) {
	        super.originalInputValue = value;
	        this.list.classList.toggle( 'rank-widget--empty', !value );
	    }

	}

	class UrlWidget extends Widget {

	    static get selector() {
	        return '.or-appearance-url input[type="text"]';
	    }

	    _init() {
	        const fragment = document.createRange().createContextualFragment( '<a class="widget url-widget" target="_blank"/>' );

	        this.element.classList.add( 'hide' );
	        this.element.after( fragment );

	        this.value = this.originalInputValue;
	    }

	    update() {
	        this.value = this.originalInputValue;
	    }

	    get value() {
	        return this.question.querySelector( '.url-widget' ).href;
	    }

	    set value( value ) {
	        value = value || '';
	        const link = this.question.querySelector( '.url-widget' );
	        link.href = value;
	        link.title = value;
	        link.textContent = value;
	    }
	}

	/**
	 * Hardcodes a maximum character length to text input fields.
	 * This is an unusual way to implement a feature, because it is not an actual widget,
	 * but this is the easiest way to do it.
	 */
	class TextMaxWidget extends Widget {

	    static get selector() {
	        return '[data-type-xml="string"]';
	    }

	    _init() {
	        const max = Number( config.textMaxChars );
	        if ( !isNaN( max ) && max > 0 ) {
	            this.element.setAttribute( 'maxlength', config.textMaxChars );
	        }
	    }
	}

	//import zz from '../widget/example/my-widget';

	var _widgets = [ NoteWidget, DesktopSelectpicker, MobileSelectPicker, AutocompleteSelectpicker, Geopicker, TextareaWidget, TableWidget, Radiopicker, DatepickerExtended, DatepickerNative, DatepickerMobile, TimepickerExtended, DatetimepickerExtended, CompactPicker, Filepicker, DrawWidget, LikertItem, HorizontalChoices, AnalogScaleWidget, ImageViewer, Comment, ImageMap, RangeWidget, RankWidget, UrlWidget, TextMaxWidget ];

	const widgets = _widgets.filter( widget => widget.selector );
	let options$1;
	let formHtml;

	/**
	 * Initializes widgets
	 *
	 * @param  {jQuery} $group The element inside which the widgets have to be initialized.
	 * @param { *} options Options (e.g. helper function of Form.js passed)
	 */
	function init( $group, opts = {} ) {
	    if ( !this.form ) {
	        throw new Error( 'Widgets module not correctly instantiated with form property.' );
	    }

	    options$1 = opts;
	    formHtml = this.form.view.html; // not sure why this is only available in init

	    const group = $group && $group.length ? $group[ 0 ] : formHtml;

	    widgets.forEach( Widget => {
	        _instantiate( Widget, group );
	    } );

	    return true;
	}

	/**
	 * Enables widgets if they weren't enabled already if they are not readonly.
	 * In most widgets, this function will do nothing because the disabled attribute was automatically removed from all
	 * fieldsets, inputs, textareas and selects inside the branch element provided as parameter.
	 * Note that this function can be called before the widgets have been initialized and will in that case do nothing. This is
	 * actually preferable than waiting for create() to complete, because enable() will never do anything that isn't
	 * done during create().
	 *
	 * @param  {Element} group [description]
	 */
	function enable( group ) {
	    widgets.forEach( Widget => {
	        const els = _getElements( group, Widget.selector )
	            .filter( el => el.nodeName.toLowerCase() === 'select' ? !el.getAttribute( 'readonly' ) : !el.readOnly );
	        new Collection( els ).enable( Widget );
	    } );
	}

	/**
	 * Disables  widgets, if they aren't disabled already when the branch was disabled by the controller.
	 * In most widgets, this function will do nothing because all fieldsets, inputs, textareas and selects will get
	 * the disabled attribute automatically when the branch element provided as parameter becomes irrelevant.
	 *
	 * @param  { Element } group The element inside which all widgets need to be disabled.
	 */
	function disable( group ) {
	    widgets.forEach( Widget => {
	        const els = _getElements( group, Widget.selector );
	        new Collection( els ).disable( Widget );
	    } );
	}

	/**
	 * Returns the elements on which to apply the widget
	 *
	 * @param  {Element} group   a jQuery-wrapped element
	 * @param  {string} selector if the selector is null, the form element will be returned
	 * @return {jQuery}          a jQuery collection
	 */
	function _getElements( group, selector ) {
	    if ( selector ) {
	        if ( selector === 'form' ) {
	            return [ formHtml ];
	        }
	        // e.g. if the widget selector starts at .question level (e.g. ".or-appearance-draw input")
	        if ( group.classList.contains( 'question' ) ) {
	            return [ ...group.querySelectorAll( 'input:not(.ignore), select:not(.ignore), textarea:not(.ignore)' ) ]
	                .filter( el => el.matches( selector ) );
	        }
	        return [ ...group.querySelectorAll( selector ) ];
	    }

	    return [];
	}

	/**
	 * Instantiate a widget on a group (whole form or newly cloned repeat)
	 *
	 * @param  widget The widget to instantiate
	 * @param  {Element} group The element inside which widgets need to be created.
	 */
	function _instantiate( Widget, group ) {
	    let opts = {};

	    if ( !Widget.name ) {
	        return console.error( 'widget doesn\'t have a name' );
	    }

	    if ( Widget.helpersRequired && Widget.helpersRequired.length > 0 ) {
	        opts.helpers = {};
	        Widget.helpersRequired.forEach( helper => {
	            opts.helpers[ helper ] = options$1[ helper ];
	        } );
	    }

	    const elements = _getElements( group, Widget.selector );

	    if ( !elements.length ) {
	        return;
	    }

	    new Collection( elements ).instantiate( Widget, opts );

	    _setLangChangeListener( Widget, elements );
	    _setOptionChangeListener( Widget, elements );
	    _setValChangeListener( Widget, elements );
	}


	/**
	 * Calls widget('update') when the language changes. This function is called upon initialization,
	 * and whenever a new repeat is created. In the latter case, since the widget('update') is called upon
	 * the elements of the repeat, there should be no duplicate eventhandlers.
	 *
	 * @param {{name: string}} widget The widget configuration object
	 * @param {<Element>}         els    Array of elements that the widget has been instantiated on.
	 */
	function _setLangChangeListener( Widget, els ) {
	    // call update for all widgets when language changes 
	    if ( els.length > 0 ) {
	        formHtml.addEventListener( event.ChangeLanguage().type, () => {
	            new Collection( els ).update( Widget );
	        } );
	    }
	}

	/**
	 * Calls widget('update') on select-type widgets when the options change. This function is called upon initialization,
	 * and whenever a new repeat is created. In the latter case, since the widget('update') is called upon
	 * the elements of the repeat, there should be no duplicate eventhandlers.
	 *
	 * @param {{name: string}} widget   The widget configuration object
	 * @param {<Element>}      els      The array of elements that the widget has been instantiated on.
	 */
	function _setOptionChangeListener( Widget, els ) {
	    if ( els.length > 0 && Widget.list ) {
	        jquery( els ).on( 'changeoption', function() {
	            // update (itemselect) picker on which event was triggered because the options changed
	            new Collection( this ).update( Widget );
	        } );
	    }
	}

	/**
	 * Calls widget('update') if the form input/select/textarea value changes due to an action outside
	 * of the widget (e.g. a calculation).
	 * 
	 * @param {{name: string}} widget   The widget configuration object
	 * @param {<Element>}      els      The array of elements that the widget has been instantiated on.
	 */
	function _setValChangeListener( Widget, els ) {
	    // avoid adding eventhandlers on widgets that apply to the <form> or <label> element
	    if ( els.length > 0 && els[ 0 ].matches( 'input, select, textarea' ) ) {
	        els.forEach( el => el.addEventListener( event.InputUpdate().type, event => {
	            new Collection( event.target ).update( Widget );
	        } ) );
	    }
	}

	class Collection {
	    constructor( elements ) {
	        if ( !Array.isArray( elements ) ) {
	            elements = [ elements ];
	        }
	        this.elements = elements;
	    }
	    _instantiateSingleWidget( element, Widget, options = {} ) {
	        if ( !Widget.condition( element ) ) {
	            return;
	        }
	        if ( elementDataStore.has( element, Widget ) ) {
	            return;
	        }
	        const w = new Widget( element, options );
	        if ( w instanceof Promise ) {
	            w.then( wr => elementDataStore.put( element, Widget.name, wr ) );
	        } else {
	            elementDataStore.put( element, Widget.name, w );
	        }
	    }
	    _methodCall( Widget, method ) {
	        this.elements.forEach( element => {
	            const w = elementDataStore.get( element, Widget.name );
	            if ( w ) {
	                w[ method ]();
	            }
	        } );
	    }
	    instantiate( Widget, options ) {
	        this.elements.forEach( el => this._instantiateSingleWidget( el, Widget, options ) );
	    }
	    update( Widget ) {
	        this._methodCall( Widget, 'update' );
	    }
	    disable( Widget ) {
	        this._methodCall( Widget, 'disable' );
	    }
	    enable( Widget ) {
	        this._methodCall( Widget, 'enable' );
	    }
	}

	var widgetModule = {
	    init,
	    enable,
	    disable
	};

	/**
	 * Form languages module.
	 */

	var languageModule = {
	    init() {
	        if ( !this.form ) {
	            throw new Error( 'Language module not correctly instantiated with form property.' );
	        }
	        const root = this.form.view.html.closest( 'body' ) || this.form.view.html.parentNode;
	        if ( !root ) {
	            return;
	        }
	        const langSelector = root.querySelector( '.form-language-selector' );
	        const formLanguages = this.form.view.html.querySelector( '#form-languages' );

	        if ( !formLanguages ) {
	            return;
	        }

	        const languages = [ ...formLanguages.querySelectorAll( 'option' ) ].map( option => option.value );
	        if ( langSelector ) {
	            langSelector
	                .append( formLanguages );
	            if ( languages.length > 1 ) {
	                langSelector.classList.remove( 'hide' );
	            }
	        }
	        this.formLanguages = root.querySelector( '#form-languages' );
	        this._currentLang = this.formLanguages.dataset.defaultLang || languages[ 0 ] || '';
	        const langOption = this.formLanguages.querySelector( `[value="${this._currentLang}"]` );
	        const currentDirectionality = langOption && langOption.dataset.dir || 'ltr';

	        this.formLanguages.value = this._currentLang;

	        this.form.view.html.setAttribute( 'dir', currentDirectionality );

	        if ( languages.length < 2 ) {
	            return;
	        }

	        this.formLanguages.addEventListener( event.Change().type, event => {
	            event.preventDefault();
	            this._currentLang = event.target.value;
	            this.setUi( this._currentLang );
	        } );

	        this.form.view.html.addEventListener( event.AddRepeat().type, event => this.setUi( this._currentLang, event.target ) );
	    },
	    get currentLang() {
	        return this._currentLang;
	    },
	    get currentLangDesc() {
	        const langOption = this.formLanguages.querySelector( `[value="${this._currentLang}"]` );
	        return langOption ? langOption.textContent : null;
	    },
	    setUi( lang, group = this.form.view.html ) {
	        const dir = this.formLanguages.querySelector( `[value="${lang}"]` ).dataset.dir || 'ltr';
	        const translations = [ ...group.querySelectorAll( '[lang]' ) ];

	        this.form.view.html.setAttribute( 'dir', dir );
	        translations.forEach( el => el.classList.remove( 'active' ) );
	        translations
	            .filter( el => el.matches( `[lang="${lang}"], [lang=""]` ) &&
	                ( !el.classList.contains( 'or-form-short' ) || ( el.classList.contains( 'or-form-short' ) && getSiblingElements( el, '.or-form-long' ).length === 0 ) ) )
	            .forEach( el => el.classList.add(
	                'active'
	            ) );

	        // For use in locale-sensitive XPath functions.
	        // Don't even check whether it's a proper subtag or not. It will revert to client locale if it is not recognized.
	        window.enketoFormLocale = lang;

	        this.form.view.html.querySelectorAll( 'select, datalist' ).forEach( el => this.setSelect( el ) );
	        this.form.view.html.dispatchEvent( event.ChangeLanguage() );
	    },
	    // swap language of <select> and <datalist> <option>s
	    setSelect( select ) {
	        const type = select.nodeName.toLowerCase();
	        const question = select.closest( '.question' );
	        const translations = question ? question.querySelector( '.or-option-translations' ) : null;

	        if ( !translations ) {
	            return;
	        }

	        [ ...select.children ].filter( el => el.matches( 'option' ) && !el.matches( '[value=""], [data-value=""]' ) )
	            .forEach( option => {
	                const curLabel = type === 'datalist' ? option.value : option.textContent;
	                const value = type === 'datalist' ? option.dataset.value : option.value;
	                const translatedOption = translations.querySelector( `.active[data-option-value="${value}"]` );
	                let newLabel = curLabel;
	                if ( translatedOption && translatedOption.textContent ) {
	                    newLabel = translatedOption.textContent;
	                }
	                option.value = value;
	                option.textContent = newLabel;
	            } );
	    }
	};

	/*
	 * Preloader module.
	 * 
	 * Note that preloaders may be deprecated in the future. This code is already prepared for a change 
	 * by using a (secret) "session" instance.
	 *
	 * Functions are designed to fail silently if unknown preloaders are called.
	 */
	var preloadModule = {
	    init() {
	        let item;
	        let param;
	        let curVal;
	        let newVal;
	        let dataNode;
	        let props;
	        let $preload;
	        const that = this;

	        if ( !this.form ) {
	            throw new Error( 'Preload module not correctly instantiated with form property.' );
	        }

	        //these initialize actual preload items
	        this.form.view.$.find( 'input[data-preload], select[data-preload], textarea[data-preload]' ).each( function() {
	            $preload = jquery( this );
	            props = that.form.input.getProps( $preload );
	            item = $preload.attr( 'data-preload' ).toLowerCase();
	            param = $preload.attr( 'data-preload-params' ).toLowerCase();

	            if ( typeof that[ item ] !== 'undefined' ) {
	                dataNode = that.form.model.node( props.path, props.index );
	                // If a preload item is placed inside a repeat with repeat-count 0, the node
	                // doesn't exist and will never get a value (which is correct behavior)
	                if ( dataNode.getElements().length ) {
	                    curVal = dataNode.getVal();
	                    newVal = that[ item ]( {
	                        param,
	                        curVal,
	                        dataNode
	                    } );

	                    dataNode.setVal( newVal, props.xmlType );
	                }
	            } else {
	                console.log( `Preload "${item}" not supported. May or may not be a big deal.` );
	            }
	        } );
	    },
	    'timestamp': function( o ) {
	        let value;
	        const that = this;
	        // when is 'start' or 'end'
	        if ( o.param === 'start' ) {
	            return ( o.curVal.length > 0 ) ? o.curVal : this.form.model.evaluate( 'now()', 'string' );
	        }
	        if ( o.param === 'end' ) {
	            //set event handler for each save event (needs to be triggered!)
	            this.form.view.$.on( 'beforesave', () => {
	                value = that.form.model.evaluate( 'now()', 'string' );
	                o.dataNode.setVal( value, 'datetime' );
	            } );
	            //TODO: why populate this upon load?
	            return this.form.model.evaluate( 'now()', 'string' );
	        }
	        return 'error - unknown timestamp parameter';
	    },
	    'date': function( o ) {
	        let today;
	        let year;
	        let month;
	        let day;

	        if ( o.curVal.length === 0 ) {
	            today = new Date( this.form.model.evaluate( 'today()', 'string' ) );
	            year = today.getFullYear().toString().pad( 4 );
	            month = ( today.getMonth() + 1 ).toString().pad( 2 );
	            day = today.getDate().toString().pad( 2 );

	            return `${year}-${month}-${day}`;
	        }
	        return o.curVal;
	    },
	    'property': function( o ) {
	        let node;

	        // 'deviceid', 'subscriberid', 'simserial', 'phonenumber'
	        if ( o.curVal.length === 0 ) {
	            node = this.form.model.node( `instance("__session")/session/context/${o.param}` );
	            if ( node.getElements().length ) {
	                return node.getVal();
	            } else {
	                return `no ${o.param} property in enketo`;
	            }
	        }
	        return o.curVal;
	    },
	    'context': function( o ) {
	        // 'application', 'user'??
	        if ( o.curVal.length === 0 ) {
	            return ( o.param === 'application' ) ? 'enketo' : `${o.param} not supported in enketo`;
	        }
	        return o.curVal;
	    },
	    'patient': function( o ) {
	        if ( o.curVal.length === 0 ) {
	            return 'patient preload item not supported in enketo';
	        }
	        return o.curVal;
	    },
	    'user': function( o ) {
	        if ( o.curVal.length === 0 ) {
	            return 'user preload item not supported in enketo yet';
	        }
	        return o.curVal;
	    },
	    'uid': function( o ) {
	        if ( o.curVal.length === 0 ) {
	            return this.form.model.evaluate( 'concat("uuid:", uuid())', 'string' );
	        }
	        return o.curVal;
	    }
	};

	/**
	 * Updates output values, optionally filtered by those values that contain a changed node name
	 *
	 * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
	 */

	var outputModule = {
	    update( updated ) {
	        const outputCache = {};
	        let val = '';
	        const that = this;

	        if ( !this.form ) {
	            throw new Error( 'Output module not correctly instantiated with form property.' );
	        }

	        const $nodes = this.form.getRelatedNodes( 'data-value', '.or-output', updated );

	        const clonedRepeatsPresent = this.form.repeatsPresent && this.form.view.html.querySelector( '.or-repeat.clone' );

	        $nodes.each( function() {
	            const $output = jquery( this );

	            // nodes are in document order, so we discard any nodes in questions/groups that have a disabled parent
	            if ( $output.closest( '.or-branch' ).parent().closest( '.disabled' ).length ) {
	                return;
	            }

	            const expr = $output.attr( 'data-value' );
	            /*
	             * Note that in XForms input is the parent of label and in HTML the other way around so an output inside a label
	             * should look at the HTML input to determine the context.
	             * So, context is either the input name attribute (if output is inside input label),
	             * or the parent with a name attribute
	             * or the whole document
	             */
	            let $context = $output.closest( '.question, .or-group' );

	            if ( !$context.is( '.or-group' ) ) {
	                $context = $context.find( '[name]' ).eq( 0 );
	            }

	            let context = that.form.input.getName( $context );

	            /* 
	             * If the output is part of a group label and that group contains repeats with the same name,
	             * but currently has 0 repeats, the context will not be available. See issue 502. 
	             * This same logic is applied in branch.js.
	             */
	            if ( $context.children( `.or-repeat-info[data-name="${context}"]` ).length && !$context.children( `.or-repeat[name="${context}"]` ).length ) {
	                context = null;
	            }

	            const insideRepeat = ( clonedRepeatsPresent && $output.parentsUntil( '.or', '.or-repeat' ).length > 0 );
	            const insideRepeatClone = ( insideRepeat && $output.parentsUntil( '.or', '.or-repeat.clone' ).length > 0 );
	            const index = ( insideRepeatClone && context ) ? that.form.input.getIndex( $context ) : 0;

	            if ( typeof outputCache[ expr ] !== 'undefined' ) {
	                val = outputCache[ expr ];
	            } else {
	                val = that.form.model.evaluate( expr, 'string', context, index, true );
	                if ( !insideRepeat ) {
	                    outputCache[ expr ] = val;
	                }
	            }
	            if ( $output.text() !== val ) {
	                $output.text( val );
	            }
	        } );
	    }
	};

	/**
	 * Updates calculated items
	 *
	 * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
	 */

	var calculationModule = {

	    update( updated = {}, filter = '' ) {
	        let $nodes;
	        const that = this;

	        if ( !this.form ) {
	            throw new Error( 'Calculation module not correctly instantiated with form property.' );
	        }

	        // Filter is used in custom applications that make a distinction between types of calculations.
	        if ( updated.relevantPath ) {
	            // Questions that are descendants of a group:
	            $nodes = this.form.getRelatedNodes( 'data-calculate', `[name^="${updated.relevantPath}/"]${filter}` )
	                // Individual questions:
	                .add( this.form.getRelatedNodes( 'data-calculate', `[name="${updated.relevantPath}"]${filter}` ) )
	                // Individual radiobutton questions with a calculate....:
	                .add( this.form.getRelatedNodes( 'data-calculate', `[data-name="${updated.relevantPath}"]${filter}` ) );
	        } else {
	            $nodes = this.form.getRelatedNodes( 'data-calculate', filter, updated );
	        }

	        $nodes.each( function() {
	            let index;
	            const $control = jquery( this );
	            const name = that.form.input.getName( $control );
	            const dataNodeName = ( name.lastIndexOf( '/' ) !== -1 ) ? name.substring( name.lastIndexOf( '/' ) + 1 ) : name;
	            const expr = that.form.input.getCalculation( $control );
	            const dataType = that.form.input.getXmlType( $control );
	            const relevantExpr = that.form.input.getRelevant( $control );
	            const dataNodesObj = that.form.model.node( name );
	            const dataNodes = dataNodesObj.getElements();

	            if ( dataNodes.length > 1 ) {

	                if ( updated.repeatPath && name.indexOf( updated.repeatPath + '/' ) !== -1 ) {
	                    /*
	                     * If the update was triggered by a datanode inside a repeat
	                     * and the dependent node is inside the same repeat, we can prevent the expensive index determination
	                     */
	                    const dataNode = that.form.model.node( updated.repeatPath, updated.repeatIndex ).getElement().querySelector( dataNodeName );
	                    index = dataNodes.indexOf( dataNode );
	                    updateCalc( index );
	                } else if ( $control[ 0 ].type === 'hidden' ) {
	                    /*
	                     * This case is the consequence of the unfortunate decision to place calculated items without a visible form control,
	                     * as a separate group (.or-calculated-items), instead of in the Form DOM in the locations where they belong.
	                     * This occurs when update is called with empty updated object and multiple repeats are present.
	                     */
	                    dataNodes.forEach( ( el, index ) => {
	                        updateCalc( index );
	                    } );
	                } else {
	                    /* 
	                     * This occurs when the updated object contains a relevantPath that refers to a repeat and multiple repeats are 
	                     * present, without calculated items that HAVE a visible form control.
	                     */
	                    const $repeatSiblings = $control.closest( '.or-repeat' ).siblings( '.or-repeat' ).addBack();
	                    if ( $repeatSiblings.length === dataNodes.length ) {
	                        index = $repeatSiblings.index( $control.closest( '.or-repeat' ) );
	                        updateCalc( index );
	                    }
	                }
	            } else if ( dataNodes.length === 1 ) {
	                index = 0;
	                updateCalc( index );
	            }

	            function updateCalc( index ) {
	                const pathParts = name.split( '/' );
	                /*
	                 * First determine immediate group parent of node, which will always be in correct location in DOM. This is where
	                 * we can use the index to be guaranteed to get the correct node.
	                 * (also for nodes in #calculated-items).
	                 *
	                 * Then get all the group parents of that node.
	                 * 
	                 * TODO: determine index at every level to properly support repeats and nested repeats
	                 * 
	                 * Note: getting the parents of $control wouldn't work for nodes inside #calculated-items!
	                 */
	                const parentPath = pathParts.splice( 0, pathParts.length - 1 ).join( '/' );
	                let startElement;

	                if ( index === 0 ) {
	                    startElement = that.form.view.html.querySelector( `.or-group[name="${parentPath}"],.or-group-data[name="${parentPath}"]` );
	                } else {
	                    startElement = that.form.view.html.querySelectorAll( `.or-repeat[name="${parentPath}"]` )[ index ] ||
	                        that.form.view.html.querySelectorAll( `.or-group[name="${parentPath}"],.or-group-data[name="${parentPath}"]` )[ index ];
	                }
	                const ancestorGroups = startElement ? [ startElement ].concat( getAncestors( startElement, '.or-group, .or-group-data' ) ) : [];

	                if ( ancestorGroups.length ) {
	                    // Start at the highest level, and traverse down to the immediate parent group.
	                    var relevant = ancestorGroups.filter( el => el.matches( '[data-relevant]' ) ).map( group => {
	                        const $group = jquery( group );
	                        const nm = that.form.input.getName( $group );

	                        return {
	                            context: nm,
	                            // thankfully relevants on repeats are not possible with XLSForm-produced forms
	                            index: that.form.view.$.find( `.or-group[name="${nm}"], .or-group-data[name="${nm}"]` ).index( $group ), // performance....
	                            expr: that.form.input.getRelevant( $group )
	                        };
	                    } ).concat( [ {
	                        context: name,
	                        index,
	                        expr: relevantExpr
	                    } ] ).every( item => item.expr ? that.form.model.evaluate( item.expr, 'boolean', item.context, item.index ) : true );
	                } else {
	                    relevant = relevantExpr ? that.form.model.evaluate( relevantExpr, 'boolean', name, index ) : true;
	                }

	                // Not sure if using 'string' is always correct
	                const newExpr = that.form.replaceChoiceNameFn( expr, 'string', name, index );

	                // It is possible that the fixed expr is '' which causes an error in XPath
	                const xpathType = that.form.input.getInputType( $control ) === 'number' ? 'number' : 'string';
	                const result = relevant && newExpr ? that.form.model.evaluate( newExpr, xpathType, name, index ) : '';

	                // Filter the result set to only include the target node
	                dataNodesObj.setIndex( index );

	                // Set the value
	                dataNodesObj.setVal( result, dataType );

	                // Not the most efficient to use input.setVal here as it will do another lookup
	                // of the node, that we already have...
	                // We should not use value "result" here because node.setVal() may have done a data type conversion
	                that.form.input.setVal( $control, dataNodesObj.getVal() );
	            }
	        } );
	    }
	};

	var requiredModule = {
	    /**
	     * Updates readonly
	     *
	     * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
	     */
	    update( updated /*, filter*/ ) {
	        const that = this;
	        // A "required" update will never result in a node value change so the expression evaluation result can be cached fairly aggressively.
	        const requiredCache = {};

	        if ( !this.form ) {
	            throw new Error( 'Required module not correctly instantiated with form property.' );
	        }

	        const $nodes = this.form.getRelatedNodes( 'data-required', '', updated );
	        const repeatClonesPresent = this.form.repeatsPresent && this.form.view.html.querySelector( '.or-repeat.clone' );

	        $nodes.each( function() {
	            const $input = jquery( this );
	            const requiredExpr = that.form.input.getRequired( $input );
	            const path = that.form.input.getName( $input );
	            // Minimize index determination because it is expensive.
	            const index = repeatClonesPresent ? that.form.input.getIndex( $input ) : 0;
	            // The path is stripped of the last nodeName to record the context.
	            // This might be dangerous, but until we find a bug, it improves performance a lot in those forms where one group contains
	            // many sibling questions that each have the same required expression.
	            const cacheIndex = `${requiredExpr}__${path.substring( 0, path.lastIndexOf( '/' ) )}__${index}`;

	            if ( typeof requiredCache[ cacheIndex ] === 'undefined' ) {
	                requiredCache[ cacheIndex ] = that.form.model.node( path, index ).isRequired( requiredExpr );
	            }

	            $input.closest( '.question' ).find( '.required' ).toggleClass( 'hide', !requiredCache[ cacheIndex ] );
	        } );
	    }
	};

	const KEYBOARD_CUT_PASTE = 'xvc';

	function init$1() {
	    /*
	     * These are hardcoded number input masks. The approach will be different if we
	     * ever add complex user-defined input masks.
	     */
	    _setNumberMask( '[data-type-xml="int"]', /^(-?[0-9]+$)/, '-0123456789' );
	    _setNumberMask( '[data-type-xml="decimal"]', /^(-?[0-9]+[.,]?[0-9]*$)/, '-0123456789.,' );
	}

	function _setNumberMask( selector, validRegex, allowedChars ) {

	    jquery( selector )
	        .on( 'keydown', e => {
	            // The "key" property is the correct standards-compliant property to use
	            // but needs some corrections for non-standard-compliant IE behavior.
	            if ( _isNotPrintableKey( e ) || _isKeyboardCutPaste( e ) || allowedChars.indexOf( e.key ) !== -1 ) {
	                return true;
	            }

	            return false;
	        } )
	        .on( 'paste', function( e ) {
	            const val = getPasteData( e );
	            // HTML number input fields will trim the pasted value automatically.
	            if ( val && validRegex.test( val.trim() ) ) {
	                // Note that this.value will be empty if the pasted value is not a valid number (except in IE11).
	                // In that case the paste action has the same result as pasting an empty value, ie
	                // clearing any existing value.
	                return true;
	            }

	            jquery( this ).val( '' ).trigger( 'change' );

	            return false;
	        } )
	        /*
	         * Workaround for most browsers keeping invalid numbers visible in the input without a means to access the invalid value.
	         * E.g. see https://bugs.chromium.org/p/chromium/issues/detail?id=178437&can=2&q=178437&colspec=ID%20Pri%20M%20Stars%20ReleaseBlock%20Component%20Status%20Owner%20Summary%20OS%20Modified
	         * 
	         * A much more intelligent way to solve the problem would be to add a feedback loop from the Model to the input that would 
	         * correct (a converted number) or empty (an invalid number). https://github.com/enketo/enketo-core/issues/407
	         */
	        .on( 'blur', function() {
	            // proper browsers:
	            if ( typeof this.validity !== 'undefined' && typeof this.validity.badInput !== 'undefined' && this.validity.badInput ) {
	                this.value = '';
	            }
	            // IE11 (no validity.badInput support, but does give access to invalid number with this.value)
	            else if ( typeof this.validity.badInput === 'undefined' && this.value && !validRegex.test( this.value.trim() ) ) {
	                this.value = '';
	            }
	        } );
	}

	// Using the (assumed) fact that a non-printable character key always has length > 1
	// IE11: non-confirming 'Spacebar' 
	function _isNotPrintableKey( e ) {
	    return e.key.length > 1 && e.key !== 'Spacebar';
	}

	function _isKeyboardCutPaste( e ) {
	    return KEYBOARD_CUT_PASTE.indexOf( e.key ) !== -1 && ( e.metaKey || e.ctrlKey );
	}

	var maskModule = {
	    init: init$1
	};

	var readonlyModule = {
	    /**
	     * Updates readonly
	     *
	     * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
	     */
	    update( updated ) {
	        const $nodes = this.form.getRelatedNodes( 'readonly', '', updated );
	        $nodes.each( function() {
	            jquery( this ).closest( '.question' ).addClass( 'readonly' );
	            // Note: the readonly-forced class is added for special readonly views of a form.
	            if ( !this.value && !this.dataset.calculate && !this.classList.contains( 'readonly-forced' ) ) {
	                this.classList.add( 'empty' );
	            }
	        } );
	    }
	};

	/**
	 * Clears form input fields and triggers events when doing this. If formelement is cloned but not yet added to DOM
	 * (and not synchronized with data object), the desired event is probably 'edit' (default). If it is already added
	 * to the DOM (and synchronized with data object) a regular change event should be fired
	 *
	 * @param  {string=} ev1 event to be triggered when a value is cleared
	 * @param  {string=} ev2 event to be triggered when a value is cleared
	 * @return { jQuery} [description]
	 */
	jquery.fn.clearInputs = function( ev1, ev2 ) {
	    ev1 = ev1 || 'edit';
	    ev2 = ev2 || '';
	    return this.each( function() {
	        //remove media previews
	        jquery( this ).find( '.file-preview' ).remove();
	        //remove input values
	        jquery( this ).find( 'input, select, textarea' ).not( '.ignore' ).each( function() {
	            const $node = jquery( this );
	            let type = $node.attr( 'type' );
	            let loadedFilename;

	            if ( $node.prop( 'nodeName' ).toUpperCase() === 'SELECT' ) {
	                type = 'select';
	            }
	            if ( $node.prop( 'nodeName' ).toUpperCase() === 'TEXTAREA' ) {
	                type = 'textarea';
	            }
	            switch ( type ) {
	                case 'file':
	                    loadedFilename = this.dataset.loadedFileName;
	                    delete this.dataset.loadedFileName;
	                    /* falls through */
	                case 'date':
	                case 'datetime':
	                case 'time':
	                case 'number':
	                case 'search':
	                case 'color':
	                case 'range':
	                case 'url':
	                case 'email':
	                case 'password':
	                case 'text':
	                case 'tel':
	                case 'hidden':
	                case 'textarea':
	                    if ( $node.val() !== '' || loadedFilename ) {
	                        $node.val( '' ).trigger( ev1 ).trigger( ev2 );
	                    }
	                    break;
	                case 'radio':
	                case 'checkbox':
	                    if ( $node.prop( 'checked' ) ) {
	                        $node.prop( 'checked', false );
	                        $node.trigger( ev1 ).trigger( ev2 );
	                    }
	                    break;
	                case 'select':
	                    if ( $node[ 0 ].selectedIndex > 0 ) {
	                        $node[ 0 ].selectedIndex = 0;
	                        $node.trigger( ev1 ).trigger( ev2 );
	                    }
	                    break;
	                default:
	                    console.error( 'Unrecognized input type found when trying to reset', this );
	            }
	        } );
	    } );
	};

	/**
	 * Reverses a jQuery collection
	 * @type {Array}
	 */
	jquery.fn.reverse = [].reverse;

	/**
	 * Class: Form
	 *
	 * Most methods are prototype method to facilitate customizations outside of enketo-core.
	 *
	 * @param {string} formSelector  jquery selector for the form
	 * @param {{modelStr: string, ?instanceStr: string, ?submitted: boolean, ?external: <{id: string, xmlStr: string }> }} data data object containing XML model, (partial) XML instance-to-load, external data and flag about whether instance-to-load has already been submitted before.
	 * @param { {?webMapId: string}} options form options
	 * 
	 * @constructor
	 */

	function Form( formSelector, data, options ) {
	    const $form = jquery( formSelector );

	    this.$nonRepeats = {};
	    this.$all = {};
	    this.options = typeof options !== 'object' ? {} : options;
	    if ( typeof this.options.clearIrrelevantImmediately === 'undefined' ) {
	        this.options.clearIrrelevantImmediately = true;
	    }
	    this.view = {
	        $: $form,
	        html: $form[ 0 ],
	        $clone: $form.clone()
	    };
	    this.model = new FormModel( data );
	    this.repeatsPresent = !!this.view.html.querySelector( '.or-repeat' );
	    this.widgetsInitialized = false;
	    this.pageNavigationBlocked = false;
	    this.initialized = false;
	}

	/**
	 * Getter and setter functions
	 * @type {Object}
	 */
	Form.prototype = {
	    evaluationCascadeAdditions: [],
	    get evaluationCascade() {
	        return [
	            this.calc.update.bind( this.calc ),
	            this.repeats.countUpdate.bind( this.repeats ),
	            this.relevant.update.bind( this.relevant ),
	            this.output.update.bind( this.output ),
	            this.itemset.update.bind( this.itemset ),
	            this.required.update.bind( this.required ),
	            this.readonly.update.bind( this.readonly ),
	            this.validationUpdate
	        ].concat( this.evaluationCascadeAdditions );
	    },
	    get recordName() {
	        return this.view.$.attr( 'name' );
	    },
	    set recordName( name ) {
	        this.view.$.attr( 'name', name );
	    },
	    get editStatus() {
	        return this.view.html.dataset.edited === 'true';
	    },
	    set editStatus( status ) {
	        // only trigger edit event once
	        if ( status && status !== this.editStatus ) {
	            this.view.html.dispatchEvent( event.Edited() );
	        }
	        this.view.html.dataset.edited = status;
	    },
	    get surveyName() {
	        return this.view.$.find( '#form-title' ).text();
	    },
	    get instanceID() {
	        return this.model.instanceID;
	    },
	    get deprecatedID() {
	        return this.model.deprecatedID;
	    },
	    get instanceName() {
	        return this.model.instanceName;
	    },
	    get version() {
	        return this.model.version;
	    },
	    get encryptionKey() {
	        return this.view.$.data( 'base64rsapublickey' );
	    },
	    get action() {
	        return this.view.$.attr( 'action' );
	    },
	    get method() {
	        return this.view.$.attr( 'method' );
	    },
	    get id() {
	        return this.view.html.id;
	    }
	};

	/**
	 * Returns a module and adds the form property to it.
	 */
	Form.prototype.addModule = function( module ) {
	    return Object.create( module, {
	        form: {
	            value: this
	        }
	    } );
	};

	/**
	 * Function: init
	 *
	 * Initializes the Form instance (XML Model and HTML View).
	 *
	 */
	Form.prototype.init = function() {
	    let loadErrors = [];
	    const that = this;

	    loadErrors = loadErrors.concat( this.model.init() );

	    if ( typeof this.model === 'undefined' || !( this.model instanceof FormModel ) ) {
	        loadErrors.push( 'Form could not be initialized without a model.' );
	        return loadErrors;
	    }

	    // Before initializing form view, passthrough some model events externally
	    this.model.events.addEventListener( 'dataupdate', event$1 => {
	        that.view.html.dispatchEvent( event.DataUpdate( event$1.detail ) );
	    } );
	    this.model.events.addEventListener( 'removed', event$1 => {
	        that.view.html.dispatchEvent( event.Removed( event$1.detail ) );
	    } );

	    this.pages = this.addModule( pageModule );
	    this.langs = this.addModule( languageModule );
	    this.progress = this.addModule( progressModule );
	    this.widgets = this.addModule( widgetModule );
	    this.preloads = this.addModule( preloadModule );
	    this.relevant = this.addModule( relevantModule );
	    this.repeats = this.addModule( repeatModule );
	    this.input = this.addModule( input );
	    this.output = this.addModule( outputModule );
	    this.itemset = this.addModule( itemsetModule );
	    this.calc = this.addModule( calculationModule );
	    this.required = this.addModule( requiredModule );
	    this.mask = this.addModule( maskModule );
	    this.readonly = this.addModule( readonlyModule );

	    try {
	        this.preloads.init();

	        // before widgets.init (as instanceID used in offlineFilepicker widget)
	        // store the current instanceID as data on the form element so it can be easily accessed by e.g. widgets
	        this.view.$.data( {
	            instanceID: this.model.instanceID
	        } );

	        // before calc.update!
	        this.grosslyViolateStandardComplianceByIgnoringCertainCalcs();
	        // before repeats.init to make sure the jr:repeat-count calculation has been evaluated
	        this.calc.update();

	        // before itemset.update
	        this.langs.init();

	        // before repeats.init so that template contains role="page" when applicable
	        this.pages.init();

	        // after radio button data-name setting (now done in XLST)
	        this.repeats.init();

	        // after repeats.init, but before itemset.update
	        this.output.update();

	        // after repeats.init
	        this.itemset.update();

	        // after repeats.init
	        this.setAllVals();

	        this.readonly.update(); // after setAllVals();

	        // after setAllVals, after repeats.init

	        this.options.input = this.input;
	        this.options.pathToAbsolute = this.pathToAbsolute.bind( this );
	        this.options.evaluate = this.model.evaluate.bind( this.model );
	        this.options.formClasses = toArray( this.view.html.classList );
	        this.options.getModelValue = this.getModelValue.bind( this );
	        this.widgetsInitialized = this.widgets.init( null, this.options );

	        // after widgets.init(), and after repeats.init(), and after pages.init()
	        this.relevant.update();

	        // after widgets init to make sure widget handlers are called before
	        // after loading existing instance to not trigger an 'edit' event
	        this.setEventHandlers();

	        // update field calculations again to make sure that dependent
	        // field values are calculated
	        this.calc.update();

	        this.required.update();

	        this.mask.init();

	        this.editStatus = false;

	        if ( this.options.printRelevantOnly !== false ) {
	            this.view.$.addClass( 'print-relevant-only' );
	        }

	        setTimeout( () => {
	            that.progress.update();
	        }, 0 );

	        this.initialized = true;
	        return loadErrors;
	    } catch ( e ) {
	        console.error( e );
	        loadErrors.push( `${e.name}: ${e.message}` );
	    }

	    document.querySelector( 'body' ).scrollIntoView();

	    console.debug( 'loadErrors', loadErrors );
	    return loadErrors;
	};

	Form.prototype.goTo = function( xpath ) {
	    const errors = [];
	    if ( !this.goToTarget( this.getGoToTarget( xpath ) ) ) {
	        errors.push( t( 'alert.gotonotfound.msg', {
	            path: location.hash.substring( 1 )
	        } ) );
	    }
	    return errors;
	};

	/**
	 * Obtains a string of primary instance.
	 * 
	 * @param  {!{include: boolean}=} include optional object items to exclude if false
	 * @return {string}        XML string of primary instance
	 */
	Form.prototype.getDataStr = function( include ) {
	    include = ( typeof include !== 'object' || include === null ) ? {} : include;
	    // By default everything is included
	    if ( include.irrelevant === false ) {
	        return this.getDataStrWithoutIrrelevantNodes();
	    }
	    return this.model.getStr();
	};

	/**
	 * Restores HTML form to pre-initialized state. It is meant to be called before re-initializing with
	 * new Form ( .....) and form.init()
	 * For this reason, it does not fix event handler, $form, formView.$ etc.!
	 * It also does not affect the XML instance!
	 */
	Form.prototype.resetView = function() {
	    //form language selector was moved outside of <form> so has to be separately removed
	    jquery( '#form-languages' ).remove();
	    this.view.$.replaceWith( this.view.$clone );
	};

	/**
	 * Implements jr:choice-name
	 * TODO: this needs to work for all expressions (relevants, constraints), now it only works for calculated items
	 * Ideally this belongs in the form Model, but unfortunately it needs access to the view
	 * 
	 * @param  {[type]} expr       [description]
	 * @param  {[type]} resTypeStr [description]
	 * @param  {[type]} selector   [description]
	 * @param  {[type]} index      [description]
	 * @param  {[type]} tryNative  [description]
	 * @return {[type]}            [description]
	 */
	Form.prototype.replaceChoiceNameFn = function( expr, resTypeStr, selector, index, tryNative ) {
	    const that = this;
	    const choiceNames = parseFunctionFromExpression( expr, 'jr:choice-name' );

	    choiceNames.forEach( choiceName => {
	        const params = choiceName[ 1 ];

	        if ( params.length === 2 ) {
	            let label = '';
	            const value = that.model.evaluate( params[ 0 ], resTypeStr, selector, index, tryNative );
	            const name = stripQuotes( params[ 1 ] ).trim();
	            const $input = that.view.$.find( `[name="${name}"]` );

	            if ( !value ) {
	                label = '';
	            } else if ( $input.length > 0 && $input.prop( 'nodeName' ).toLowerCase() === 'select' ) {
	                label = $input.find( `[value="${value}"]` ).text();
	            } else if ( $input.length > 0 && $input.prop( 'nodeName' ).toLowerCase() === 'input' ) {
	                if ( !$input.attr( 'list' ) ) {
	                    label = $input.filter( function() {
	                        return jquery( this ).attr( 'value' ) === value;
	                    } ).siblings( '.option-label.active' ).text();
	                } else {
	                    label = $input.siblings( `datalist#${$input.attr( 'list' )}` ).find( `[data-value="${value}"]` ).attr( 'value' );
	                }
	            }
	            expr = expr.replace( choiceName[ 0 ], `"${label}"` );
	        } else {
	            throw new FormLogicError( `jr:choice-name function has incorrect number of parameters: ${choiceName[ 0 ]}` );
	        }

	    } );
	    return expr;
	};

	/**
	 *  Uses current state of model to set all the values in the form.
	 *  Since not all data nodes with a value have a corresponding input element, 
	 *  we cycle through the HTML form elements and check for each form element whether data is available.
	 */
	Form.prototype.setAllVals = function( $group, groupIndex ) {
	    const that = this;
	    const selector = ( $group && $group.attr( 'name' ) ) ? $group.attr( 'name' ) : null;

	    groupIndex = ( typeof groupIndex !== 'undefined' ) ? groupIndex : null;

	    this.model.node( selector, groupIndex ).getElements()
	        .reduce( ( nodes, current ) => {
	            const newNodes = [ ...current.querySelectorAll( '*' ) ].filter( ( n ) => n.children.length === 0 && n.textContent );
	            return nodes.concat( newNodes );
	        }, [] )
	        .forEach( element => {
	            try {
	                var value = element.textContent;
	                var name = that.model.getXPath( element, 'instance' );
	                const index = that.model.node( name ).getElements().indexOf( element );
	                const $control = that.input.find( name, index );
	                if ( $control.length ) {
	                    that.input.setVal( $control, value );
	                }
	            } catch ( e ) {
	                console.error( e );
	                // TODO: Test if this correctly adds to loadErrors
	                //loadErrors.push( 'Could not load input field value with name: ' + name + ' and value: ' + value );
	                throw new Error( `Could not load input field value with name: ${name} and value: ${value}` );
	            }
	        } );
	    return;
	};

	Form.prototype.getModelValue = function( $control ) {
	    const path = this.input.getName( $control );
	    const index = this.input.getIndex( $control );
	    return this.model.node( path, index ).getVal();
	};

	/**
	 * Finds nodes that have attributes with XPath expressions that refer to particular XML elements.
	 *
	 * @param  {string} attribute The attribute name to search for
	 * @param  {?string} filter   The optional filter to append to each selector
	 * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
	 * @return {jQuery}           A jQuery collection of elements
	 */
	Form.prototype.getRelatedNodes = function( attr, filter, updated ) {
	    let $collection;
	    let $repeatControls = null;
	    let $controls;
	    let selector = [];
	    const that = this;

	    updated = updated || {};
	    filter = filter || '';

	    // The collection of non-repeat inputs, calculations and groups is cached (unchangeable)
	    if ( !this.$nonRepeats[ attr ] ) {
	        $controls = this.view.$.find( `:not(.or-repeat-info)[${attr}]` )
	            .filter( function() {
	                return jquery( this ).closest( '.or-repeat' ).length === 0;
	            } );
	        this.$nonRepeats[ attr ] = this.filterRadioCheckSiblings( $controls );
	    }

	    // If the updated node is inside a repeat (and there are multiple repeats present)
	    if ( typeof updated.repeatPath !== 'undefined' && updated.repeatIndex >= 0 ) {
	        $controls = this.view.$.find( `.or-repeat[name="${updated.repeatPath}"]` ).eq( updated.repeatIndex )
	            .find( `[${attr}]` );
	        $repeatControls = this.filterRadioCheckSiblings( $controls );
	    }

	    // If a new repeat was created, update the cached collection of all form controls with that attribute
	    // If a repeat was deleted ( update.repeatPath && !updated.cloned), rebuild cache
	    if ( !this.$all[ attr ] || ( updated.repeatPath && !updated.cloned ) ) {
	        // (re)build the cache
	        this.$all[ attr ] = this.filterRadioCheckSiblings( this.view.$.find( `[${attr}]` ) );
	    } else if ( updated.cloned && $repeatControls ) {
	        // update the cache
	        this.$all[ attr ] = this.$all[ attr ].add( $repeatControls );
	    }

	    /**
	     * If the update was triggered from a repeat, it improves performance (a lot)
	     * to exclude all those repeats that did not trigger it...
	     * However, this will break if people are referring to nodes in other
	     * repeats such as with /path/to/repeat[3]/node, /path/to/repeat[position() = 3]/node or indexed-repeat(/path/to/repeat/node, /path/to/repeat, 3).
	     * We accept that for now.
	     **/
	    if ( $repeatControls ) {
	        // The non-repeat fields have to be added too, e.g. to update a calculated item with count(to/repeat/node) at the top level
	        $collection = this.$nonRepeats[ attr ].add( $repeatControls );
	    } else {
	        $collection = this.$all[ attr ];
	    }

	    // Add selectors based on specific changed nodes
	    if ( !updated.nodes || updated.nodes.length === 0 ) {
	        selector = selector.concat( [ filter ] );
	    } else {
	        updated.nodes.forEach( node => {
	            selector = selector.concat( that.getQuerySelectorsForLogic( filter, attr, node ) );
	        } );
	        // add all the paths that use the /* selector at end of path
	        selector = selector.concat( that.getQuerySelectorsForLogic( filter, attr, '*' ) );
	    }

	    const selectorStr = selector.join( ', ' );

	    $collection = selectorStr ? $collection.filter( selectorStr ) : $collection;

	    // TODO: exclude descendents of disabled elements? .find( ':not(:disabled) span.active' )
	    return $collection;
	};

	Form.prototype.filterRadioCheckSiblings = $controls => {
	    const wrappers = [];
	    return $controls.filter( function() {
	        // TODO: can this be further performance-optimized?
	        const wrapper = this.type === 'radio' || this.type === 'checkbox' ? jquery( this.parentNode ).parent( '.option-wrapper' )[ 0 ] : null;
	        // Filter out duplicate radiobuttons and checkboxes
	        if ( wrapper ) {
	            if ( wrappers.indexOf( wrapper ) !== -1 ) {
	                return false;
	            }
	            wrappers.push( wrapper );
	        }
	        return true;
	    } );
	};

	/**
	 * Crafts an optimized jQuery selector for element attributes that contain an expression with a target node name.
	 * 
	 * @param  {string} filter   The filter to use
	 * @param  {string} attr     The attribute to target
	 * @param  {string} nodeName The XML nodeName to find
	 * @return {string}          The selector
	 */
	Form.prototype.getQuerySelectorsForLogic = ( filter, attr, nodeName ) => [
	    // The target node name is ALWAYS at the END of a path inside the expression.
	    // #1: followed by space
	    `${filter}[${attr}*="/${nodeName} "]`,
	    // #2: followed by )
	    `${filter}[${attr}*="/${nodeName})"]`,
	    // #3: followed by , if used as first parameter of multiple parameters
	    `${filter}[${attr}*="/${nodeName},"]`,
	    // #4: at the end of an expression
	    `${filter}[${attr}$="/${nodeName}"]`,
	    // #5: followed by ] (used in itemset filters)
	    `${filter}[${attr}*="/${nodeName}]"]`,
	    // #6: followed by [ (used when filtering nodes in repeat instances)
	    `${filter}[${attr}*="/${nodeName}["]`
	];

	/**
	 * Obtains the XML primary instance as string without nodes that have a relevant
	 * that evaluates to false.
	 *
	 * Though this function may be slow it is slow when it doesn't matter much (upon saving). The
	 * alternative is to add some logic to relevant.update to mark irrelevant nodes in the model
	 * but that would slow down form loading and form traversal when it does matter.
	 * 
	 * @return {string} [description]
	 */
	Form.prototype.getDataStrWithoutIrrelevantNodes = function() {
	    const that = this;
	    const modelClone = new FormModel( this.model.getStr() );
	    modelClone.init();

	    // Since we are removing nodes, we need to go in reverse order to make sure 
	    // the indices are still correct!
	    this.getRelatedNodes( 'data-relevant' ).reverse().each( function() {
	        const $node = jquery( this );
	        const relevant = that.input.getRelevant( $node );
	        const index = that.input.getIndex( $node );
	        const path = that.input.getName( $node );
	        let context;

	        /* 
	         * Copied from relevant.js:
	         * 
	         * If the relevant is placed on a group and that group contains repeats with the same name,
	         * but currently has 0 repeats, the context will not be available.
	         */
	        if ( $node.children( `.or-repeat-info[data-name="${path}"]` ).length && !$node.children( `.or-repeat[name="${path}"]` ).length ) {
	            context = null;
	        } else {
	            context = path;
	        }

	        /*
	         * If performance becomes an issue, some opportunities are:
	         * - check if ancestor is relevant
	         * - use cache of relevant.update
	         * - check for repeatClones to avoid calculating index (as in relevant.update)
	         */
	        if ( context && !that.model.evaluate( relevant, 'boolean', context, index ) ) {
	            modelClone.node( context, index ).remove();
	        }
	    } );

	    return modelClone.getStr();
	};

	/**
	 * See https://groups.google.com/forum/?fromgroups=#!topic/opendatakit-developers/oBn7eQNQGTg
	 * and http://code.google.com/p/opendatakit/issues/detail?id=706
	 *
	 * This is using an aggressive name attribute selector to also find e.g. name="/../orx:meta/orx:instanceID", with
	 * *ANY* namespace prefix.
	 *
	 * Once the following is complete this function can and should be removed:
	 *
	 * 1. ODK Collect starts supporting an instanceID preload item (or automatic handling of meta->instanceID without binding)
	 * 2. Pyxforms changes the instanceID binding from calculate to preload (or without binding)
	 * 3. Formhub has re-generated all stored XML forms from the stored XLS forms with the updated pyxforms
	 *
	 */
	Form.prototype.grosslyViolateStandardComplianceByIgnoringCertainCalcs = function() {
	    const $culprit = this.view.$.find( '[name$="instanceID"][data-calculate]' );
	    if ( $culprit.length > 0 ) {
	        $culprit.removeAttr( 'data-calculate' );
	    }
	};

	/**   
	 * This re-validates questions that have a dependency on a question that has just been updated.
	 * 
	 * Note: it does not take care of re-validating a question itself after its value has changed due to a calculation update!
	 */
	Form.prototype.validationUpdate = function( updated ) {
	};

	Form.prototype.setEventHandlers = function() {
	    const that = this;

	    // Prevent default submission, e.g. when text field is filled in and Enter key is pressed
	    this.view.$.attr( 'onsubmit', 'return false;' );

	    /*
	     * The listener below catches both change and change.file events.
	     * The .file namespace is used in the filepicker to avoid an infinite loop. 
	     * 
	     * Fields with the "ignore" class are dynamically added to the DOM in a widget and are supposed to be handled
	     * by the widget itself, e.g. the search field in a geopoint widget. They should be ignored by the main engine.
	     *
	     * Readonly fields are not excluded because of this scenario:
	     * 1. readonly field has a calculation
	     * 2. readonly field becomes irrelevant (e.g. parent group with relevant)
	     * 3. this clears value in view, which should propagate to model via 'change' event
	     */
	    this.view.$.on( 'change.file',
	        'input:not(.ignore), select:not(.ignore), textarea:not(.ignore)',
	        function() {
	            const $input = jquery( this );
	            const n = {
	                path: that.input.getName( $input ),
	                inputType: that.input.getInputType( $input ),
	                xmlType: that.input.getXmlType( $input ),
	                val: that.input.getVal( $input ),
	                index: that.input.getIndex( $input )
	            };

	            // set file input values to the uniqified actual name of file (without c://fakepath or anything like that)
	            if ( n.val.length > 0 && n.inputType === 'file' && $input[ 0 ].files[ 0 ] && $input[ 0 ].files[ 0 ].size > 0 ) {
	                n.val = getFilename( $input[ 0 ].files[ 0 ], $input[ 0 ].dataset.filenamePostfix );
	            }
	            if ( n.val.length > 0 && n.inputType === 'drawing' ) {
	                n.val = getFilename( {
	                    name: n.val
	                }, $input[ 0 ].dataset.filenamePostfix );
	            }

	            const updated = that.model.node( n.path, n.index ).setVal( n.val, n.xmlType );

	            if ( updated ) {
	                that.validateInput( $input )
	                    .then( valid => {
	                        // propagate event externally after internal processing is completed
	                        $input.trigger( 'valuechange', valid );
	                    } );
	            }
	        } );

	    // doing this on the focus event may have little effect on performance, because nothing else is happening :)
	    this.view.html.addEventListener( 'focusin', event => {
	        // update the form progress status
	        this.progress.update( event.target );
	    } );
	    this.view.html.addEventListener( event.FakeFocus().type, event => {
	        // update the form progress status
	        this.progress.update( event.target );
	    } );

	    this.model.events.addEventListener( 'dataupdate', event => {
	        that.evaluationCascade.forEach( fn => {
	            fn.call( that, event.detail );
	        }, true );
	        // edit is fired when the model changes after the form has been initialized
	        that.editStatus = true;
	    } );

	    this.view.html.addEventListener( event.AddRepeat().type, event => {
	        const index = event.detail ? event.detail[ 0 ] : undefined;
	        const $clone = jquery( event.target );
	        const updated = {
	            repeatPath: $clone.attr( 'name' ),
	            repeatIndex: index,
	            cloned: true
	        };
	        // Set defaults of added repeats in Form, setAllVals does not trigger change event
	        that.setAllVals( $clone, index );
	        // Initialize calculations, relevant, itemset, required, output inside that repeat. 
	        that.evaluationCascade.forEach( fn => {
	            fn.call( that, updated );
	        } );
	        that.progress.update();
	    } );

	    this.view.html.addEventListener( event.RemoveRepeat().type, () => {
	        that.progress.update();
	    } );

	    this.view.html.addEventListener( event.ChangeLanguage().type, () => {
	        that.output.update();
	    } );

	    this.view.$.find( '.or-group > h4' ).on( 'click', function() {
	        // The resize trigger is to make sure canvas widgets start working.
	        jquery( this ).closest( '.or-group' ).toggleClass( 'or-appearance-compact' ).trigger( 'resize' );
	    } );
	};

	Form.prototype.setValid = function( $node, type ) {
	    const classes = ( type ) ? `invalid-${type}` : 'invalid-constraint invalid-required invalid-relevant';
	    this.input.getWrapNodes( $node ).removeClass( classes );
	};

	Form.prototype.setInvalid = function( $node, type ) {
	    type = type || 'constraint';

	    this.input.getWrapNodes( $node ).addClass( `invalid-${type}` );
	};

	/**
	 * Blocks page navigation for a short period.
	 * This can be used to ensure that the user sees a new error message before moving to another page.
	 * 
	 * @return {[type]} [description]
	 */
	Form.prototype.blockPageNavigation = function() {
	    const that = this;
	    this.pageNavigationBlocked = true;
	    window.clearTimeout( this.blockPageNavigationTimeout );
	    this.blockPageNavigationTimeout = window.setTimeout( () => {
	        that.pageNavigationBlocked = false;
	    }, 600 );
	};

	/**
	 * Checks whether the question is not currently marked as invalid. If no argument is provided, it checks the whole form.
	 * 
	 * @return {!boolean} whether the question/form is not marked as invalid.
	 */
	Form.prototype.isValid = function( $node ) {
	    let $question;
	    if ( $node ) {
	        $question = this.input.getWrapNodes( $node );
	        return !$question.hasClass( 'invalid-required' ) && !$question.hasClass( 'invalid-constraint' ) && !$question.hasClass( 'invalid-relevant' );
	    }
	    return this.view.$.find( '.invalid-required, .invalid-constraint, .invalid-relevant' ).length === 0;
	};

	Form.prototype.clearIrrelevant = function() {
	    this.relevant.update( null, true );
	};

	/**
	 * Clears all irrelevant question values if necessary and then 
	 * validates all enabled input fields after first resetting everything as valid.
	 * 
	 * @return {Promise} wrapping {boolean} whether the form contains any errors
	 */
	Form.prototype.validateAll = function() {
	    const that = this;
	    // to not delay validation unneccessarily we only clear irrelevants if necessary
	    if ( this.options.clearIrrelevantImmediately === false ) {
	        this.clearIrrelevant();
	    }

	    return this.validateContent( this.view.$ )
	        .then( valid => {
	            that.view.html.dispatchEvent( event.ValidationComplete() );
	            return valid;
	        } );
	};

	/**
	 * Alias of validateAll
	 */
	Form.prototype.validate = Form.prototype.validateAll;

	/**
	 * Validates all enabled input fields in the supplied container, after first resetting everything as valid.
	 * @return {Promise} wrapping {boolean} whether the container contains any errors
	 */
	Form.prototype.validateContent = function( $container ) {
	    let $firstError;
	    const that = this;

	    //can't fire custom events on disabled elements therefore we set them all as valid
	    $container.find( 'fieldset:disabled input, fieldset:disabled select, fieldset:disabled textarea, ' +
	        'input:disabled, select:disabled, textarea:disabled' ).each( function() {
	        that.setValid( jquery( this ) );
	    } );

	    const validations = $container.find( '.question' ).addBack( '.question' ).map( function() {
	        // only trigger validate on first input and use a **pure CSS** selector (huge performance impact)
	        const $elem = jquery( this )
	            .find( 'input:not(.ignore):not(:disabled), select:not(.ignore):not(:disabled), textarea:not(.ignore):not(:disabled)' );
	        if ( $elem.length === 0 ) {
	            return Promise.resolve();
	        }
	        return that.validateInput( $elem.eq( 0 ) );
	    } ).toArray();

	    return Promise.all( validations )
	        .then( () => {
	            $firstError = $container
	                .find( '.invalid-required, .invalid-constraint, .invalid-relevant' )
	                .addBack( '.invalid-required, .invalid-constraint, .invalid-relevant' )
	                .eq( 0 );

	            if ( $firstError.length > 0 ) {
	                that.goToTarget( $firstError[ 0 ] );
	            }
	            return $firstError.length === 0;
	        } )
	        .catch( () => // fail whole-form validation if any of the question
	            // validations threw.
	            false );
	};

	Form.prototype.pathToAbsolute = function( targetPath, contextPath ) {
	    let target;

	    if ( targetPath.indexOf( '/' ) === 0 ) {
	        return targetPath;
	    }

	    // index is irrelevant (no positions in returned path)
	    target = this.model.evaluate( targetPath, 'node', contextPath, 0, true );

	    return this.model.getXPath( target, 'instance', false );
	};

	/**
	 * Validates question values.
	 * 
	 * @param  {jQuery} $input    [description]
	 * @return {Promise}           [description]
	 */
	Form.prototype.validateInput = function( $input ) {
	    if ( !this.initialized ) {
	        return Promise.resolve();
	    }
	    const that = this;
	    let getValidationResult;
	    // All relevant properties, except for the **very expensive** index property
	    // There is some scope for performance improvement by determining other properties when they 
	    // are needed, but that may not be so significant.
	    const n = {
	        path: this.input.getName( $input ),
	        inputType: this.input.getInputType( $input ),
	        xmlType: this.input.getXmlType( $input ),
	        enabled: this.input.isEnabled( $input ),
	        constraint: this.input.getConstraint( $input ),
	        calculation: this.input.getCalculation( $input ),
	        required: this.input.getRequired( $input ),
	        readonly: this.input.getReadonly( $input ),
	        val: this.input.getVal( $input )
	    };
	    // No need to validate, **nor send validation events**. Meant for simple empty "notes" only.
	    if ( n.readonly && !n.val && !n.required && !n.constraint && !n.calculation ) {
	        return Promise.resolve();
	    }

	    // The enabled check serves a purpose only when an input field itself is marked as enabled but its parent fieldset is not.
	    // If an element is disabled mark it as valid (to undo a previously shown branch with fields marked as invalid).
	    if ( n.enabled && n.inputType !== 'hidden' ) {
	        // Only now, will we determine the index.
	        n.ind = this.input.getIndex( $input );
	        getValidationResult = this.model.node( n.path, n.ind ).validate( n.constraint, n.required, n.xmlType );
	    } else {
	        getValidationResult = Promise.resolve( {
	            requiredValid: true,
	            constraintValid: true
	        } );
	    }

	    return getValidationResult
	        .then( result => {
	            let previouslyInvalid = false;
	            const passed = result.requiredValid !== false && result.constraintValid !== false;

	            if ( n.inputType !== 'hidden' ) {
	                // Check current UI state
	                n.$q = that.input.getWrapNodes( $input );
	                previouslyInvalid = n.$q.hasClass( 'invalid-required' ) || n.$q.hasClass( 'invalid-constraint' );

	                // Update UI
	                if ( result.requiredValid === false ) {
	                    that.setValid( $input, 'constraint' );
	                    that.setInvalid( $input, 'required' );
	                } else if ( result.constraintValid === false ) {
	                    that.setValid( $input, 'required' );
	                    that.setInvalid( $input, 'constraint' );
	                } else {
	                    that.setValid( $input, 'constraint' );
	                    that.setValid( $input, 'required' );
	                }
	            }
	            // Send invalidated event
	            if ( !passed && !previouslyInvalid ) {
	                $input[ 0 ].dispatchEvent( event.Invalidated() );
	            }
	            return passed;
	        } )
	        .catch( e => {
	            console.error( 'validation error', e );
	            that.setInvalid( $input, 'constraint' );
	            throw e;
	        } );
	};

	Form.prototype.getGoToTarget = function( path ) {
	    let hits;
	    let modelNode;
	    let target;
	    let intermediateTarget;
	    let selector = '';
	    const repeatRegEx = /([^[]+)\[(\d+)\]([^[]*$)?/g;

	    if ( !path ) {
	        return;
	    }

	    modelNode = this.model.node( path ).getElement();

	    if ( !modelNode ) {
	        return;
	    }

	    // Convert to absolute path, while maintaining positions.
	    path = this.model.getXPath( modelNode, 'instance', true );

	    // Not inside a cloned repeat.
	    target = this.view.html.querySelector( `[name="${path}"]` );

	    // If inside a cloned repeat (i.e. a repeat that is not first-in-series)
	    if ( !target ) {
	        intermediateTarget = this.view.html;
	        while ( ( hits = repeatRegEx.exec( path ) ) !== null && intermediateTarget ) {
	            selector += hits[ 1 ];
	            intermediateTarget = intermediateTarget
	                .querySelectorAll( `[name="${selector}"], [data-name="${selector}"]` )[ hits[ 2 ] ];
	            if ( intermediateTarget && hits[ 3 ] ) {
	                selector += hits[ 3 ];
	                intermediateTarget = intermediateTarget
	                    .querySelector( `[name="${selector}"],[data-name="${selector}"]` );
	            }
	            target = intermediateTarget;
	        }
	    }

	    return target ? this.input.getWrapNodes( jquery( target ) ).get( 0 ) : target;
	};

	/**
	 * Scrolls to a HTML Element, flips to the page it is on and focuses on the nearest form control.
	 * 
	 * @param  {HTMLElement} target A HTML element to scroll to
	 */
	Form.prototype.goToTarget = function( target ) {
	    if ( target ) {
	        if ( this.pages.active ) {
	            // Flip to page
	            this.pages.flipToPageContaining( jquery( target ) );
	        }
	        // check if the nearest question or group is irrelevant after page flip
	        if ( target.closest( '.or-branch.disabled' ) ) {
	            // It is up to the apps to decide what to do with this event.
	            target.dispatchEvent( event.GoToHidden() );
	        }
	        // Scroll to element
	        target.scrollIntoView();
	        // Focus on the first non .ignore form control
	        // If the element is hidden (e.g. because it's been replaced by a widget), 
	        // the focus event will not fire, so we also trigger an applyfocus event that widgets can listen for.
	        const input = target.querySelector( 'input:not(.ignore), textarea:not(.ignore), select:not(.ignore)' );
	        input.focus();
	        input.dispatchEvent( event.ApplyFocus() );
	    }
	    return !!target;
	};

	/** 
	 * Static method to obtain required enketo-transform version direct from class.
	 */
	Form.requiredTransformerVersion = '1.30.1';

	angular.module('emission.survey.enketo.launch', ['emission.services',
	                    'emission.plugin.logger'])

	.controller('EnketoSurveyCtrl', function($window, $scope, $rootScope, $state,
	    $stateParams, $http, $ionicPopup, Logger) {

	    console.log("EnketoSurveyCtrl called with params = "+JSON.stringify($stateParams));

	    $scope.loadForm = function(form_location) {
	        $http.get(form_location)
	        .then(function(form_json) {
	            console.log(form_json);
	            $scope.loaded_form = form_json.data.form;
	            $scope.loaded_model = form_json.data.model;
	            $( '#dummy-form-content' ).after( $scope.loaded_form );
	            var formSelector = 'form.or:eq(0)';
	            var data = {
	                 // required string of the default instance defined in the XForm
	                 modelStr: $scope.loaded_model,
	                 // optional string of an existing instance to be edited
	                 instanceStr: null,
	                 // optional boolean whether this instance has ever been submitted before
	                 submitted: false,
	                 // optional array of external data objects containing: 
	                 // {id: 'someInstanceId', xml: XMLDocument}
	                 external: [],
	                 // optional object of session properties 
	                 // 'deviceid', 'username', 'email', 'phonenumber', 'simserial', 'subscriberid'
	                 session: {}
	            };
	            $scope.form = new Form( formSelector, data, options);
	            var loadErrors = $scope.form.init();
	            if (loadErrors.length > 0) {
	                $ionicPopup.alert({template: "loadErrors: " + loadErrors.join(",")});
	            }
	        });
	    };
	    
	    /*
	     * Initialize all the scope variables based on the paramters
	     */
	    if (!angular.isDefined($stateParams.form_location)) {
	        $ionicPopup.alert("No form location defined, going back to metrics")
	        .then(function() {
	            $state.go("root.main.metrics");
	        });
	    } else {
	        $scope.loadForm($stateParams.form_location, $stateParams.model_location);
	    }

	    $scope.validateForm = function() {
	        $scope.form.validate()
	          .then(function (valid){
	            if ( !valid ) {
	              $ionicPopup.alert( 'Form contains errors. Please see fields marked in red.' );
	            } else {
	             // Record is valid! 
	              $ionicPopup.alert('Form is valid! (see XML record in the console)');
	              console.log($scope.form.getDataStr());
	            }
	        });
	    };
	});

}());
